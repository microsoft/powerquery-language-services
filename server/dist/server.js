module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/vscode-jsonrpc/lib/cancellation.js":
/*!**********************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/cancellation.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! ./events */ "../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../node_modules/vscode-jsonrpc/lib/is.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/events.js":
/*!****************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/events.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/is.js":
/*!************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/is.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/linkedMap.js":
/*!*******************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/linkedMap.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/main.js":
/*!**************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/main.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../typings/thenable.d.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(/*! ./is */ "../node_modules/vscode-jsonrpc/lib/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-jsonrpc/lib/messages.js");
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../node_modules/vscode-jsonrpc/lib/messageReader.js");
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../node_modules/vscode-jsonrpc/lib/messageWriter.js");
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(/*! ./events */ "../node_modules/vscode-jsonrpc/lib/events.js");
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../node_modules/vscode-jsonrpc/lib/cancellation.js");
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../node_modules/vscode-jsonrpc/lib/linkedMap.js");
__export(__webpack_require__(/*! ./pipeSupport */ "../node_modules/vscode-jsonrpc/lib/pipeSupport.js"));
__export(__webpack_require__(/*! ./socketSupport */ "../node_modules/vscode-jsonrpc/lib/socketSupport.js"));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/messageReader.js":
/*!***********************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/messageReader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! ./events */ "../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../node_modules/vscode-jsonrpc/lib/is.js");
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/messageWriter.js":
/*!***********************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/messageWriter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! ./events */ "../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../node_modules/vscode-jsonrpc/lib/is.js");
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/messages.js":
/*!******************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/messages.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const is = __webpack_require__(/*! ./is */ "../node_modules/vscode-jsonrpc/lib/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    ErrorCodes.ContentModified = -32801;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 *
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
/**
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/pipeSupport.js":
/*!*********************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/pipeSupport.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(/*! path */ "path");
const os_1 = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../node_modules/vscode-jsonrpc/lib/messageReader.js");
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../node_modules/vscode-jsonrpc/lib/messageWriter.js");
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),

/***/ "../node_modules/vscode-jsonrpc/lib/socketSupport.js":
/*!***********************************************************!*\
  !*** ../node_modules/vscode-jsonrpc/lib/socketSupport.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __webpack_require__(/*! net */ "net");
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../node_modules/vscode-jsonrpc/lib/messageReader.js");
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../node_modules/vscode-jsonrpc/lib/messageWriter.js");
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/main.js":
/*!******************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/main.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
exports.ProgressType = vscode_jsonrpc_1.ProgressType;
__export(__webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js"));
__export(__webpack_require__(/*! ./protocol */ "../node_modules/vscode-languageserver-protocol/lib/protocol.js"));
const callHierarchy = __webpack_require__(/*! ./protocol.callHierarchy.proposed */ "../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js");
const st = __webpack_require__(/*! ./protocol.sematicTokens.proposed */ "../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js");
var Proposed;
(function (Proposed) {
    let CallHierarchyPrepareRequest;
    (function (CallHierarchyPrepareRequest) {
        CallHierarchyPrepareRequest.method = callHierarchy.CallHierarchyPrepareRequest.method;
        CallHierarchyPrepareRequest.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed.CallHierarchyPrepareRequest || (Proposed.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function (CallHierarchyIncomingCallsRequest) {
        CallHierarchyIncomingCallsRequest.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
        CallHierarchyIncomingCallsRequest.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed.CallHierarchyIncomingCallsRequest || (Proposed.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function (CallHierarchyOutgoingCallsRequest) {
        CallHierarchyOutgoingCallsRequest.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
        CallHierarchyOutgoingCallsRequest.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed.CallHierarchyOutgoingCallsRequest || (Proposed.CallHierarchyOutgoingCallsRequest = {}));
    Proposed.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function (SemanticTokensRequest) {
        SemanticTokensRequest.method = st.SemanticTokensRequest.method;
        SemanticTokensRequest.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function (SemanticTokensEditsRequest) {
        SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;
        SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function (SemanticTokensRangeRequest) {
        SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;
        SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));
})(Proposed = exports.Proposed || (exports.Proposed = {}));
function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/messages.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/messages.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js":
/*!************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
    /** @deprecated Use DocumentColorRequest.type */
    DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js":
/*!************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
    /** @deprecated Use DeclarationRequest.type */
    DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
    /** @deprecated Use FoldingRangeRequest.type */
    FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
    /** @deprecated Use ImplementationRequest.type */
    ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(/*! ./utils/is */ "../node_modules/vscode-languageserver-protocol/lib/utils/is.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js");
exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js");
exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
const protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ "../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js");
exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js");
exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js");
exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js");
exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js");
exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js");
exports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js");
exports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
exports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
exports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling startegy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
    /** @deprecated Use CompletionRequest.type */
    CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
    /** @deprecated Use DefinitionRequest.type */
    DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
    /** @deprecated Use ReferencesRequest.type */
    ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
    /** @deprecated Use DocumentHighlightRequest.type */
    DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
    /** @deprecated Use DocumentSymbolRequest.type */
    DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
    /** @deprecated Use CodeActionRequest.type */
    CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
    /** @deprecated Use WorkspaceSymbolRequest.type */
    WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');
    /** @deprecated Use CodeLensRequest.type */
    CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
    /** @deprecated Use DocumentLinkRequest.type */
    DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
    /** @deprecated  Use SelectionRangeRequest.type */
    SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    SemanticTokenTypes["namespace"] = "namespace";
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["member"] = "member";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["label"] = "label";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["reference"] = "reference";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["volatile"] = "volatile";
    SemanticTokenModifiers["readonly"] = "readonly";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensEditsRequest;
(function (SemanticTokensEditsRequest) {
    SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';
    SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);
})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
    /** @deprecated Use TypeDefinitionRequest.type */
    TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/utils/is.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/utils/is.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),

/***/ "../node_modules/vscode-languageserver-textdocument/lib/esm/main.js":
/*!**************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-textdocument/lib/esm/main.js ***!
  \**************************************************************************/
/*! exports provided: TextDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}


/***/ }),

/***/ "../node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!*******************************************************************!*\
  !*** ../node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \*******************************************************************/
/*! exports provided: Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Diagnostic, Command, TextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, EOL, TextDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationLink", function() { return LocationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorInformation", function() { return ColorInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPresentation", function() { return ColorPresentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRangeKind", function() { return FoldingRangeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRange", function() { return FoldingRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticRelatedInformation", function() { return DiagnosticRelatedInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticSeverity", function() { return DiagnosticSeverity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticTag", function() { return DiagnosticTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Diagnostic", function() { return Diagnostic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return Command; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEdit", function() { return TextEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentEdit", function() { return TextDocumentEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreateFile", function() { return CreateFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenameFile", function() { return RenameFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeleteFile", function() { return DeleteFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceEdit", function() { return WorkspaceEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceChange", function() { return WorkspaceChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentIdentifier", function() { return TextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VersionedTextDocumentIdentifier", function() { return VersionedTextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentItem", function() { return TextDocumentItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupKind", function() { return MarkupKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupContent", function() { return MarkupContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemKind", function() { return CompletionItemKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InsertTextFormat", function() { return InsertTextFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemTag", function() { return CompletionItemTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItem", function() { return CompletionItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionList", function() { return CompletionList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedString", function() { return MarkedString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hover", function() { return Hover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterInformation", function() { return ParameterInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignatureInformation", function() { return SignatureInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlightKind", function() { return DocumentHighlightKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlight", function() { return DocumentHighlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolKind", function() { return SymbolKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolTag", function() { return SymbolTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolInformation", function() { return SymbolInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentSymbol", function() { return DocumentSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionKind", function() { return CodeActionKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionContext", function() { return CodeActionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeAction", function() { return CodeAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeLens", function() { return CodeLens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormattingOptions", function() { return FormattingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentLink", function() { return DocumentLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionRange", function() { return SelectionRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOL", function() { return EOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.red)
            && Is.number(candidate.green)
            && Is.number(candidate.blue)
            && Is.number(candidate.alpha);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange.prototype.deleteFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange.prototype.checkDocumentChanges = function () {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.15
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void 0) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === void 0 || Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || Command.is(candidate.command)) &&
            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/configuration.js":
/*!******************************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/configuration.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "../node_modules/vscode-languageserver/lib/utils/is.js");
exports.ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/files.js":
/*!**********************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/files.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
//# sourceMappingURL=files.js.map
/* WEBPACK VAR INJECTION */}.call(this, "/index.js"))

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/main.js":
/*!*********************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/main.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../typings/thenable.d.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js");
exports.Event = vscode_languageserver_protocol_1.Event;
const configuration_1 = __webpack_require__(/*! ./configuration */ "../node_modules/vscode-languageserver/lib/configuration.js");
const workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ "../node_modules/vscode-languageserver/lib/workspaceFolders.js");
const Is = __webpack_require__(/*! ./utils/is */ "../node_modules/vscode-languageserver/lib/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "../node_modules/vscode-languageserver/lib/utils/uuid.js");
// ------------- Reexport the API surface of the language worker API ----------------------
__export(__webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js"));
const fm = __webpack_require__(/*! ./files */ "../node_modules/vscode-languageserver/lib/files.js");
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        process.exit(shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
function null2Undefined(value) {
    if (value === null) {
        return void 0;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._documents = Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not mananged by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            let document = this._documents[td.uri];
            const { version } = td;
            if (version === null || version === void 0) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            document = this._configuration.update(document, changes, version);
            this._documents[td.uri] = document;
            this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class ConnectionLogger {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this._connection);
        }
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Unregistering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this._connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this._connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let strategy;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (vscode_languageserver_protocol_1.ConnectionStrategy.is(arg1)) {
        strategy = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        strategy = arg3;
    }
    return _createConnection(input, output, strategy, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, strategy, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new vscode_languageserver_protocol_1.IPCMessageReader(process);
                output = new vscode_languageserver_protocol_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = vscode_languageserver_protocol_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = vscode_languageserver_protocol_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
    }
    const logger = (factories && factories.console ? new (factories.console(ConnectionLogger))() : new ConnectionLogger());
    const connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, strategy);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, handler),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, handler),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, handler),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), proposed_progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, proposed_progress_1.attachWorkDone(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, proposed_progress_1.attachWorkDone(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (shutdownReceived) {
                process.exit(0);
            }
            else {
                process.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
// Export the protocol currently in proposed state.
const proposed_progress_1 = __webpack_require__(/*! ./proposed.progress */ "../node_modules/vscode-languageserver/lib/proposed.progress.js");
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features',
        window: proposed_progress_1.ProgressFeature
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/proposed.progress.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/proposed.progress.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "../node_modules/vscode-languageserver/lib/utils/uuid.js");
class WorkDoneProgressImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressImpl.Instances.set(this._token, this);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.Proposed.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.Proposed.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressImpl.Instances.delete(this._token);
        this._source.dispose();
        this._connection.sendProgress(vscode_languageserver_protocol_1.Proposed.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
    cancel() {
        this._source.cancel();
    }
}
WorkDoneProgressImpl.Instances = new Map();
class NullProgress {
    constructor() {
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgress();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
exports.ProgressFeature = (Base) => {
    return class extends Base {
        initialize(cap) {
            const capabilities = cap;
            if (capabilities.window && capabilities.window.workDoneProgress) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.Proposed.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressImpl.Instances.get(params.token);
                    if (progress !== undefined) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgress();
            }
            else {
                return new WorkDoneProgressImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.Proposed.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgress());
            }
        }
    };
};
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;
//# sourceMappingURL=proposed.progress.js.map

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/utils/is.js":
/*!*************************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/utils/is.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/utils/uuid.js":
/*!***************************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/utils/uuid.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "../node_modules/vscode-languageserver/lib/workspaceFolders.js":
/*!*********************************************************************!*\
  !*** ../node_modules/vscode-languageserver/lib/workspaceFolders.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js");
exports.WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/error.js":
/*!*********************************************************!*\
  !*** ../packages/powerquery-format/lib/format/error.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
function isTFormatError(x) {
    return powerquery_parser_1.LexError.isTLexError(x) || powerquery_parser_1.ParseError.isTParseError(x);
}
exports.isTFormatError = isTFormatError;
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/format.js":
/*!**********************************************************!*\
  !*** ../packages/powerquery-format/lib/format/format.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const comment_1 = __webpack_require__(/*! ./passes/comment */ "../packages/powerquery-format/lib/format/passes/comment.js");
const isMultiline_1 = __webpack_require__(/*! ./passes/isMultiline/isMultiline */ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultiline.js");
const serializerParameter_1 = __webpack_require__(/*! ./passes/serializerParameter */ "../packages/powerquery-format/lib/format/passes/serializerParameter.js");
const serializer_1 = __webpack_require__(/*! ./serializer */ "../packages/powerquery-format/lib/format/serializer.js");
function format(formatSettings, text) {
    const triedLexParse = powerquery_parser_1.tryLexParse(formatSettings, text);
    if (triedLexParse.kind === "Err" /* Err */) {
        return triedLexParse;
    }
    const lexParseOk = triedLexParse.value;
    const ast = lexParseOk.ast;
    const comments = lexParseOk.lexerSnapshot.comments;
    const nodeIdMapCollection = lexParseOk.nodeIdMapCollection;
    const localizationTemplates = formatSettings.localizationTemplates;
    let commentCollectionMap = new Map();
    if (comments.length) {
        const triedCommentPass = comment_1.tryTraverse(localizationTemplates, ast, nodeIdMapCollection, comments);
        if (triedCommentPass.kind === "Err" /* Err */) {
            return triedCommentPass;
        }
        commentCollectionMap = triedCommentPass.value;
    }
    const triedIsMultilineMap = isMultiline_1.tryTraverse(localizationTemplates, ast, commentCollectionMap, nodeIdMapCollection);
    if (triedIsMultilineMap.kind === "Err" /* Err */) {
        return triedIsMultilineMap;
    }
    const isMultilineMap = triedIsMultilineMap.value;
    const triedSerializerParameter = serializerParameter_1.tryTraverse(localizationTemplates, ast, nodeIdMapCollection, commentCollectionMap, isMultilineMap);
    if (triedSerializerParameter.kind === "Err" /* Err */) {
        return triedSerializerParameter;
    }
    const serializerParameterMap = triedSerializerParameter.value;
    const maps = {
        commentCollectionMap,
        serializerParameterMap,
    };
    const serializeRequest = {
        localizationTemplates: localizationTemplates,
        document: lexParseOk.ast,
        nodeIdMapCollection,
        maps,
        indentationLiteral: formatSettings.indentationLiteral,
        newlineLiteral: formatSettings.newlineLiteral,
    };
    return serializer_1.Serializer.run(serializeRequest);
}
exports.format = format;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/index.js":
/*!*********************************************************!*\
  !*** ../packages/powerquery-format/lib/format/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const FormatError = __webpack_require__(/*! ./error */ "../packages/powerquery-format/lib/format/error.js");
exports.FormatError = FormatError;
__export(__webpack_require__(/*! ./format */ "../packages/powerquery-format/lib/format/format.js"));
__export(__webpack_require__(/*! ./serializer */ "../packages/powerquery-format/lib/format/serializer.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/comment.js":
/*!******************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/comment.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
function tryTraverse(localizationTemplates, root, nodeIdMapCollection, comments) {
    const state = {
        localizationTemplates,
        result: new Map(),
        comments,
        commentsIndex: 0,
        maybeCurrentComment: comments[0],
    };
    return powerquery_parser_1.Traverse.tryTraverseAst(state, nodeIdMapCollection, root, "DepthFirst" /* DepthFirst */, visitNode, powerquery_parser_1.Traverse.expectExpandAllAstChildren, earlyExit);
}
exports.tryTraverse = tryTraverse;
function earlyExit(state, node) {
    const maybeCurrentComment = state.maybeCurrentComment;
    if (maybeCurrentComment === undefined) {
        return true;
    }
    else if (node.tokenRange.positionEnd.codeUnit < maybeCurrentComment.positionStart.codeUnit) {
        return true;
    }
    else {
        return false;
    }
}
function visitNode(state, node) {
    if (!node.isLeaf) {
        return;
    }
    let maybeCurrentComment = state.maybeCurrentComment;
    while (maybeCurrentComment && maybeCurrentComment.positionStart.codeUnit < node.tokenRange.positionStart.codeUnit) {
        const currentComment = maybeCurrentComment;
        const commentMap = state.result;
        const nodeId = node.id;
        const maybeCommentCollection = commentMap.get(nodeId);
        // It's the first comment for the TNode
        if (maybeCommentCollection === undefined) {
            const commentCollection = {
                prefixedComments: [currentComment],
                prefixedCommentsContainsNewline: currentComment.containsNewline,
            };
            commentMap.set(nodeId, commentCollection);
        }
        // At least one comment already attached to the TNode
        else {
            const commentCollection = maybeCommentCollection;
            commentCollection.prefixedComments.push(currentComment);
            if (currentComment.containsNewline) {
                commentCollection.prefixedCommentsContainsNewline = true;
            }
        }
        state.commentsIndex += 1;
        maybeCurrentComment = state.comments[state.commentsIndex];
    }
    state.maybeCurrentComment = maybeCurrentComment;
}
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/common.js":
/*!*****************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/common.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
function maybeGetParent(nodeIdMapCollection, nodeId) {
    const maybeParentNodeId = nodeIdMapCollection.parentIdById.get(nodeId);
    if (maybeParentNodeId === undefined) {
        return undefined;
    }
    const parentNodeId = maybeParentNodeId;
    return powerquery_parser_1.NodeIdMapUtils.expectAstNode(nodeIdMapCollection.astNodeById, parentNodeId);
}
exports.maybeGetParent = maybeGetParent;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/isMultiline/common.js":
/*!*****************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/isMultiline/common.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
function expectGetIsMultiline(isMultilineMap, node) {
    const maybeIsMultiline = isMultilineMap.get(node.id);
    if (maybeIsMultiline === undefined) {
        const details = { nodeId: node.id };
        throw new powerquery_parser_1.CommonError.InvariantError(`isMultiline is missing an expected nodeId`, details);
    }
    return maybeIsMultiline;
}
exports.expectGetIsMultiline = expectGetIsMultiline;
function setIsMultiline(isMultilineMap, node, isMultiline) {
    isMultilineMap.set(node.id, isMultiline);
}
exports.setIsMultiline = setIsMultiline;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultiline.js":
/*!**********************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/isMultiline/isMultiline.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const isMultilineFirstPass_1 = __webpack_require__(/*! ./isMultilineFirstPass */ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineFirstPass.js");
const isMultilineSecondPass_1 = __webpack_require__(/*! ./isMultilineSecondPass */ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineSecondPass.js");
// runs a DFS pass followed by a BFS pass.
function tryTraverse(localizationTemplates, ast, commentCollectionMap, nodeIdMapCollection) {
    const triedFirstPass = isMultilineFirstPass_1.tryTraverse(localizationTemplates, ast, commentCollectionMap, nodeIdMapCollection);
    if (triedFirstPass.kind === "Err" /* Err */) {
        return triedFirstPass;
    }
    const isMultilineMap = triedFirstPass.value;
    return isMultilineSecondPass_1.tryTraverse(localizationTemplates, ast, isMultilineMap, nodeIdMapCollection);
}
exports.tryTraverse = tryTraverse;
//# sourceMappingURL=isMultiline.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineFirstPass.js":
/*!*******************************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineFirstPass.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/lib/format/passes/common.js");
const common_2 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/lib/format/passes/isMultiline/common.js");
const linearLength_1 = __webpack_require__(/*! ./linearLength */ "../packages/powerquery-format/lib/format/passes/isMultiline/linearLength.js");
function tryTraverse(localizationTemplates, ast, commentCollectionMap, nodeIdMapCollection) {
    const state = {
        localizationTemplates,
        result: new Map(),
        commentCollectionMap,
        nodeIdMapCollection,
        linearLengthMap: new Map(),
    };
    return powerquery_parser_1.Traverse.tryTraverseAst(state, nodeIdMapCollection, ast, "DepthFirst" /* DepthFirst */, visitNode, powerquery_parser_1.Traverse.expectExpandAllAstChildren, undefined);
}
exports.tryTraverse = tryTraverse;
const InvokeExpressionIdentifierLinearLengthExclusions = [
    "#datetime",
    "#datetimezone",
    "#duration",
    "#time",
];
const TBinOpExpressionLinearLengthThreshold = 40;
const InvokeExpressionLinearLengthThreshold = 40;
function visitNode(state, node) {
    const isMultilineMap = state.result;
    let isMultiline = false;
    switch (node.kind) {
        // TPairedConstant
        case "AsNullablePrimitiveType" /* AsNullablePrimitiveType */:
        case "AsType" /* AsType */:
        case "EachExpression" /* EachExpression */:
        case "ErrorRaisingExpression" /* ErrorRaisingExpression */:
        case "IsNullablePrimitiveType" /* IsNullablePrimitiveType */:
        case "NullablePrimitiveType" /* NullablePrimitiveType */:
        case "NullableType" /* NullableType */:
        case "OtherwiseExpression" /* OtherwiseExpression */:
        case "TypePrimaryType" /* TypePrimaryType */:
            isMultiline = isAnyMultiline(isMultilineMap, node.constant, node.paired);
            break;
        // TBinOpExpression
        case "IsExpression" /* IsExpression */:
        case "AsExpression" /* AsExpression */:
        case "ArithmeticExpression" /* ArithmeticExpression */:
        case "EqualityExpression" /* EqualityExpression */:
        case "LogicalExpression" /* LogicalExpression */:
        case "RelationalExpression" /* RelationalExpression */: {
            const left = node.left;
            const right = node.right;
            if ((powerquery_parser_1.AstUtils.isTBinOpExpression(left) && containsLogicalExpression(left)) ||
                (powerquery_parser_1.AstUtils.isTBinOpExpression(right) && containsLogicalExpression(right))) {
                isMultiline = true;
            }
            const linearLength = linearLength_1.getLinearLength(state.localizationTemplates, state.linearLengthMap, state.nodeIdMapCollection, node);
            if (linearLength > TBinOpExpressionLinearLengthThreshold) {
                isMultiline = true;
            }
            else {
                isMultiline = isAnyMultiline(isMultilineMap, left, node.operatorConstant, right);
            }
            break;
        }
        // TKeyValuePair
        case "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */:
        case "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */:
        case "IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */:
        case "IdentifierPairedExpression" /* IdentifierPairedExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.key, node.equalConstant, node.value);
            break;
        // Possible for a parent to assign an isMultiline override.
        case "ArrayWrapper" /* ArrayWrapper */:
            isMultiline = isAnyMultiline(isMultilineMap, ...node.elements);
            break;
        case "ListExpression" /* ListExpression */:
        case "ListLiteral" /* ListLiteral */:
        case "RecordExpression" /* RecordExpression */:
        case "RecordLiteral" /* RecordLiteral */: {
            if (node.content.elements.length > 1) {
                isMultiline = true;
            }
            else {
                const isAnyChildMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.closeWrapperConstant, ...node.content.elements);
                if (isAnyChildMultiline) {
                    isMultiline = true;
                }
                else {
                    const csvs = node.content.elements;
                    const csvNodes = csvs.map((csv) => csv.node);
                    isMultiline = isAnyListOrRecord(csvNodes);
                }
            }
            common_2.setIsMultiline(isMultilineMap, node.content, isMultiline);
            break;
        }
        case "Csv" /* Csv */:
            isMultiline = isAnyMultiline(isMultilineMap, node.node, node.maybeCommaConstant);
            break;
        case "ErrorHandlingExpression" /* ErrorHandlingExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.tryConstant, node.protectedExpression, node.maybeOtherwiseExpression);
            break;
        case "FieldProjection" /* FieldProjection */:
            isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.closeWrapperConstant, node.maybeOptionalConstant, ...node.content.elements);
            break;
        case "FieldSelector" /* FieldSelector */:
            isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.content, node.closeWrapperConstant, node.maybeOptionalConstant);
            break;
        case "FieldSpecification" /* FieldSpecification */:
            isMultiline = isAnyMultiline(isMultilineMap, node.maybeOptionalConstant, node.name, node.maybeFieldTypeSpecification);
            break;
        case "FieldSpecificationList" /* FieldSpecificationList */: {
            const fieldArray = node.content;
            const fields = fieldArray.elements;
            if (fields.length > 1) {
                isMultiline = true;
            }
            else if (fields.length === 1 && node.maybeOpenRecordMarkerConstant) {
                isMultiline = true;
            }
            common_2.setIsMultiline(isMultilineMap, fieldArray, isMultiline);
            break;
        }
        case "FieldTypeSpecification" /* FieldTypeSpecification */:
            isMultiline = isAnyMultiline(isMultilineMap, node.equalConstant, node.fieldType);
            break;
        case "FunctionExpression" /* FunctionExpression */:
            isMultiline = common_2.expectGetIsMultiline(isMultilineMap, node.expression);
            break;
        case "IdentifierExpression" /* IdentifierExpression */: {
            isMultiline = isAnyMultiline(isMultilineMap, node.maybeInclusiveConstant, node.identifier);
            break;
        }
        case "IfExpression" /* IfExpression */:
            isMultiline = true;
            break;
        case "InvokeExpression" /* InvokeExpression */: {
            const nodeIdMapCollection = state.nodeIdMapCollection;
            const args = node.content.elements;
            if (args.length > 1) {
                const linearLengthMap = state.linearLengthMap;
                const linearLength = linearLength_1.getLinearLength(state.localizationTemplates, linearLengthMap, nodeIdMapCollection, node);
                const maybeArrayWrapper = common_1.maybeGetParent(nodeIdMapCollection, node.id);
                if (maybeArrayWrapper === undefined || maybeArrayWrapper.kind !== "ArrayWrapper" /* ArrayWrapper */) {
                    throw new powerquery_parser_1.CommonError.InvariantError("InvokeExpression must have ArrayWrapper as a parent");
                }
                const arrayWrapper = maybeArrayWrapper;
                const maybeRecursivePrimaryExpression = common_1.maybeGetParent(nodeIdMapCollection, arrayWrapper.id);
                if (maybeRecursivePrimaryExpression === undefined ||
                    maybeRecursivePrimaryExpression.kind !== "RecursivePrimaryExpression" /* RecursivePrimaryExpression */) {
                    throw new powerquery_parser_1.CommonError.InvariantError("ArrayWrapper must have RecursivePrimaryExpression as a parent");
                }
                const recursivePrimaryExpression = maybeRecursivePrimaryExpression;
                const headLinearLength = linearLength_1.getLinearLength(state.localizationTemplates, linearLengthMap, nodeIdMapCollection, recursivePrimaryExpression.head);
                const compositeLinearLength = headLinearLength + linearLength;
                // if it's beyond the threshold check if it's a long literal
                // ex. `#datetimezone(2013,02,26, 09,15,00, 09,00)`
                if (compositeLinearLength > InvokeExpressionLinearLengthThreshold) {
                    const maybeName = powerquery_parser_1.NodeIdMapUtils.maybeInvokeExpressionName(nodeIdMapCollection, node.id);
                    if (maybeName) {
                        const name = maybeName;
                        isMultiline = InvokeExpressionIdentifierLinearLengthExclusions.indexOf(name) === -1;
                    }
                    common_2.setIsMultiline(isMultilineMap, node.content, isMultiline);
                }
                else {
                    isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.closeWrapperConstant, ...args);
                }
            }
            else {
                // a single argument can still be multiline
                // ex. `foo(if true then 1 else 0)`
                isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.closeWrapperConstant, ...args);
            }
            break;
        }
        case "ItemAccessExpression" /* ItemAccessExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.maybeOptionalConstant, node.content, node.closeWrapperConstant, node.maybeOptionalConstant);
            break;
        case "LetExpression" /* LetExpression */:
            isMultiline = true;
            common_2.setIsMultiline(isMultilineMap, node.variableList, true);
            break;
        case "LiteralExpression" /* LiteralExpression */:
            if (node.literalKind === "Str" /* Str */ && containsNewline(node.literal)) {
                isMultiline = true;
            }
            break;
        case "ListType" /* ListType */:
            isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.content, node.closeWrapperConstant);
            break;
        case "MetadataExpression" /* MetadataExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.left, node.operatorConstant, node.right);
            break;
        case "ParenthesizedExpression" /* ParenthesizedExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.openWrapperConstant, node.content, node.closeWrapperConstant);
            break;
        case "PrimitiveType" /* PrimitiveType */:
            isMultiline = common_2.expectGetIsMultiline(isMultilineMap, node.primitiveType);
            break;
        case "RangeExpression" /* RangeExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.left, node.rangeConstant, node.right);
            break;
        case "RecordType" /* RecordType */:
            isMultiline = common_2.expectGetIsMultiline(isMultilineMap, node.fields);
            break;
        case "RecursivePrimaryExpression" /* RecursivePrimaryExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, node.head, ...node.recursiveExpressions.elements);
            break;
        case "Section" /* Section */:
            if (node.sectionMembers.elements.length) {
                isMultiline = true;
            }
            else {
                isMultiline = isAnyMultiline(isMultilineMap, node.maybeLiteralAttributes, node.sectionConstant, node.maybeName, node.semicolonConstant, ...node.sectionMembers.elements);
            }
            break;
        case "SectionMember" /* SectionMember */:
            isMultiline = isAnyMultiline(isMultilineMap, node.maybeLiteralAttributes, node.maybeSharedConstant, node.namePairedExpression, node.semicolonConstant);
            break;
        case "TableType" /* TableType */:
            isMultiline = isAnyMultiline(isMultilineMap, node.tableConstant, node.rowType);
            break;
        case "UnaryExpression" /* UnaryExpression */:
            isMultiline = isAnyMultiline(isMultilineMap, ...node.operators.elements);
            break;
        // no-op nodes
        case "Constant" /* Constant */:
        case "FunctionType" /* FunctionType */:
        case "GeneralizedIdentifier" /* GeneralizedIdentifier */:
        case "Identifier" /* Identifier */:
        case "NotImplementedExpression" /* NotImplementedExpression */:
        case "Parameter" /* Parameter */:
        case "ParameterList" /* ParameterList */:
            break;
        default:
            throw powerquery_parser_1.isNever(node);
    }
    setIsMultilineWithCommentCheck(state, node, isMultiline);
}
function isAnyListOrRecord(nodes) {
    for (const node of nodes) {
        switch (node.kind) {
            case "ListExpression" /* ListExpression */:
            case "ListLiteral" /* ListLiteral */:
            case "RecordExpression" /* RecordExpression */:
            case "RecordLiteral" /* RecordLiteral */:
                return true;
            default:
                break;
        }
    }
    return false;
}
function isAnyMultiline(isMultilineMap, ...maybeNodes) {
    for (const maybeNode of maybeNodes) {
        if (maybeNode && common_2.expectGetIsMultiline(isMultilineMap, maybeNode)) {
            return true;
        }
    }
    return false;
}
function setIsMultilineWithCommentCheck(state, node, isMultiline) {
    if (precededByMultilineComment(state, node)) {
        isMultiline = true;
    }
    common_2.setIsMultiline(state.result, node, isMultiline);
}
function precededByMultilineComment(state, node) {
    const maybeCommentCollection = state.commentCollectionMap.get(node.id);
    if (maybeCommentCollection) {
        return maybeCommentCollection.prefixedCommentsContainsNewline;
    }
    else {
        return false;
    }
}
function containsNewline(text) {
    const textLength = text.length;
    for (let index = 0; index < textLength; index += 1) {
        if (powerquery_parser_1.StringUtils.maybeNewlineKindAt(text, index)) {
            return true;
        }
    }
    return false;
}
function containsLogicalExpression(node) {
    if (!powerquery_parser_1.AstUtils.isTBinOpExpression(node)) {
        return false;
    }
    const left = node.left;
    const right = node.right;
    return (node.kind === "LogicalExpression" /* LogicalExpression */ ||
        (powerquery_parser_1.AstUtils.isTBinOpExpression(left) && containsLogicalExpression(left)) ||
        (powerquery_parser_1.AstUtils.isTBinOpExpression(right) && containsLogicalExpression(right)));
}
//# sourceMappingURL=isMultilineFirstPass.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineSecondPass.js":
/*!********************************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/isMultiline/isMultilineSecondPass.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/lib/format/passes/common.js");
const common_2 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/lib/format/passes/isMultiline/common.js");
function tryTraverse(localizationTemplates, ast, isMultilineMap, nodeIdMapCollection) {
    const state = {
        localizationTemplates,
        result: isMultilineMap,
        nodeIdMapCollection,
    };
    return powerquery_parser_1.Traverse.tryTraverseAst(state, nodeIdMapCollection, ast, "BreadthFirst" /* BreadthFirst */, visitNode, powerquery_parser_1.Traverse.expectExpandAllAstChildren, undefined);
}
exports.tryTraverse = tryTraverse;
function visitNode(state, node) {
    switch (node.kind) {
        // TBinOpExpression
        case "ArithmeticExpression" /* ArithmeticExpression */:
        case "AsExpression" /* AsExpression */:
        case "EqualityExpression" /* EqualityExpression */:
        case "IsExpression" /* IsExpression */:
        case "LogicalExpression" /* LogicalExpression */:
        case "RelationalExpression" /* RelationalExpression */: {
            const isMultilineMap = state.result;
            const maybeParent = common_1.maybeGetParent(state.nodeIdMapCollection, node.id);
            if (maybeParent &&
                powerquery_parser_1.AstUtils.isTBinOpExpression(maybeParent) &&
                common_2.expectGetIsMultiline(isMultilineMap, maybeParent)) {
                common_2.setIsMultiline(isMultilineMap, node, true);
            }
            break;
        }
        // If a list or record is a child node,
        // Then by default it should be considered multiline if it has one or more values
        case "ListExpression" /* ListExpression */:
        case "ListLiteral" /* ListLiteral */:
        case "RecordExpression" /* RecordExpression */:
        case "RecordLiteral" /* RecordLiteral */:
            if (node.content.elements.length) {
                const nodeIdMapCollection = state.nodeIdMapCollection;
                let maybeParent = common_1.maybeGetParent(nodeIdMapCollection, node.id);
                let maybeCsv;
                let maybeArrayWrapper;
                if (maybeParent && maybeParent.kind === "Csv" /* Csv */) {
                    maybeCsv = maybeParent;
                    maybeParent = common_1.maybeGetParent(nodeIdMapCollection, maybeParent.id);
                }
                if (maybeParent && maybeParent.kind === "ArrayWrapper" /* ArrayWrapper */) {
                    maybeArrayWrapper = maybeParent;
                    maybeParent = common_1.maybeGetParent(nodeIdMapCollection, maybeParent.id);
                }
                if (maybeParent) {
                    const parent = maybeParent;
                    switch (parent.kind) {
                        case "ItemAccessExpression" /* ItemAccessExpression */:
                        case "InvokeExpression" /* InvokeExpression */:
                        case "FunctionExpression" /* FunctionExpression */:
                        case "Section" /* Section */:
                        case "SectionMember" /* SectionMember */:
                            break;
                        default: {
                            const isMultilineMap = state.result;
                            common_2.setIsMultiline(isMultilineMap, parent, true);
                            if (maybeCsv) {
                                common_2.setIsMultiline(isMultilineMap, maybeCsv, true);
                            }
                            if (maybeArrayWrapper) {
                                common_2.setIsMultiline(isMultilineMap, maybeArrayWrapper, true);
                            }
                            common_2.setIsMultiline(isMultilineMap, node, true);
                            common_2.setIsMultiline(isMultilineMap, node.content, true);
                        }
                    }
                }
            }
            break;
        default:
            break;
    }
}
//# sourceMappingURL=isMultilineSecondPass.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/isMultiline/linearLength.js":
/*!***********************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/isMultiline/linearLength.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
// Lazy evaluation of a potentially large AST.
// Returns the text length of the node if IsMultiline is set to false.
// Nodes which can't ever have a linear length (such as IfExpressions) will evaluate to NaN.
function getLinearLength(localizationTemplates, linearLengthMap, nodeIdMapCollection, node) {
    const nodeId = node.id;
    const maybeLinearLength = linearLengthMap.get(nodeId);
    if (maybeLinearLength === undefined) {
        const linearLength = calculateLinearLength(localizationTemplates, node, nodeIdMapCollection, linearLengthMap);
        linearLengthMap.set(nodeId, linearLength);
        return linearLength;
    }
    else {
        return maybeLinearLength;
    }
}
exports.getLinearLength = getLinearLength;
function calculateLinearLength(localizationTemplates, node, nodeIdMapCollection, linearLengthMap) {
    const state = {
        localizationTemplates,
        result: 0,
        nodeIdMapCollection,
        linearLengthMap,
    };
    const triedTraverse = powerquery_parser_1.Traverse.tryTraverseAst(state, nodeIdMapCollection, node, "DepthFirst" /* DepthFirst */, visitNode, powerquery_parser_1.Traverse.expectExpandAllAstChildren, undefined);
    if (triedTraverse.kind === "Err" /* Err */) {
        throw triedTraverse.error;
    }
    else {
        return triedTraverse.value;
    }
}
function visitNode(state, node) {
    let linearLength;
    switch (node.kind) {
        // TPairedConstant
        case "AsNullablePrimitiveType" /* AsNullablePrimitiveType */:
        case "AsType" /* AsType */:
        case "EachExpression" /* EachExpression */:
        case "ErrorRaisingExpression" /* ErrorRaisingExpression */:
        case "IsNullablePrimitiveType" /* IsNullablePrimitiveType */:
        case "NullablePrimitiveType" /* NullablePrimitiveType */:
        case "NullableType" /* NullableType */:
        case "OtherwiseExpression" /* OtherwiseExpression */:
        case "TypePrimaryType" /* TypePrimaryType */:
            linearLength = sumLinearLengths(state, 1, node.constant, node.paired);
            break;
        // TBinOpExpression
        case "AsExpression" /* AsExpression */:
        case "ArithmeticExpression" /* ArithmeticExpression */:
        case "EqualityExpression" /* EqualityExpression */:
        case "IsExpression" /* IsExpression */:
        case "LogicalExpression" /* LogicalExpression */:
        case "RelationalExpression" /* RelationalExpression */: {
            linearLength = sumLinearLengths(state, 2, node.left, node.operatorConstant, node.right);
            break;
        }
        // TKeyValuePair
        case "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */:
        case "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */:
        case "IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */:
        case "IdentifierPairedExpression" /* IdentifierPairedExpression */:
            linearLength = sumLinearLengths(state, 2, node.key, node.equalConstant, node.value);
            break;
        // TWrapped where Content is TCsv[] and no extra attributes
        case "InvokeExpression" /* InvokeExpression */:
        case "ListExpression" /* ListExpression */:
        case "ListLiteral" /* ListLiteral */:
        case "ParameterList" /* ParameterList */:
        case "RecordExpression" /* RecordExpression */:
        case "RecordLiteral" /* RecordLiteral */: {
            const elements = node.content.elements;
            const numElements = elements.length;
            linearLength = sumLinearLengths(state, numElements ? numElements - 1 : 0, node.openWrapperConstant, node.closeWrapperConstant, ...elements);
            break;
        }
        case "ArrayWrapper" /* ArrayWrapper */:
            linearLength = sumLinearLengths(state, 0, ...node.elements);
            break;
        case "Constant" /* Constant */:
            linearLength = node.constantKind.length;
            break;
        case "Csv" /* Csv */:
            linearLength = sumLinearLengths(state, 0, node.node, node.maybeCommaConstant);
            break;
        case "ErrorHandlingExpression" /* ErrorHandlingExpression */: {
            let initialLength = 1;
            if (node.maybeOtherwiseExpression) {
                initialLength += 2;
            }
            linearLength = sumLinearLengths(state, initialLength, node.tryConstant, node.protectedExpression, node.maybeOtherwiseExpression);
            break;
        }
        case "FieldProjection" /* FieldProjection */:
            linearLength = sumLinearLengths(state, 0, node.openWrapperConstant, node.closeWrapperConstant, node.maybeOptionalConstant, ...node.content.elements);
            break;
        case "FieldSelector" /* FieldSelector */:
            linearLength = sumLinearLengths(state, 0, node.openWrapperConstant, node.content, node.closeWrapperConstant, node.maybeOptionalConstant);
            break;
        case "FieldSpecification" /* FieldSpecification */:
            linearLength = sumLinearLengths(state, 0, node.maybeOptionalConstant, node.name, node.maybeFieldTypeSpecification);
            break;
        case "FieldSpecificationList" /* FieldSpecificationList */: {
            const elements = node.content.elements;
            let initialLength = 0;
            if (node.maybeOpenRecordMarkerConstant && elements.length) {
                initialLength += 2;
            }
            linearLength = sumLinearLengths(state, initialLength, node.openWrapperConstant, node.closeWrapperConstant, node.maybeOpenRecordMarkerConstant, ...elements);
            break;
        }
        case "FieldTypeSpecification" /* FieldTypeSpecification */:
            linearLength = sumLinearLengths(state, 2, node.equalConstant, node.fieldType);
            break;
        case "FunctionExpression" /* FunctionExpression */: {
            let initialLength = 2;
            if (node.maybeFunctionReturnType) {
                initialLength += 2;
            }
            linearLength = sumLinearLengths(state, initialLength, node.parameters, node.maybeFunctionReturnType, node.fatArrowConstant, node.expression);
            break;
        }
        case "FunctionType" /* FunctionType */:
            linearLength = sumLinearLengths(state, 2, node.functionConstant, node.parameters, node.functionReturnType);
            break;
        case "GeneralizedIdentifier" /* GeneralizedIdentifier */:
        case "Identifier" /* Identifier */:
            linearLength = node.literal.length;
            break;
        case "IdentifierExpression" /* IdentifierExpression */:
            linearLength = sumLinearLengths(state, 0, node.maybeInclusiveConstant, node.identifier);
            break;
        case "ItemAccessExpression" /* ItemAccessExpression */:
            linearLength = sumLinearLengths(state, 0, node.openWrapperConstant, node.content, node.closeWrapperConstant, node.maybeOptionalConstant);
            break;
        case "LiteralExpression" /* LiteralExpression */:
            linearLength = node.literal.length;
            break;
        case "ListType" /* ListType */:
            linearLength = sumLinearLengths(state, 0, node.openWrapperConstant, node.content, node.closeWrapperConstant);
            break;
        case "MetadataExpression" /* MetadataExpression */: {
            linearLength = sumLinearLengths(state, 2, node.left, node.operatorConstant, node.right);
            break;
        }
        case "NotImplementedExpression" /* NotImplementedExpression */:
            linearLength = sumLinearLengths(state, 0, node.ellipsisConstant);
            break;
        case "Parameter" /* Parameter */: {
            let initialLength = 0;
            if (node.maybeOptionalConstant) {
                initialLength += 1;
            }
            if (node.maybeParameterType) {
                initialLength += 1;
            }
            linearLength = sumLinearLengths(state, initialLength, node.maybeOptionalConstant, node.name, node.maybeParameterType);
            break;
        }
        case "ParenthesizedExpression" /* ParenthesizedExpression */:
            linearLength = sumLinearLengths(state, 0, node.openWrapperConstant, node.content, node.closeWrapperConstant);
            break;
        case "PrimitiveType" /* PrimitiveType */:
            linearLength = getLinearLength(state.localizationTemplates, state.linearLengthMap, state.nodeIdMapCollection, node.primitiveType);
            break;
        case "RangeExpression" /* RangeExpression */:
            linearLength = sumLinearLengths(state, 0, node.left, node.rangeConstant, node.right);
            break;
        case "RecordType" /* RecordType */:
            linearLength = sumLinearLengths(state, 0, node.fields);
            break;
        case "RecursivePrimaryExpression" /* RecursivePrimaryExpression */:
            linearLength = sumLinearLengths(state, 0, node.head, ...node.recursiveExpressions.elements);
            break;
        case "SectionMember" /* SectionMember */: {
            let initialLength = 0;
            if (node.maybeLiteralAttributes) {
                initialLength += 1;
            }
            if (node.maybeSharedConstant) {
                initialLength += 1;
            }
            linearLength = sumLinearLengths(state, initialLength, node.maybeLiteralAttributes, node.maybeSharedConstant, node.namePairedExpression, node.semicolonConstant);
            break;
        }
        case "Section" /* Section */: {
            const sectionMembers = node.sectionMembers.elements;
            if (sectionMembers.length) {
                linearLength = NaN;
            }
            else {
                let initialLength = 0;
                if (node.maybeLiteralAttributes) {
                    initialLength += 1;
                }
                if (node.maybeName) {
                    initialLength += 1;
                }
                linearLength = sumLinearLengths(state, initialLength, node.maybeLiteralAttributes, node.sectionConstant, node.maybeName, node.semicolonConstant, ...sectionMembers);
            }
            break;
        }
        case "TableType" /* TableType */:
            linearLength = sumLinearLengths(state, 1, node.tableConstant, node.rowType);
            break;
        case "UnaryExpression" /* UnaryExpression */:
            linearLength = sumLinearLengths(state, 1, node.typeExpression, ...node.operators.elements);
            break;
        // is always multiline, therefore cannot have linear line length
        case "IfExpression" /* IfExpression */:
        case "LetExpression" /* LetExpression */:
            linearLength = NaN;
            break;
        default:
            throw powerquery_parser_1.isNever(node);
    }
    state.linearLengthMap.set(node.id, linearLength);
    state.result = linearLength;
}
function sumLinearLengths(state, initialLength, ...maybeNodes) {
    let summedLinearLength = initialLength;
    for (const maybeNode of maybeNodes) {
        if (maybeNode) {
            const nodeLinearLength = getLinearLength(state.localizationTemplates, state.linearLengthMap, state.nodeIdMapCollection, maybeNode);
            summedLinearLength += nodeLinearLength;
        }
    }
    return summedLinearLength;
}
//# sourceMappingURL=linearLength.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/passes/serializerParameter.js":
/*!******************************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/passes/serializerParameter.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const common_1 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/lib/format/passes/common.js");
const common_2 = __webpack_require__(/*! ./isMultiline/common */ "../packages/powerquery-format/lib/format/passes/isMultiline/common.js");
function tryTraverse(localizationTemplates, ast, nodeIdMapCollection, commentCollectionMap, isMultilineMap) {
    const state = {
        result: {
            writeKind: new Map(),
            indentationChange: new Map(),
            comments: new Map(),
        },
        localizationTemplates,
        nodeIdMapCollection,
        commentCollectionMap,
        isMultilineMap,
        workspaceMap: new Map(),
    };
    return powerquery_parser_1.Traverse.tryTraverseAst(state, nodeIdMapCollection, ast, "BreadthFirst" /* BreadthFirst */, visitNode, powerquery_parser_1.Traverse.expectExpandAllAstChildren, undefined);
}
exports.tryTraverse = tryTraverse;
function getSerializerWriteKind(node, serializerParametersMap) {
    const maybeWriteKind = serializerParametersMap.writeKind.get(node.id);
    if (maybeWriteKind) {
        return maybeWriteKind;
    }
    else {
        const details = { node };
        throw new powerquery_parser_1.CommonError.InvariantError("expected node to be in SerializerParameterMap.writeKind", details);
    }
}
exports.getSerializerWriteKind = getSerializerWriteKind;
const DefaultWorkspace = {
    maybeWriteKind: "Any" /* Any */,
    maybeIndentationChange: undefined,
};
function visitNode(state, node) {
    switch (node.kind) {
        case "ArrayWrapper" /* ArrayWrapper */: {
            const parent = powerquery_parser_1.NodeIdMapUtils.expectParentAstNode(state.nodeIdMapCollection, node.id);
            switch (parent.kind) {
                case "Section" /* Section */:
                    visitArrayWrapperForSectionMembers(state, parent.sectionMembers);
                    break;
                case "UnaryExpression" /* UnaryExpression */:
                    visitArrayWrapperForUnaryExpression(state, parent.operators);
                    break;
                default:
                    visitArrayWrapper(state, node);
                    break;
            }
            break;
        }
        // TPairedConstant
        case "AsNullablePrimitiveType" /* AsNullablePrimitiveType */:
        case "AsType" /* AsType */:
        case "EachExpression" /* EachExpression */:
        case "IsNullablePrimitiveType" /* IsNullablePrimitiveType */:
        case "NullablePrimitiveType" /* NullablePrimitiveType */:
        case "NullableType" /* NullableType */:
        case "OtherwiseExpression" /* OtherwiseExpression */: {
            propagateWriteKind(state, node, node.constant);
            const isPairedMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node.paired);
            if (isPairedMultiline) {
                setWorkspace(state, node.paired, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            else {
                setWorkspace(state, node.paired, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        // TBinOpExpression
        case "ArithmeticExpression" /* ArithmeticExpression */:
        case "AsExpression" /* AsExpression */:
        case "EqualityExpression" /* EqualityExpression */:
        case "IsExpression" /* IsExpression */:
        case "LogicalExpression" /* LogicalExpression */:
        case "RelationalExpression" /* RelationalExpression */: {
            propagateWriteKind(state, node, node.left);
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            if (isMultiline) {
                setWorkspace(state, node.operatorConstant, { maybeWriteKind: "Indented" /* Indented */ });
                setWorkspace(state, node.right, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            else if (node.kind === "LogicalExpression" /* LogicalExpression */ && isMultiline) {
                setWorkspace(state, node.operatorConstant, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
                setWorkspace(state, node.right, { maybeWriteKind: "Indented" /* Indented */ });
            }
            else {
                setWorkspace(state, node.operatorConstant, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
                setWorkspace(state, node.right, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        // TKeyValuePair
        case "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */:
        case "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */:
        case "IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */:
        case "IdentifierPairedExpression" /* IdentifierPairedExpression */:
            visitKeyValuePair(state, node);
            break;
        case "ListLiteral" /* ListLiteral */:
        case "ListExpression" /* ListExpression */:
        case "RecordExpression" /* RecordExpression */:
        case "RecordLiteral" /* RecordLiteral */:
            visitWrapped(state, node);
            break;
        case "Csv" /* Csv */: {
            const workspace = getWorkspace(state, node);
            const maybeWriteKind = workspace.maybeWriteKind;
            propagateWriteKind(state, node, node.node);
            if (node.maybeCommaConstant && maybeWriteKind !== "Indented" /* Indented */) {
                const commaConstant = node.maybeCommaConstant;
                setWorkspace(state, commaConstant, { maybeWriteKind: "PaddedRight" /* PaddedRight */ });
            }
            break;
        }
        case "ErrorHandlingExpression" /* ErrorHandlingExpression */: {
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            propagateWriteKind(state, node, node.tryConstant);
            const protectedIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node.protectedExpression);
            if (protectedIsMultiline) {
                setWorkspace(state, node.protectedExpression, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            else {
                setWorkspace(state, node.protectedExpression, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            if (node.maybeOtherwiseExpression) {
                const otherwiseExpression = node.maybeOtherwiseExpression;
                let otherwiseWriteKind;
                if (isMultiline) {
                    otherwiseWriteKind = "Indented" /* Indented */;
                }
                else {
                    otherwiseWriteKind = "PaddedLeft" /* PaddedLeft */;
                }
                setWorkspace(state, otherwiseExpression, { maybeWriteKind: otherwiseWriteKind });
            }
            break;
        }
        // TPairedConstant override
        case "ErrorRaisingExpression" /* ErrorRaisingExpression */: {
            propagateWriteKind(state, node, node.constant);
            let pairedWorkspace;
            switch (node.paired.kind) {
                case "ListExpression" /* ListExpression */:
                case "RecordExpression" /* RecordExpression */:
                    pairedWorkspace = {
                        maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
                    };
                    break;
                default:
                    const pairedIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node.paired);
                    if (pairedIsMultiline) {
                        pairedWorkspace = {
                            maybeIndentationChange: 1,
                            maybeWriteKind: "Indented" /* Indented */,
                        };
                    }
                    else {
                        pairedWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
                    }
                    break;
            }
            setWorkspace(state, node.paired, pairedWorkspace);
            break;
        }
        case "FieldProjection" /* FieldProjection */:
            visitWrapped(state, node);
            break;
        case "FieldSelector" /* FieldSelector */:
            propagateWriteKind(state, node, node.openWrapperConstant);
            break;
        case "FieldSpecification" /* FieldSpecification */: {
            const maybeOptionalConstant = node.maybeOptionalConstant;
            if (maybePropagateWriteKind(state, node, maybeOptionalConstant)) {
                setWorkspace(state, node.name, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            else {
                propagateWriteKind(state, node, node.name);
            }
            const maybeFieldTypeSpecification = node.maybeFieldTypeSpecification;
            if (maybeFieldTypeSpecification) {
                const fieldTypeSpecification = maybeFieldTypeSpecification;
                const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, fieldTypeSpecification);
                let typeWorkspace;
                if (isMultiline) {
                    typeWorkspace = {
                        maybeIndentationChange: 1,
                        maybeWriteKind: "Indented" /* Indented */,
                    };
                }
                else {
                    typeWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
                }
                setWorkspace(state, fieldTypeSpecification, typeWorkspace);
            }
            break;
        }
        case "FieldSpecificationList" /* FieldSpecificationList */: {
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            const fieldsArray = node.content;
            visitWrapped(state, node);
            if (node.maybeOpenRecordMarkerConstant) {
                const openRecordMarkerConstant = node.maybeOpenRecordMarkerConstant;
                let workspace;
                if (isMultiline) {
                    workspace = {
                        maybeIndentationChange: 1,
                        maybeWriteKind: "Indented" /* Indented */,
                    };
                }
                else if (fieldsArray.elements.length) {
                    workspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
                }
                else {
                    workspace = { maybeWriteKind: "Any" /* Any */ };
                }
                setWorkspace(state, openRecordMarkerConstant, workspace);
            }
            break;
        }
        case "FieldTypeSpecification" /* FieldTypeSpecification */: {
            // can't use propagateWriteKind as I want the equalConstant on the
            // same line as the previous node (FieldParameter).
            const workspace = getWorkspace(state, node);
            // assumes SerializerWriteKind.Indented -> maybeIndentationChange === 1
            if (workspace.maybeWriteKind === "Indented" /* Indented */) {
                setWorkspace(state, node.equalConstant, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
                setWorkspace(state, node.fieldType, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            else {
                propagateWriteKind(state, node, node.equalConstant);
                setWorkspace(state, node.fieldType, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        case "FunctionExpression" /* FunctionExpression */: {
            propagateWriteKind(state, node, node.parameters);
            if (node.maybeFunctionReturnType) {
                const functionReturnType = node.maybeFunctionReturnType;
                setWorkspace(state, functionReturnType, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            setWorkspace(state, node.fatArrowConstant, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            const expressionIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node.expression);
            let expressionWorkspace;
            if (expressionIsMultiline) {
                expressionWorkspace = {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                };
            }
            else {
                expressionWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
            }
            setWorkspace(state, node.expression, expressionWorkspace);
            break;
        }
        case "FunctionType" /* FunctionType */: {
            propagateWriteKind(state, node, node.functionConstant);
            const commonWorkspace = {
                maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
            };
            setWorkspace(state, node.parameters, commonWorkspace);
            setWorkspace(state, node.functionReturnType, commonWorkspace);
            break;
        }
        case "IdentifierExpression" /* IdentifierExpression */:
            if (maybePropagateWriteKind(state, node, node.maybeInclusiveConstant)) {
                setWorkspace(state, node.identifier, DefaultWorkspace);
            }
            else {
                propagateWriteKind(state, node, node.identifier);
            }
            break;
        case "IfExpression" /* IfExpression */:
            visitIfExpression(state, node);
            break;
        case "InvokeExpression" /* InvokeExpression */:
            visitWrapped(state, node);
            break;
        case "ItemAccessExpression" /* ItemAccessExpression */: {
            const isMultilineMap = state.isMultilineMap;
            const isMultiline = common_2.expectGetIsMultiline(isMultilineMap, node);
            const itemSelector = node.content;
            const itemSelectorIsMultiline = common_2.expectGetIsMultiline(isMultilineMap, itemSelector);
            visitWrapped(state, node);
            if (isMultiline) {
                setWorkspace(state, itemSelector, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            let closeWrapperConstantWorkspace;
            if (itemSelectorIsMultiline) {
                switch (itemSelector.kind) {
                    case "ListExpression" /* ListExpression */:
                    case "RecordExpression" /* RecordExpression */:
                        closeWrapperConstantWorkspace = { maybeWriteKind: "Any" /* Any */ };
                        break;
                    default:
                        closeWrapperConstantWorkspace = { maybeWriteKind: "Indented" /* Indented */ };
                        break;
                }
            }
            else {
                closeWrapperConstantWorkspace = {
                    maybeWriteKind: "Any" /* Any */,
                };
            }
            setWorkspace(state, node.closeWrapperConstant, closeWrapperConstantWorkspace);
            break;
        }
        case "LetExpression" /* LetExpression */:
            propagateWriteKind(state, node, node.letConstant);
            setWorkspace(state, node.inConstant, { maybeWriteKind: "Indented" /* Indented */ });
            setWorkspace(state, node.expression, {
                maybeIndentationChange: 1,
                maybeWriteKind: "Indented" /* Indented */,
            });
            break;
        case "ListType" /* ListType */: {
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            visitWrapped(state, node);
            if (isMultiline) {
                setWorkspace(state, node.content, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            break;
        }
        case "MetadataExpression" /* MetadataExpression */: {
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            propagateWriteKind(state, node, node.left);
            let otherWorkspace;
            if (isMultiline) {
                otherWorkspace = {
                    maybeWriteKind: "Indented" /* Indented */,
                };
            }
            else {
                otherWorkspace = {
                    maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
                };
            }
            setWorkspace(state, node.operatorConstant, otherWorkspace);
            setWorkspace(state, node.right, otherWorkspace);
            break;
        }
        case "NotImplementedExpression" /* NotImplementedExpression */:
            propagateWriteKind(state, node, node.ellipsisConstant);
            break;
        case "Parameter" /* Parameter */: {
            if (node.maybeOptionalConstant) {
                const optionalConstant = node.maybeOptionalConstant;
                setWorkspace(state, optionalConstant, { maybeWriteKind: "PaddedRight" /* PaddedRight */ });
            }
            if (node.maybeParameterType) {
                const parameterType = node.maybeParameterType;
                setWorkspace(state, parameterType, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        case "ParameterList" /* ParameterList */:
            propagateWriteKind(state, node, node.openWrapperConstant);
            break;
        case "ParenthesizedExpression" /* ParenthesizedExpression */: {
            const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
            visitWrapped(state, node);
            if (isMultiline) {
                setWorkspace(state, node.content, {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                });
            }
            break;
        }
        case "PrimitiveType" /* PrimitiveType */:
            propagateWriteKind(state, node, node.primitiveType);
            break;
        // Assumes the parent must be a CsvArray owned by a ListExpression,
        // meaning the Workspace can only get set in visitCsvArray.
        case "RangeExpression" /* RangeExpression */: {
            const workspace = getWorkspace(state, node);
            propagateWriteKind(state, node, node.left);
            if (workspace.maybeWriteKind === "Indented" /* Indented */) {
                setWorkspace(state, node.rangeConstant, { maybeWriteKind: "Indented" /* Indented */ });
                setWorkspace(state, node.right, { maybeWriteKind: "Indented" /* Indented */ });
            }
            break;
        }
        case "RecordType" /* RecordType */: {
            const workspace = getWorkspace(state, node);
            setWorkspace(state, node.fields, workspace);
            break;
        }
        case "RecursivePrimaryExpression" /* RecursivePrimaryExpression */:
            propagateWriteKind(state, node, node.head);
            break;
        case "TableType" /* TableType */: {
            propagateWriteKind(state, node, node.tableConstant);
            const rowType = node.rowType;
            const rowTypeIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, rowType);
            let rowTypeWorkspace;
            if (rowTypeIsMultiline) {
                rowTypeWorkspace = {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                };
            }
            else {
                rowTypeWorkspace = {
                    maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
                };
            }
            setWorkspace(state, rowType, rowTypeWorkspace);
            break;
        }
        case "Section" /* Section */: {
            const isMultilineMap = state.isMultilineMap;
            let sectionConstantWriteKind = "Any" /* Any */;
            const maybeLiteralAttributes = node.maybeLiteralAttributes;
            if (maybeLiteralAttributes) {
                const literalAttributes = maybeLiteralAttributes;
                if (common_2.expectGetIsMultiline(isMultilineMap, literalAttributes)) {
                    sectionConstantWriteKind = "Indented" /* Indented */;
                }
                else {
                    sectionConstantWriteKind = "PaddedLeft" /* PaddedLeft */;
                }
            }
            setWorkspace(state, node.sectionConstant, { maybeWriteKind: sectionConstantWriteKind });
            const maybeName = node.maybeName;
            if (maybeName) {
                const name = maybeName;
                setWorkspace(state, name, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        case "SectionMember" /* SectionMember */: {
            const isMultilineMap = state.isMultilineMap;
            let maybeSharedConstantWriteKind;
            let isNameExpressionPairWorkspaceSet = false;
            if (node.maybeLiteralAttributes) {
                const literalAttributes = node.maybeLiteralAttributes;
                propagateWriteKind(state, node, literalAttributes);
                if (common_2.expectGetIsMultiline(isMultilineMap, literalAttributes)) {
                    maybeSharedConstantWriteKind = "Indented" /* Indented */;
                }
                else {
                    maybeSharedConstantWriteKind = "PaddedLeft" /* PaddedLeft */;
                }
            }
            else if (node.maybeSharedConstant) {
                const sharedConstant = node.maybeSharedConstant;
                propagateWriteKind(state, node, sharedConstant);
            }
            else {
                propagateWriteKind(state, node, node.namePairedExpression);
                isNameExpressionPairWorkspaceSet = true;
            }
            if (node.maybeSharedConstant && maybeSharedConstantWriteKind) {
                const sharedConstant = node.maybeSharedConstant;
                setWorkspace(state, sharedConstant, { maybeWriteKind: maybeSharedConstantWriteKind });
            }
            if (!isNameExpressionPairWorkspaceSet) {
                let isNameExpressionPairIndented = false;
                if (node.maybeSharedConstant) {
                    const sharedConstant = node.maybeSharedConstant;
                    if (common_2.expectGetIsMultiline(isMultilineMap, sharedConstant)) {
                        isNameExpressionPairIndented = true;
                    }
                }
                else if (node.maybeLiteralAttributes) {
                    const literalAttributes = node.maybeLiteralAttributes;
                    if (common_2.expectGetIsMultiline(isMultilineMap, literalAttributes)) {
                        isNameExpressionPairIndented = true;
                    }
                }
                let writeKind;
                if (isNameExpressionPairIndented) {
                    writeKind = "Indented" /* Indented */;
                }
                else {
                    writeKind = "PaddedLeft" /* PaddedLeft */;
                }
                setWorkspace(state, node.namePairedExpression, { maybeWriteKind: writeKind });
            }
            break;
        }
        // TPairedConstant overload
        case "TypePrimaryType" /* TypePrimaryType */: {
            propagateWriteKind(state, node, node.constant);
            const paired = node.paired;
            const pairedIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, paired);
            let pairedWorkspace;
            if (skipPrimaryTypeIndentation(paired)) {
                pairedWorkspace = {
                    maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
                };
            }
            else if (pairedIsMultiline) {
                pairedWorkspace = {
                    maybeIndentationChange: 1,
                    maybeWriteKind: "Indented" /* Indented */,
                };
            }
            else {
                pairedWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
            }
            setWorkspace(state, paired, pairedWorkspace);
            break;
        }
        case "UnaryExpression" /* UnaryExpression */: {
            propagateWriteKind(state, node, node.operators);
            const operators = node.operators.elements;
            const lastOperator = operators[operators.length - 1];
            if (lastOperator.constantKind === "not" /* Not */) {
                setWorkspace(state, node.typeExpression, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
            }
            break;
        }
        // Leaf nodes.
        // If a parent gave the leaf node a workspace it assigns indentationChange,
        // while writeType can be overwritten if the leaf node has a multiline comment attached.
        case "Constant" /* Constant */:
        case "GeneralizedIdentifier" /* GeneralizedIdentifier */:
        case "Identifier" /* Identifier */:
        case "LiteralExpression" /* LiteralExpression */: {
            const workspace = getWorkspace(state, node);
            maybeSetIndentationChange(state, node, workspace.maybeIndentationChange);
            let maybeWriteKind = workspace.maybeWriteKind;
            maybeWriteKind = visitComments(state, node, maybeWriteKind);
            if (!maybeWriteKind) {
                const details = {
                    node,
                    maybeWriteKind: maybeWriteKind,
                };
                throw new powerquery_parser_1.CommonError.InvariantError("maybeWriteKind should be truthy", details);
            }
            state.result.writeKind.set(node.id, maybeWriteKind);
            break;
        }
        default:
            powerquery_parser_1.isNever(node);
    }
}
function getWorkspace(state, node, fallback = DefaultWorkspace) {
    const maybeWorkspace = state.workspaceMap.get(node.id);
    if (maybeWorkspace !== undefined) {
        return maybeWorkspace;
    }
    else {
        return fallback;
    }
}
function setWorkspace(state, node, workspace) {
    state.workspaceMap.set(node.id, workspace);
}
// sets indentationChange for the parent using the parent's Workspace,
// then propagates the writeKind to firstChild by setting its Workspace.
function propagateWriteKind(state, parent, firstChild) {
    const workspace = getWorkspace(state, parent);
    maybeSetIndentationChange(state, parent, workspace.maybeIndentationChange);
    const maybeWriteKind = workspace.maybeWriteKind;
    if (maybeWriteKind) {
        setWorkspace(state, firstChild, { maybeWriteKind: maybeWriteKind });
    }
}
function maybePropagateWriteKind(state, parent, maybeFirstChild) {
    if (maybeFirstChild) {
        const firstChild = maybeFirstChild;
        propagateWriteKind(state, parent, firstChild);
        return true;
    }
    else {
        return false;
    }
}
function maybeSetIndentationChange(state, node, maybeIndentationChange) {
    if (maybeIndentationChange) {
        state.result.indentationChange.set(node.id, maybeIndentationChange);
    }
}
// serves three purposes:
//  * propagates the TNode's writeKind to the first comment
//  * assigns writeKind for all comments attached to the TNode
//  * conditionally changes the TNode's writeKind based on the last comment's writeKind
//
// for example if maybeWriteKind === PaddedLeft and the TNode has two line comments:
//  * the first comment is set to PaddedLeft (from maybeWriteKind)
//  * the second comment is set to Indented (default for comment with newline)
//  * the TNode is set to Indented (last comment contains a newline)
function visitComments(state, node, maybeWriteKind) {
    const nodeId = node.id;
    const maybeComments = state.commentCollectionMap.get(nodeId);
    if (!maybeComments) {
        return maybeWriteKind;
    }
    const commentParameters = [];
    const comments = maybeComments.prefixedComments;
    const numComments = comments.length;
    if (!numComments) {
        return maybeWriteKind;
    }
    for (let index = 0; index < numComments; index += 1) {
        const comment = comments[index];
        const previousComment = comments[index - 1];
        let writeKind;
        if (index === 0) {
            writeKind = maybeWriteKind || "Any" /* Any */;
        }
        else if (comment.containsNewline) {
            writeKind = "Indented" /* Indented */;
        }
        else if (previousComment && previousComment.containsNewline) {
            writeKind = "Indented" /* Indented */;
        }
        else {
            writeKind = "Any" /* Any */;
        }
        commentParameters.push({
            literal: comment.data,
            writeKind,
        });
    }
    state.result.comments.set(nodeId, commentParameters);
    const lastComment = comments[comments.length - 1];
    if (lastComment.containsNewline) {
        maybeWriteKind = "Indented" /* Indented */;
    }
    else {
        maybeWriteKind = "PaddedLeft" /* PaddedLeft */;
    }
    return maybeWriteKind;
}
function visitKeyValuePair(state, node) {
    const isMultilineMap = state.isMultilineMap;
    const equalConstantIsMultiline = common_2.expectGetIsMultiline(isMultilineMap, node.equalConstant);
    const valueIsMultiline = common_2.expectGetIsMultiline(isMultilineMap, node.value);
    propagateWriteKind(state, node, node.key);
    let equalWorkspace;
    if (equalConstantIsMultiline) {
        equalWorkspace = { maybeWriteKind: "Indented" /* Indented */ };
    }
    else {
        equalWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
    }
    setWorkspace(state, node.equalConstant, equalWorkspace);
    let valueWorkspace;
    if (valueIsMultiline) {
        valueWorkspace = {
            maybeIndentationChange: 1,
            maybeWriteKind: "Indented" /* Indented */,
        };
    }
    else {
        valueWorkspace = { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ };
    }
    setWorkspace(state, node.value, valueWorkspace);
}
function visitArrayWrapper(state, node) {
    const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node);
    let maybeWriteKind;
    let maybeIndentationChange;
    if (isMultiline) {
        maybeWriteKind = "Indented" /* Indented */;
        maybeIndentationChange = 1;
    }
    else {
        maybeWriteKind = "Any" /* Any */;
    }
    for (const element of node.elements) {
        setWorkspace(state, element, {
            maybeWriteKind,
            maybeIndentationChange,
        });
    }
}
function visitArrayWrapperForSectionMembers(state, node) {
    let maybePreviousSectionMember;
    for (const member of node.elements) {
        if (member.kind !== "SectionMember" /* SectionMember */) {
            const details = { nodeKind: member.kind };
            throw new powerquery_parser_1.CommonError.InvariantError(`expected sectionMember`, details);
        }
        let memberWriteKind = "DoubleNewline" /* DoubleNewline */;
        if (maybePreviousSectionMember && isSectionMemeberSimilarScope(member, maybePreviousSectionMember)) {
            memberWriteKind = "Indented" /* Indented */;
        }
        setWorkspace(state, member, { maybeWriteKind: memberWriteKind });
        maybePreviousSectionMember = member;
    }
}
function visitArrayWrapperForUnaryExpression(state, node) {
    // `not` is an unary operator which needs to be padded.
    // The default Any write kind is fine for the other operators (`+` and `-`).
    const elements = node.elements;
    const numElements = node.elements.length;
    propagateWriteKind(state, node, elements[0]);
    let previousWasNotOperator = elements[0].constantKind === "not" /* Not */;
    for (let index = 1; index < numElements; index += 1) {
        const operatorConstant = elements[index];
        if (previousWasNotOperator || operatorConstant.constantKind === "not" /* Not */) {
            setWorkspace(state, operatorConstant, { maybeWriteKind: "PaddedLeft" /* PaddedLeft */ });
        }
        previousWasNotOperator = operatorConstant.constantKind === "not" /* Not */;
    }
}
function visitIfExpression(state, node) {
    propagateWriteKind(state, node, node.ifConstant);
    const conditionIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, node.condition);
    let conditionWorkspace;
    let thenConstantWorkspace;
    if (conditionIsMultiline) {
        conditionWorkspace = {
            maybeIndentationChange: 1,
            maybeWriteKind: "Indented" /* Indented */,
        };
        thenConstantWorkspace = {
            maybeWriteKind: "Indented" /* Indented */,
        };
    }
    else {
        conditionWorkspace = {
            maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
        };
        thenConstantWorkspace = {
            maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
        };
    }
    setWorkspace(state, node.condition, conditionWorkspace);
    setWorkspace(state, node.thenConstant, thenConstantWorkspace);
    setWorkspace(state, node.trueExpression, {
        maybeIndentationChange: 1,
        maybeWriteKind: "Indented" /* Indented */,
    });
    const falseExpression = node.falseExpression;
    let falseExpressionWorkspace;
    if (falseExpression.kind === "IfExpression" /* IfExpression */) {
        falseExpressionWorkspace = {
            maybeWriteKind: "PaddedLeft" /* PaddedLeft */,
        };
    }
    else {
        falseExpressionWorkspace = {
            maybeIndentationChange: 1,
            maybeWriteKind: "Indented" /* Indented */,
        };
    }
    setWorkspace(state, node.elseConstant, { maybeWriteKind: "Indented" /* Indented */ });
    setWorkspace(state, falseExpression, falseExpressionWorkspace);
}
function visitWrapped(state, wrapped) {
    const isMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, wrapped);
    // not const as it's conditionally overwritten if SerializerWriteKind.Indented
    let workspace = getWorkspace(state, wrapped);
    if (workspace.maybeWriteKind === "Indented" /* Indented */) {
        const writeKind = wrapperOpenWriteKind(state, wrapped);
        if (writeKind !== "Indented" /* Indented */) {
            workspace = {
                maybeIndentationChange: undefined,
                maybeWriteKind: writeKind,
            };
        }
    }
    setWorkspace(state, wrapped, workspace);
    propagateWriteKind(state, wrapped, wrapped.openWrapperConstant);
    if (isMultiline) {
        setWorkspace(state, wrapped.closeWrapperConstant, { maybeWriteKind: "Indented" /* Indented */ });
    }
}
function wrapperOpenWriteKind(state, wrapped) {
    // an open constant is multiline iff it is has a multiline comment
    const openIsMultiline = common_2.expectGetIsMultiline(state.isMultilineMap, wrapped.openWrapperConstant);
    if (openIsMultiline) {
        return "Indented" /* Indented */;
    }
    switch (wrapped.kind) {
        case "InvokeExpression" /* InvokeExpression */:
        case "ItemAccessExpression" /* ItemAccessExpression */:
            return "Any" /* Any */;
        default:
            break;
    }
    const nodeIdMapCollection = state.nodeIdMapCollection;
    let maybeParent = common_1.maybeGetParent(nodeIdMapCollection, wrapped.id);
    if (maybeParent && maybeParent.kind === "Csv" /* Csv */) {
        maybeParent = common_1.maybeGetParent(nodeIdMapCollection, maybeParent.id);
    }
    if (maybeParent && maybeParent.kind === "ArrayWrapper" /* ArrayWrapper */) {
        maybeParent = common_1.maybeGetParent(nodeIdMapCollection, maybeParent.id);
    }
    if (!maybeParent) {
        return "Indented" /* Indented */;
    }
    switch (maybeParent.kind) {
        case "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */:
        case "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */:
        case "IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */:
        case "IdentifierPairedExpression" /* IdentifierPairedExpression */:
        case "ListType" /* ListType */:
        case "RecordType" /* RecordType */:
        case "TableType" /* TableType */:
        case "TypePrimaryType" /* TypePrimaryType */:
            return "PaddedLeft" /* PaddedLeft */;
        case "ItemAccessExpression" /* ItemAccessExpression */:
            return "Any" /* Any */;
        default:
            return "Indented" /* Indented */;
    }
}
function skipPrimaryTypeIndentation(node) {
    switch (node.kind) {
        case "FunctionType" /* FunctionType */:
        case "NullableType" /* NullableType */:
        case "TableType" /* TableType */:
            return true;
        case "ListType" /* ListType */:
        case "PrimitiveType" /* PrimitiveType */:
        case "RecordType" /* RecordType */:
            return false;
        default:
            powerquery_parser_1.isNever(node);
    }
    return false;
}
// By default SectionMembers are two newlines apart from one another.
// Like-named sections (ex. Foo.Alpha, Foo.Bravo) should be placed one newline apart.
function isSectionMemeberSimilarScope(left, right) {
    const leftName = left.namePairedExpression.key;
    const leftScope = leftName.literal.split(".");
    const rightName = right.namePairedExpression.key;
    const rightScope = rightName.literal.split(".");
    return leftScope[0] === rightScope[0];
}
//# sourceMappingURL=serializerParameter.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/format/serializer.js":
/*!**************************************************************!*\
  !*** ../packages/powerquery-format/lib/format/serializer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const serializerParameter_1 = __webpack_require__(/*! ./passes/serializerParameter */ "../packages/powerquery-format/lib/format/passes/serializerParameter.js");
class Serializer {
    constructor(document, nodeIdMapCollection, passthroughMaps, indentationLiteral, newlineLiteral, formatted = "", currentLine = "", indentationLevel = 0, indentationCache = [""]) {
        this.document = document;
        this.nodeIdMapCollection = nodeIdMapCollection;
        this.passthroughMaps = passthroughMaps;
        this.indentationLiteral = indentationLiteral;
        this.newlineLiteral = newlineLiteral;
        this.formatted = formatted;
        this.currentLine = currentLine;
        this.indentationLevel = indentationLevel;
        this.indentationCache = indentationCache;
        this.expandIndentationCache(10);
    }
    static run(settings) {
        const serializer = new Serializer(settings.document, settings.nodeIdMapCollection, settings.maps, settings.indentationLiteral, settings.newlineLiteral);
        try {
            return {
                kind: "Ok" /* Ok */,
                value: serializer.run(),
            };
        }
        catch (err) {
            return {
                kind: "Err" /* Err */,
                error: powerquery_parser_1.CommonError.ensureCommonError(settings.localizationTemplates, err),
            };
        }
    }
    run() {
        this.visitNode(this.document);
        return this.formatted;
    }
    append(str) {
        this.formatted += str;
        if (str === this.newlineLiteral) {
            this.currentLine = "";
        }
        else {
            this.currentLine += str;
        }
    }
    serialize(str, serializerWriteKind) {
        switch (serializerWriteKind) {
            case "Any" /* Any */:
                this.append(str);
                break;
            case "DoubleNewline" /* DoubleNewline */:
                this.append(this.newlineLiteral);
                this.append(this.newlineLiteral);
                this.append(str);
                break;
            case "Indented" /* Indented */:
                this.serializeIndented(str);
                break;
            case "PaddedLeft" /* PaddedLeft */:
                this.serializePadded(str, true, false);
                break;
            case "PaddedRight" /* PaddedRight */:
                this.serializePadded(str, false, true);
                break;
            default:
                throw powerquery_parser_1.isNever(serializerWriteKind);
        }
    }
    serializeIndented(str) {
        if (this.currentLine !== "") {
            this.append(this.newlineLiteral);
        }
        this.append(this.currentIndentation());
        this.append(str);
    }
    serializePadded(str, padLeft, padRight) {
        if (padLeft && this.currentLine) {
            const lastWrittenCharacter = this.currentLine[this.currentLine.length - 1];
            if (lastWrittenCharacter !== " " && lastWrittenCharacter !== "\t") {
                this.append(" ");
            }
        }
        this.append(str);
        if (padRight) {
            this.append(" ");
        }
    }
    visitNode(node) {
        const nodeId = node.id;
        const maybeIndentationChange = this.passthroughMaps.serializerParameterMap.indentationChange.get(nodeId);
        if (maybeIndentationChange) {
            this.indentationLevel += 1;
        }
        if (node.isLeaf) {
            const maybeComments = this.passthroughMaps.serializerParameterMap.comments.get(nodeId);
            if (maybeComments) {
                this.visitComments(maybeComments);
            }
        }
        switch (node.kind) {
            case "Constant" /* Constant */: {
                const writeKind = serializerParameter_1.getSerializerWriteKind(node, this.passthroughMaps.serializerParameterMap);
                this.serialize(node.constantKind, writeKind);
                break;
            }
            case "GeneralizedIdentifier" /* GeneralizedIdentifier */:
            case "Identifier" /* Identifier */: {
                const writeKind = serializerParameter_1.getSerializerWriteKind(node, this.passthroughMaps.serializerParameterMap);
                this.serialize(`${node.literal}`, writeKind);
                break;
            }
            case "LiteralExpression" /* LiteralExpression */: {
                const writeKind = serializerParameter_1.getSerializerWriteKind(node, this.passthroughMaps.serializerParameterMap);
                this.serialize(node.literal, writeKind);
                break;
            }
            default:
                const maybeChildren = powerquery_parser_1.NodeIdMapUtils.maybeAstChildren(this.nodeIdMapCollection, node.id);
                if (maybeChildren === undefined) {
                    break;
                }
                const children = maybeChildren;
                for (const child of children) {
                    this.visitNode(child);
                }
                break;
        }
        if (maybeIndentationChange) {
            this.indentationLevel -= maybeIndentationChange;
        }
    }
    visitComments(collection) {
        for (const comment of collection) {
            this.serialize(comment.literal, comment.writeKind);
        }
    }
    currentIndentation() {
        const maybeIndentationLiteral = this.indentationCache[this.indentationLevel];
        if (maybeIndentationLiteral === undefined) {
            return this.expandIndentationCache(this.indentationLevel);
        }
        else {
            return maybeIndentationLiteral;
        }
    }
    expandIndentationCache(level) {
        for (let index = this.indentationCache.length; index <= level; index += 1) {
            const previousIndentation = this.indentationCache[index - 1] || "";
            this.indentationCache[index] = previousIndentation + this.indentationLiteral;
        }
        return this.indentationCache[this.indentationCache.length - 1];
    }
}
exports.Serializer = Serializer;
//# sourceMappingURL=serializer.js.map

/***/ }),

/***/ "../packages/powerquery-format/lib/index.js":
/*!**************************************************!*\
  !*** ../packages/powerquery-format/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./format */ "../packages/powerquery-format/lib/format/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/arrayUtils.js":
/*!********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/arrayUtils.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function removeFirstInstance(collection, element) {
    return removeAtIndex(collection, collection.indexOf(element));
}
exports.removeFirstInstance = removeFirstInstance;
function removeAtIndex(collection, index) {
    if (index < 0 || index >= collection.length) {
        const details = {
            index,
            collectionLength: collection.length,
        };
        throw new _1.CommonError.InvariantError("index not within array bounds", details);
    }
    return [...collection.slice(0, index), ...collection.slice(index + 1)];
}
exports.removeAtIndex = removeAtIndex;
function findReverse(collection, predicate) {
    const numElements = collection.length;
    for (let index = numElements - 1; index >= 0; index -= 1) {
        const element = collection[index];
        if (predicate(element)) {
            return element;
        }
    }
    return undefined;
}
exports.findReverse = findReverse;
//# sourceMappingURL=arrayUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/assert.js":
/*!****************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/assert.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function isNever(_) {
    throw new _1.CommonError.InvariantError(`should never be reached`);
}
exports.isNever = isNever;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/error.js":
/*!***************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/error.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const localization_1 = __webpack_require__(/*! ../localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js");
class CommonError extends Error {
    constructor(innerError) {
        super(innerError.message);
        this.innerError = innerError;
    }
}
exports.CommonError = CommonError;
class InvariantError extends Error {
    constructor(invariantBroken, maybeDetails = undefined) {
        super(localization_1.Localization.error_common_invariantError(localization_1.DefaultTemplates, invariantBroken, maybeDetails));
        this.invariantBroken = invariantBroken;
        this.maybeDetails = maybeDetails;
    }
}
exports.InvariantError = InvariantError;
class UnknownError extends Error {
    constructor(templates, innerError) {
        super(localization_1.Localization.error_common_unknown(templates, innerError));
        this.innerError = innerError;
    }
}
exports.UnknownError = UnknownError;
function isTInnerCommonError(x) {
    return x instanceof InvariantError || x instanceof UnknownError;
}
exports.isTInnerCommonError = isTInnerCommonError;
function ensureCommonError(templates, err) {
    if (isTInnerCommonError(err)) {
        return new CommonError(err);
    }
    else {
        return new CommonError(new UnknownError(templates, err));
    }
}
exports.ensureCommonError = ensureCommonError;
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js":
/*!***************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ArrayUtils = __webpack_require__(/*! ./arrayUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/arrayUtils.js");
exports.ArrayUtils = ArrayUtils;
const CommonError = __webpack_require__(/*! ./error */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/error.js");
exports.CommonError = CommonError;
const Pattern = __webpack_require__(/*! ./patterns */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/patterns.js");
exports.Pattern = Pattern;
const StringUtils = __webpack_require__(/*! ./stringUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/stringUtils.js");
exports.StringUtils = StringUtils;
const Traverse = __webpack_require__(/*! ./traversal */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/traversal.js");
exports.Traverse = Traverse;
const TypeUtils = __webpack_require__(/*! ./typeUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/typeUtils.js");
exports.TypeUtils = TypeUtils;
__export(__webpack_require__(/*! ./assert */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/assert.js"));
__export(__webpack_require__(/*! ./error */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/error.js"));
__export(__webpack_require__(/*! ./partialResult */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/index.js"));
__export(__webpack_require__(/*! ./patterns */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/patterns.js"));
__export(__webpack_require__(/*! ./result */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/index.js"));
__export(__webpack_require__(/*! ./stringUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/stringUtils.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/index.js":
/*!*****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/index.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const PartialResultUtils = __webpack_require__(/*! ./partialResultUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResultUtils.js");
exports.PartialResultUtils = PartialResultUtils;
__export(__webpack_require__(/*! ./partialResult */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResult.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResult.js":
/*!*************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResult.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=partialResult.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResultUtils.js":
/*!******************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/partialResult/partialResultUtils.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
function okFactory(value) {
    return {
        kind: "Ok" /* Ok */,
        value,
    };
}
exports.okFactory = okFactory;
function mixedFactory(value, error) {
    return {
        kind: "Mixed" /* Mixed */,
        value,
        error,
    };
}
exports.mixedFactory = mixedFactory;
function errFactory(error) {
    return {
        kind: "Err" /* Err */,
        error,
    };
}
exports.errFactory = errFactory;
function isOk(result) {
    return result.kind === "Ok" /* Ok */;
}
exports.isOk = isOk;
function isMixed(result) {
    return result.kind === "Mixed" /* Mixed */;
}
exports.isMixed = isMixed;
function isErr(result) {
    return result.kind === "Err" /* Err */;
}
exports.isErr = isErr;
//# sourceMappingURL=partialResultUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/patterns.js":
/*!******************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/patterns.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegExpIdentifier = RegExp("(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u1884\u1887-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5-\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400\u4db5\u4e00\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\u{10000}-\u{1000b}\u{1000d}-\u{10026}\u{10028}-\u{1003a}\u{1003c}-\u{1003d}\u{1003f}-\u{1004d}\u{10050}-\u{1005d}\u{10080}-\u{100fa}\u{10140}-\u{10174}\u{10280}-\u{1029c}\u{102a0}-\u{102d0}\u{10300}-\u{1031f}\u{1032d}-\u{1034a}\u{10350}-\u{10375}\u{10380}-\u{1039d}\u{103a0}-\u{103c3}\u{103c8}-\u{103cf}\u{103d1}-\u{103d5}\u{10400}-\u{1049d}\u{104b0}-\u{104d3}\u{104d8}-\u{104fb}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10800}-\u{10805}\u{10808}\u{1080a}-\u{10835}\u{10837}-\u{10838}\u{1083c}\u{1083f}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089e}\u{108e0}-\u{108f2}\u{108f4}-\u{108f5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109b7}\u{109be}-\u{109bf}\u{10a00}\u{10a10}-\u{10a13}\u{10a15}-\u{10a17}\u{10a19}-\u{10a35}\u{10a60}-\u{10a7c}\u{10a80}-\u{10a9c}\u{10ac0}-\u{10ac7}\u{10ac9}-\u{10ae4}\u{10b00}-\u{10b35}\u{10b40}-\u{10b55}\u{10b60}-\u{10b72}\u{10b80}-\u{10b91}\u{10c00}-\u{10c48}\u{10c80}-\u{10cb2}\u{10cc0}-\u{10cf2}\u{10d00}-\u{10d23}\u{10f00}-\u{10f1c}\u{10f27}\u{10f30}-\u{10f45}\u{11003}-\u{11037}\u{11083}-\u{110af}\u{110d0}-\u{110e8}\u{11103}-\u{11126}\u{11144}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111b2}\u{111c1}-\u{111c4}\u{111da}\u{111dc}\u{11200}-\u{11211}\u{11213}-\u{1122b}\u{11280}-\u{11286}\u{11288}\u{1128a}-\u{1128d}\u{1128f}-\u{1129d}\u{1129f}-\u{112a8}\u{112b0}-\u{112de}\u{11305}-\u{1130c}\u{1130f}-\u{11310}\u{11313}-\u{11328}\u{1132a}-\u{11330}\u{11332}-\u{11333}\u{11335}-\u{11339}\u{1133d}\u{11350}\u{1135d}-\u{11361}\u{11400}-\u{11434}\u{11447}-\u{1144a}\u{11480}-\u{114af}\u{114c4}-\u{114c5}\u{114c7}\u{11580}-\u{115ae}\u{115d8}-\u{115db}\u{11600}-\u{1162f}\u{11644}\u{11680}-\u{116aa}\u{11700}-\u{1171a}\u{11800}-\u{1182b}\u{118a0}-\u{118df}\u{118ff}\u{11a00}\u{11a0b}-\u{11a32}\u{11a3a}\u{11a50}\u{11a5c}-\u{11a83}\u{11a86}-\u{11a89}\u{11a9d}\u{11ac0}-\u{11af8}\u{11c00}-\u{11c08}\u{11c0a}-\u{11c2e}\u{11c40}\u{11c72}-\u{11c8f}\u{11d00}-\u{11d06}\u{11d08}-\u{11d09}\u{11d0b}-\u{11d30}\u{11d46}\u{11d60}-\u{11d65}\u{11d67}-\u{11d68}\u{11d6a}-\u{11d89}\u{11d98}\u{11ee0}-\u{11ef2}\u{12000}-\u{12399}\u{12400}-\u{1246e}\u{12480}-\u{12543}\u{13000}-\u{1342e}\u{14400}-\u{14646}\u{16800}-\u{16a38}\u{16a40}-\u{16a5e}\u{16ad0}-\u{16aed}\u{16b00}-\u{16b2f}\u{16b40}-\u{16b43}\u{16b63}-\u{16b77}\u{16b7d}-\u{16b8f}\u{16e40}-\u{16e7f}\u{16f00}-\u{16f44}\u{16f50}\u{16f93}-\u{16f9f}\u{16fe0}-\u{16fe1}\u{17000}\u{187f1}\u{18800}-\u{18af2}\u{1b000}-\u{1b11e}\u{1b170}-\u{1b2fb}\u{1bc00}-\u{1bc6a}\u{1bc70}-\u{1bc7c}\u{1bc80}-\u{1bc88}\u{1bc90}-\u{1bc99}\u{1d400}-\u{1d454}\u{1d456}-\u{1d49c}\u{1d49e}-\u{1d49f}\u{1d4a2}\u{1d4a5}-\u{1d4a6}\u{1d4a9}-\u{1d4ac}\u{1d4ae}-\u{1d4b9}\u{1d4bb}\u{1d4bd}-\u{1d4c3}\u{1d4c5}-\u{1d505}\u{1d507}-\u{1d50a}\u{1d50d}-\u{1d514}\u{1d516}-\u{1d51c}\u{1d51e}-\u{1d539}\u{1d53b}-\u{1d53e}\u{1d540}-\u{1d544}\u{1d546}\u{1d54a}-\u{1d550}\u{1d552}-\u{1d6a5}\u{1d6a8}-\u{1d6c0}\u{1d6c2}-\u{1d6da}\u{1d6dc}-\u{1d6fa}\u{1d6fc}-\u{1d714}\u{1d716}-\u{1d734}\u{1d736}-\u{1d74e}\u{1d750}-\u{1d76e}\u{1d770}-\u{1d788}\u{1d78a}-\u{1d7a8}\u{1d7aa}-\u{1d7c2}\u{1d7c4}-\u{1d7cb}\u{1e800}-\u{1e8c4}\u{1e900}-\u{1e943}\u{1ee00}-\u{1ee03}\u{1ee05}-\u{1ee1f}\u{1ee21}-\u{1ee22}\u{1ee24}\u{1ee27}\u{1ee29}-\u{1ee32}\u{1ee34}-\u{1ee37}\u{1ee39}\u{1ee3b}\u{1ee42}\u{1ee47}\u{1ee49}\u{1ee4b}\u{1ee4d}-\u{1ee4f}\u{1ee51}-\u{1ee52}\u{1ee54}\u{1ee57}\u{1ee59}\u{1ee5b}\u{1ee5d}\u{1ee5f}\u{1ee61}-\u{1ee62}\u{1ee64}\u{1ee67}-\u{1ee6a}\u{1ee6c}-\u{1ee72}\u{1ee74}-\u{1ee77}\u{1ee79}-\u{1ee7c}\u{1ee7e}\u{1ee80}-\u{1ee89}\u{1ee8b}-\u{1ee9b}\u{1eea1}-\u{1eea3}\u{1eea5}-\u{1eea9}\u{1eeab}-\u{1eebb}\u{20000}\u{2a6d6}\u{2a700}\u{2b734}\u{2b740}\u{2b81d}\u{2b820}\u{2cea1}\u{2ceb0}\u{2ebe0}\u{2f800}-\u{2fa1d}\u005f][\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00ad\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0600-\u0605\u0610-\u061a\u061c\u0620-\u0669\u066e-\u06d3\u06d5-\u06dd\u06df-\u06e8\u06ea-\u06fc\u06ff\u070f-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180e\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cf9\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200b-\u200f\u202a-\u202e\u203f-\u2040\u2054\u2060-\u2064\u2066-\u206f\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400\u4db5\u4e00\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\ufeff\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\ufff9-\ufffb\u{10000}-\u{1000b}\u{1000d}-\u{10026}\u{10028}-\u{1003a}\u{1003c}-\u{1003d}\u{1003f}-\u{1004d}\u{10050}-\u{1005d}\u{10080}-\u{100fa}\u{10140}-\u{10174}\u{101fd}\u{10280}-\u{1029c}\u{102a0}-\u{102d0}\u{102e0}\u{10300}-\u{1031f}\u{1032d}-\u{1034a}\u{10350}-\u{1037a}\u{10380}-\u{1039d}\u{103a0}-\u{103c3}\u{103c8}-\u{103cf}\u{103d1}-\u{103d5}\u{10400}-\u{1049d}\u{104a0}-\u{104a9}\u{104b0}-\u{104d3}\u{104d8}-\u{104fb}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10800}-\u{10805}\u{10808}\u{1080a}-\u{10835}\u{10837}-\u{10838}\u{1083c}\u{1083f}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089e}\u{108e0}-\u{108f2}\u{108f4}-\u{108f5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109b7}\u{109be}-\u{109bf}\u{10a00}-\u{10a03}\u{10a05}-\u{10a06}\u{10a0c}-\u{10a13}\u{10a15}-\u{10a17}\u{10a19}-\u{10a35}\u{10a38}-\u{10a3a}\u{10a3f}\u{10a60}-\u{10a7c}\u{10a80}-\u{10a9c}\u{10ac0}-\u{10ac7}\u{10ac9}-\u{10ae6}\u{10b00}-\u{10b35}\u{10b40}-\u{10b55}\u{10b60}-\u{10b72}\u{10b80}-\u{10b91}\u{10c00}-\u{10c48}\u{10c80}-\u{10cb2}\u{10cc0}-\u{10cf2}\u{10d00}-\u{10d27}\u{10d30}-\u{10d39}\u{10f00}-\u{10f1c}\u{10f27}\u{10f30}-\u{10f50}\u{11000}-\u{11046}\u{11066}-\u{1106f}\u{1107f}-\u{110ba}\u{110bd}\u{110cd}\u{110d0}-\u{110e8}\u{110f0}-\u{110f9}\u{11100}-\u{11134}\u{11136}-\u{1113f}\u{11144}-\u{11146}\u{11150}-\u{11173}\u{11176}\u{11180}-\u{111c4}\u{111c9}-\u{111cc}\u{111d0}-\u{111da}\u{111dc}\u{11200}-\u{11211}\u{11213}-\u{11237}\u{1123e}\u{11280}-\u{11286}\u{11288}\u{1128a}-\u{1128d}\u{1128f}-\u{1129d}\u{1129f}-\u{112a8}\u{112b0}-\u{112ea}\u{112f0}-\u{112f9}\u{11300}-\u{11303}\u{11305}-\u{1130c}\u{1130f}-\u{11310}\u{11313}-\u{11328}\u{1132a}-\u{11330}\u{11332}-\u{11333}\u{11335}-\u{11339}\u{1133b}-\u{11344}\u{11347}-\u{11348}\u{1134b}-\u{1134d}\u{11350}\u{11357}\u{1135d}-\u{11363}\u{11366}-\u{1136c}\u{11370}-\u{11374}\u{11400}-\u{1144a}\u{11450}-\u{11459}\u{1145e}\u{11480}-\u{114c5}\u{114c7}\u{114d0}-\u{114d9}\u{11580}-\u{115b5}\u{115b8}-\u{115c0}\u{115d8}-\u{115dd}\u{11600}-\u{11640}\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116b7}\u{116c0}-\u{116c9}\u{11700}-\u{1171a}\u{1171d}-\u{1172b}\u{11730}-\u{11739}\u{11800}-\u{1183a}\u{118a0}-\u{118e9}\u{118ff}\u{11a00}-\u{11a3e}\u{11a47}\u{11a50}-\u{11a83}\u{11a86}-\u{11a99}\u{11a9d}\u{11ac0}-\u{11af8}\u{11c00}-\u{11c08}\u{11c0a}-\u{11c36}\u{11c38}-\u{11c40}\u{11c50}-\u{11c59}\u{11c72}-\u{11c8f}\u{11c92}-\u{11ca7}\u{11ca9}-\u{11cb6}\u{11d00}-\u{11d06}\u{11d08}-\u{11d09}\u{11d0b}-\u{11d36}\u{11d3a}\u{11d3c}-\u{11d3d}\u{11d3f}-\u{11d47}\u{11d50}-\u{11d59}\u{11d60}-\u{11d65}\u{11d67}-\u{11d68}\u{11d6a}-\u{11d8e}\u{11d90}-\u{11d91}\u{11d93}-\u{11d98}\u{11da0}-\u{11da9}\u{11ee0}-\u{11ef6}\u{12000}-\u{12399}\u{12400}-\u{1246e}\u{12480}-\u{12543}\u{13000}-\u{1342e}\u{14400}-\u{14646}\u{16800}-\u{16a38}\u{16a40}-\u{16a5e}\u{16a60}-\u{16a69}\u{16ad0}-\u{16aed}\u{16af0}-\u{16af4}\u{16b00}-\u{16b36}\u{16b40}-\u{16b43}\u{16b50}-\u{16b59}\u{16b63}-\u{16b77}\u{16b7d}-\u{16b8f}\u{16e40}-\u{16e7f}\u{16f00}-\u{16f44}\u{16f50}-\u{16f7e}\u{16f8f}-\u{16f9f}\u{16fe0}-\u{16fe1}\u{17000}\u{187f1}\u{18800}-\u{18af2}\u{1b000}-\u{1b11e}\u{1b170}-\u{1b2fb}\u{1bc00}-\u{1bc6a}\u{1bc70}-\u{1bc7c}\u{1bc80}-\u{1bc88}\u{1bc90}-\u{1bc99}\u{1bc9d}-\u{1bc9e}\u{1bca0}-\u{1bca3}\u{1d165}-\u{1d169}\u{1d16d}-\u{1d182}\u{1d185}-\u{1d18b}\u{1d1aa}-\u{1d1ad}\u{1d242}-\u{1d244}\u{1d400}-\u{1d454}\u{1d456}-\u{1d49c}\u{1d49e}-\u{1d49f}\u{1d4a2}\u{1d4a5}-\u{1d4a6}\u{1d4a9}-\u{1d4ac}\u{1d4ae}-\u{1d4b9}\u{1d4bb}\u{1d4bd}-\u{1d4c3}\u{1d4c5}-\u{1d505}\u{1d507}-\u{1d50a}\u{1d50d}-\u{1d514}\u{1d516}-\u{1d51c}\u{1d51e}-\u{1d539}\u{1d53b}-\u{1d53e}\u{1d540}-\u{1d544}\u{1d546}\u{1d54a}-\u{1d550}\u{1d552}-\u{1d6a5}\u{1d6a8}-\u{1d6c0}\u{1d6c2}-\u{1d6da}\u{1d6dc}-\u{1d6fa}\u{1d6fc}-\u{1d714}\u{1d716}-\u{1d734}\u{1d736}-\u{1d74e}\u{1d750}-\u{1d76e}\u{1d770}-\u{1d788}\u{1d78a}-\u{1d7a8}\u{1d7aa}-\u{1d7c2}\u{1d7c4}-\u{1d7cb}\u{1d7ce}-\u{1d7ff}\u{1da00}-\u{1da36}\u{1da3b}-\u{1da6c}\u{1da75}\u{1da84}\u{1da9b}-\u{1da9f}\u{1daa1}-\u{1daaf}\u{1e000}-\u{1e006}\u{1e008}-\u{1e018}\u{1e01b}-\u{1e021}\u{1e023}-\u{1e024}\u{1e026}-\u{1e02a}\u{1e800}-\u{1e8c4}\u{1e8d0}-\u{1e8d6}\u{1e900}-\u{1e94a}\u{1e950}-\u{1e959}\u{1ee00}-\u{1ee03}\u{1ee05}-\u{1ee1f}\u{1ee21}-\u{1ee22}\u{1ee24}\u{1ee27}\u{1ee29}-\u{1ee32}\u{1ee34}-\u{1ee37}\u{1ee39}\u{1ee3b}\u{1ee42}\u{1ee47}\u{1ee49}\u{1ee4b}\u{1ee4d}-\u{1ee4f}\u{1ee51}-\u{1ee52}\u{1ee54}\u{1ee57}\u{1ee59}\u{1ee5b}\u{1ee5d}\u{1ee5f}\u{1ee61}-\u{1ee62}\u{1ee64}\u{1ee67}-\u{1ee6a}\u{1ee6c}-\u{1ee72}\u{1ee74}-\u{1ee77}\u{1ee79}-\u{1ee7c}\u{1ee7e}\u{1ee80}-\u{1ee89}\u{1ee8b}-\u{1ee9b}\u{1eea1}-\u{1eea3}\u{1eea5}-\u{1eea9}\u{1eeab}-\u{1eebb}\u{20000}\u{2a6d6}\u{2a700}\u{2b734}\u{2b740}\u{2b81d}\u{2b820}\u{2cea1}\u{2ceb0}\u{2ebe0}\u{2f800}-\u{2fa1d}\u{e0001}\u{e0020}-\u{e007f}\u{e0100}-\u{e01ef}]*)(\\.([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u1884\u1887-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5-\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400\u4db5\u4e00\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\u{10000}-\u{1000b}\u{1000d}-\u{10026}\u{10028}-\u{1003a}\u{1003c}-\u{1003d}\u{1003f}-\u{1004d}\u{10050}-\u{1005d}\u{10080}-\u{100fa}\u{10140}-\u{10174}\u{10280}-\u{1029c}\u{102a0}-\u{102d0}\u{10300}-\u{1031f}\u{1032d}-\u{1034a}\u{10350}-\u{10375}\u{10380}-\u{1039d}\u{103a0}-\u{103c3}\u{103c8}-\u{103cf}\u{103d1}-\u{103d5}\u{10400}-\u{1049d}\u{104b0}-\u{104d3}\u{104d8}-\u{104fb}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10800}-\u{10805}\u{10808}\u{1080a}-\u{10835}\u{10837}-\u{10838}\u{1083c}\u{1083f}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089e}\u{108e0}-\u{108f2}\u{108f4}-\u{108f5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109b7}\u{109be}-\u{109bf}\u{10a00}\u{10a10}-\u{10a13}\u{10a15}-\u{10a17}\u{10a19}-\u{10a35}\u{10a60}-\u{10a7c}\u{10a80}-\u{10a9c}\u{10ac0}-\u{10ac7}\u{10ac9}-\u{10ae4}\u{10b00}-\u{10b35}\u{10b40}-\u{10b55}\u{10b60}-\u{10b72}\u{10b80}-\u{10b91}\u{10c00}-\u{10c48}\u{10c80}-\u{10cb2}\u{10cc0}-\u{10cf2}\u{10d00}-\u{10d23}\u{10f00}-\u{10f1c}\u{10f27}\u{10f30}-\u{10f45}\u{11003}-\u{11037}\u{11083}-\u{110af}\u{110d0}-\u{110e8}\u{11103}-\u{11126}\u{11144}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111b2}\u{111c1}-\u{111c4}\u{111da}\u{111dc}\u{11200}-\u{11211}\u{11213}-\u{1122b}\u{11280}-\u{11286}\u{11288}\u{1128a}-\u{1128d}\u{1128f}-\u{1129d}\u{1129f}-\u{112a8}\u{112b0}-\u{112de}\u{11305}-\u{1130c}\u{1130f}-\u{11310}\u{11313}-\u{11328}\u{1132a}-\u{11330}\u{11332}-\u{11333}\u{11335}-\u{11339}\u{1133d}\u{11350}\u{1135d}-\u{11361}\u{11400}-\u{11434}\u{11447}-\u{1144a}\u{11480}-\u{114af}\u{114c4}-\u{114c5}\u{114c7}\u{11580}-\u{115ae}\u{115d8}-\u{115db}\u{11600}-\u{1162f}\u{11644}\u{11680}-\u{116aa}\u{11700}-\u{1171a}\u{11800}-\u{1182b}\u{118a0}-\u{118df}\u{118ff}\u{11a00}\u{11a0b}-\u{11a32}\u{11a3a}\u{11a50}\u{11a5c}-\u{11a83}\u{11a86}-\u{11a89}\u{11a9d}\u{11ac0}-\u{11af8}\u{11c00}-\u{11c08}\u{11c0a}-\u{11c2e}\u{11c40}\u{11c72}-\u{11c8f}\u{11d00}-\u{11d06}\u{11d08}-\u{11d09}\u{11d0b}-\u{11d30}\u{11d46}\u{11d60}-\u{11d65}\u{11d67}-\u{11d68}\u{11d6a}-\u{11d89}\u{11d98}\u{11ee0}-\u{11ef2}\u{12000}-\u{12399}\u{12400}-\u{1246e}\u{12480}-\u{12543}\u{13000}-\u{1342e}\u{14400}-\u{14646}\u{16800}-\u{16a38}\u{16a40}-\u{16a5e}\u{16ad0}-\u{16aed}\u{16b00}-\u{16b2f}\u{16b40}-\u{16b43}\u{16b63}-\u{16b77}\u{16b7d}-\u{16b8f}\u{16e40}-\u{16e7f}\u{16f00}-\u{16f44}\u{16f50}\u{16f93}-\u{16f9f}\u{16fe0}-\u{16fe1}\u{17000}\u{187f1}\u{18800}-\u{18af2}\u{1b000}-\u{1b11e}\u{1b170}-\u{1b2fb}\u{1bc00}-\u{1bc6a}\u{1bc70}-\u{1bc7c}\u{1bc80}-\u{1bc88}\u{1bc90}-\u{1bc99}\u{1d400}-\u{1d454}\u{1d456}-\u{1d49c}\u{1d49e}-\u{1d49f}\u{1d4a2}\u{1d4a5}-\u{1d4a6}\u{1d4a9}-\u{1d4ac}\u{1d4ae}-\u{1d4b9}\u{1d4bb}\u{1d4bd}-\u{1d4c3}\u{1d4c5}-\u{1d505}\u{1d507}-\u{1d50a}\u{1d50d}-\u{1d514}\u{1d516}-\u{1d51c}\u{1d51e}-\u{1d539}\u{1d53b}-\u{1d53e}\u{1d540}-\u{1d544}\u{1d546}\u{1d54a}-\u{1d550}\u{1d552}-\u{1d6a5}\u{1d6a8}-\u{1d6c0}\u{1d6c2}-\u{1d6da}\u{1d6dc}-\u{1d6fa}\u{1d6fc}-\u{1d714}\u{1d716}-\u{1d734}\u{1d736}-\u{1d74e}\u{1d750}-\u{1d76e}\u{1d770}-\u{1d788}\u{1d78a}-\u{1d7a8}\u{1d7aa}-\u{1d7c2}\u{1d7c4}-\u{1d7cb}\u{1e800}-\u{1e8c4}\u{1e900}-\u{1e943}\u{1ee00}-\u{1ee03}\u{1ee05}-\u{1ee1f}\u{1ee21}-\u{1ee22}\u{1ee24}\u{1ee27}\u{1ee29}-\u{1ee32}\u{1ee34}-\u{1ee37}\u{1ee39}\u{1ee3b}\u{1ee42}\u{1ee47}\u{1ee49}\u{1ee4b}\u{1ee4d}-\u{1ee4f}\u{1ee51}-\u{1ee52}\u{1ee54}\u{1ee57}\u{1ee59}\u{1ee5b}\u{1ee5d}\u{1ee5f}\u{1ee61}-\u{1ee62}\u{1ee64}\u{1ee67}-\u{1ee6a}\u{1ee6c}-\u{1ee72}\u{1ee74}-\u{1ee77}\u{1ee79}-\u{1ee7c}\u{1ee7e}\u{1ee80}-\u{1ee89}\u{1ee8b}-\u{1ee9b}\u{1eea1}-\u{1eea3}\u{1eea5}-\u{1eea9}\u{1eeab}-\u{1eebb}\u{20000}\u{2a6d6}\u{2a700}\u{2b734}\u{2b740}\u{2b81d}\u{2b820}\u{2cea1}\u{2ceb0}\u{2ebe0}\u{2f800}-\u{2fa1d}\u005f][\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00ad\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0600-\u0605\u0610-\u061a\u061c\u0620-\u0669\u066e-\u06d3\u06d5-\u06dd\u06df-\u06e8\u06ea-\u06fc\u06ff\u070f-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180e\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cf9\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200b-\u200f\u202a-\u202e\u203f-\u2040\u2054\u2060-\u2064\u2066-\u206f\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400\u4db5\u4e00\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\ufeff\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\ufff9-\ufffb\u{10000}-\u{1000b}\u{1000d}-\u{10026}\u{10028}-\u{1003a}\u{1003c}-\u{1003d}\u{1003f}-\u{1004d}\u{10050}-\u{1005d}\u{10080}-\u{100fa}\u{10140}-\u{10174}\u{101fd}\u{10280}-\u{1029c}\u{102a0}-\u{102d0}\u{102e0}\u{10300}-\u{1031f}\u{1032d}-\u{1034a}\u{10350}-\u{1037a}\u{10380}-\u{1039d}\u{103a0}-\u{103c3}\u{103c8}-\u{103cf}\u{103d1}-\u{103d5}\u{10400}-\u{1049d}\u{104a0}-\u{104a9}\u{104b0}-\u{104d3}\u{104d8}-\u{104fb}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10800}-\u{10805}\u{10808}\u{1080a}-\u{10835}\u{10837}-\u{10838}\u{1083c}\u{1083f}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089e}\u{108e0}-\u{108f2}\u{108f4}-\u{108f5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109b7}\u{109be}-\u{109bf}\u{10a00}-\u{10a03}\u{10a05}-\u{10a06}\u{10a0c}-\u{10a13}\u{10a15}-\u{10a17}\u{10a19}-\u{10a35}\u{10a38}-\u{10a3a}\u{10a3f}\u{10a60}-\u{10a7c}\u{10a80}-\u{10a9c}\u{10ac0}-\u{10ac7}\u{10ac9}-\u{10ae6}\u{10b00}-\u{10b35}\u{10b40}-\u{10b55}\u{10b60}-\u{10b72}\u{10b80}-\u{10b91}\u{10c00}-\u{10c48}\u{10c80}-\u{10cb2}\u{10cc0}-\u{10cf2}\u{10d00}-\u{10d27}\u{10d30}-\u{10d39}\u{10f00}-\u{10f1c}\u{10f27}\u{10f30}-\u{10f50}\u{11000}-\u{11046}\u{11066}-\u{1106f}\u{1107f}-\u{110ba}\u{110bd}\u{110cd}\u{110d0}-\u{110e8}\u{110f0}-\u{110f9}\u{11100}-\u{11134}\u{11136}-\u{1113f}\u{11144}-\u{11146}\u{11150}-\u{11173}\u{11176}\u{11180}-\u{111c4}\u{111c9}-\u{111cc}\u{111d0}-\u{111da}\u{111dc}\u{11200}-\u{11211}\u{11213}-\u{11237}\u{1123e}\u{11280}-\u{11286}\u{11288}\u{1128a}-\u{1128d}\u{1128f}-\u{1129d}\u{1129f}-\u{112a8}\u{112b0}-\u{112ea}\u{112f0}-\u{112f9}\u{11300}-\u{11303}\u{11305}-\u{1130c}\u{1130f}-\u{11310}\u{11313}-\u{11328}\u{1132a}-\u{11330}\u{11332}-\u{11333}\u{11335}-\u{11339}\u{1133b}-\u{11344}\u{11347}-\u{11348}\u{1134b}-\u{1134d}\u{11350}\u{11357}\u{1135d}-\u{11363}\u{11366}-\u{1136c}\u{11370}-\u{11374}\u{11400}-\u{1144a}\u{11450}-\u{11459}\u{1145e}\u{11480}-\u{114c5}\u{114c7}\u{114d0}-\u{114d9}\u{11580}-\u{115b5}\u{115b8}-\u{115c0}\u{115d8}-\u{115dd}\u{11600}-\u{11640}\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116b7}\u{116c0}-\u{116c9}\u{11700}-\u{1171a}\u{1171d}-\u{1172b}\u{11730}-\u{11739}\u{11800}-\u{1183a}\u{118a0}-\u{118e9}\u{118ff}\u{11a00}-\u{11a3e}\u{11a47}\u{11a50}-\u{11a83}\u{11a86}-\u{11a99}\u{11a9d}\u{11ac0}-\u{11af8}\u{11c00}-\u{11c08}\u{11c0a}-\u{11c36}\u{11c38}-\u{11c40}\u{11c50}-\u{11c59}\u{11c72}-\u{11c8f}\u{11c92}-\u{11ca7}\u{11ca9}-\u{11cb6}\u{11d00}-\u{11d06}\u{11d08}-\u{11d09}\u{11d0b}-\u{11d36}\u{11d3a}\u{11d3c}-\u{11d3d}\u{11d3f}-\u{11d47}\u{11d50}-\u{11d59}\u{11d60}-\u{11d65}\u{11d67}-\u{11d68}\u{11d6a}-\u{11d8e}\u{11d90}-\u{11d91}\u{11d93}-\u{11d98}\u{11da0}-\u{11da9}\u{11ee0}-\u{11ef6}\u{12000}-\u{12399}\u{12400}-\u{1246e}\u{12480}-\u{12543}\u{13000}-\u{1342e}\u{14400}-\u{14646}\u{16800}-\u{16a38}\u{16a40}-\u{16a5e}\u{16a60}-\u{16a69}\u{16ad0}-\u{16aed}\u{16af0}-\u{16af4}\u{16b00}-\u{16b36}\u{16b40}-\u{16b43}\u{16b50}-\u{16b59}\u{16b63}-\u{16b77}\u{16b7d}-\u{16b8f}\u{16e40}-\u{16e7f}\u{16f00}-\u{16f44}\u{16f50}-\u{16f7e}\u{16f8f}-\u{16f9f}\u{16fe0}-\u{16fe1}\u{17000}\u{187f1}\u{18800}-\u{18af2}\u{1b000}-\u{1b11e}\u{1b170}-\u{1b2fb}\u{1bc00}-\u{1bc6a}\u{1bc70}-\u{1bc7c}\u{1bc80}-\u{1bc88}\u{1bc90}-\u{1bc99}\u{1bc9d}-\u{1bc9e}\u{1bca0}-\u{1bca3}\u{1d165}-\u{1d169}\u{1d16d}-\u{1d182}\u{1d185}-\u{1d18b}\u{1d1aa}-\u{1d1ad}\u{1d242}-\u{1d244}\u{1d400}-\u{1d454}\u{1d456}-\u{1d49c}\u{1d49e}-\u{1d49f}\u{1d4a2}\u{1d4a5}-\u{1d4a6}\u{1d4a9}-\u{1d4ac}\u{1d4ae}-\u{1d4b9}\u{1d4bb}\u{1d4bd}-\u{1d4c3}\u{1d4c5}-\u{1d505}\u{1d507}-\u{1d50a}\u{1d50d}-\u{1d514}\u{1d516}-\u{1d51c}\u{1d51e}-\u{1d539}\u{1d53b}-\u{1d53e}\u{1d540}-\u{1d544}\u{1d546}\u{1d54a}-\u{1d550}\u{1d552}-\u{1d6a5}\u{1d6a8}-\u{1d6c0}\u{1d6c2}-\u{1d6da}\u{1d6dc}-\u{1d6fa}\u{1d6fc}-\u{1d714}\u{1d716}-\u{1d734}\u{1d736}-\u{1d74e}\u{1d750}-\u{1d76e}\u{1d770}-\u{1d788}\u{1d78a}-\u{1d7a8}\u{1d7aa}-\u{1d7c2}\u{1d7c4}-\u{1d7cb}\u{1d7ce}-\u{1d7ff}\u{1da00}-\u{1da36}\u{1da3b}-\u{1da6c}\u{1da75}\u{1da84}\u{1da9b}-\u{1da9f}\u{1daa1}-\u{1daaf}\u{1e000}-\u{1e006}\u{1e008}-\u{1e018}\u{1e01b}-\u{1e021}\u{1e023}-\u{1e024}\u{1e026}-\u{1e02a}\u{1e800}-\u{1e8c4}\u{1e8d0}-\u{1e8d6}\u{1e900}-\u{1e94a}\u{1e950}-\u{1e959}\u{1ee00}-\u{1ee03}\u{1ee05}-\u{1ee1f}\u{1ee21}-\u{1ee22}\u{1ee24}\u{1ee27}\u{1ee29}-\u{1ee32}\u{1ee34}-\u{1ee37}\u{1ee39}\u{1ee3b}\u{1ee42}\u{1ee47}\u{1ee49}\u{1ee4b}\u{1ee4d}-\u{1ee4f}\u{1ee51}-\u{1ee52}\u{1ee54}\u{1ee57}\u{1ee59}\u{1ee5b}\u{1ee5d}\u{1ee5f}\u{1ee61}-\u{1ee62}\u{1ee64}\u{1ee67}-\u{1ee6a}\u{1ee6c}-\u{1ee72}\u{1ee74}-\u{1ee77}\u{1ee79}-\u{1ee7c}\u{1ee7e}\u{1ee80}-\u{1ee89}\u{1ee8b}-\u{1ee9b}\u{1eea1}-\u{1eea3}\u{1eea5}-\u{1eea9}\u{1eeab}-\u{1eebb}\u{20000}\u{2a6d6}\u{2a700}\u{2b734}\u{2b740}\u{2b81d}\u{2b820}\u{2cea1}\u{2ceb0}\u{2ebe0}\u{2f800}-\u{2fa1d}\u{e0001}\u{e0020}-\u{e007f}\u{e0100}-\u{e01ef}]*))*)", "yu");
exports.RegExpWhitespace = RegExp("[" +
    "\u0020" + // SPACE
    "|\u00A0" + // NO-BREAK SPACE
    "|\u1680" + // OGHAM SPACE MARK
    "|\u2000" + // EN QUAD
    "|\u2001" + // EM QUAD
    "|\u2002" + // EN SPACE
    "|\u2003" + // EM SPACE
    "|\u2004" + // THREE-PER-EM SPACE
    "|\u2005" + // FOUR-PER-EM SPACE
    "|\u2006" + // SIX-PER-EM SPACE
    "|\u2007" + // FIGURE SPACE
    "|\u2008" + // PUNCTUATION SPACE
    "|\u2009" + // THIN SPACE
    "|\u200A" + // HAIR SPACE
    "|\u202F" + // NARROW NO-BREAK SPACE
    "|\u205F" + // MEDIUM MATHEMATICAL SPACE
    "|\u3000" + // IDEOGRAPHIC SPACE
    "|\u0009" + // HORIZONTAL TAB
    "|\u000B" + // VERTICAL TAB
    "|\u000C" + // FORM FEED
    "]+", "y");
exports.RegExpHex = RegExp("0[xX][a-fA-F0-9]+", "y");
exports.RegExpNumeric = RegExp("(" + "([0-9]*\\.[0-9]+)" + "|" + "([0-9]+)" + ")" + "([eE][\\+\\-]?[0-9]+)?", "y");
//# sourceMappingURL=patterns.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/index.js":
/*!**********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ResultUtils = __webpack_require__(/*! ./resultUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/resultUtils.js");
exports.ResultUtils = ResultUtils;
__export(__webpack_require__(/*! ./result */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/result.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/result.js":
/*!***********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/result.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
function okFactory(value) {
    return {
        kind: "Ok" /* Ok */,
        value,
    };
}
exports.okFactory = okFactory;
//# sourceMappingURL=result.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/resultUtils.js":
/*!****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/resultUtils.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
function okFactory(value) {
    return {
        kind: "Ok" /* Ok */,
        value,
    };
}
exports.okFactory = okFactory;
function errFactory(error) {
    return {
        kind: "Err" /* Err */,
        error,
    };
}
exports.errFactory = errFactory;
function isOk(result) {
    return result.kind === "Ok" /* Ok */;
}
exports.isOk = isOk;
function isErr(result) {
    return result.kind === "Err" /* Err */;
}
exports.isErr = isErr;
//# sourceMappingURL=resultUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/stringUtils.js":
/*!*********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/stringUtils.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line: no-require-imports
const GraphemeSplitter = __webpack_require__(/*! grapheme-splitter */ "../packages/powerquery-format/node_modules/grapheme-splitter/index.js");
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
exports.graphemeSplitter = new GraphemeSplitter();
function columnNumberFrom(text, requiredCodeUnit) {
    const graphemes = exports.graphemeSplitter.splitGraphemes(text);
    let columnNumber = 0;
    let summedCodeUnits = 0;
    for (const grapheme of graphemes) {
        if (summedCodeUnits === requiredCodeUnit) {
            return columnNumber;
        }
        else {
            summedCodeUnits += grapheme.length;
            columnNumber += 1;
        }
    }
    const details = {
        text,
        requiredCodeUnit,
    };
    throw new _1.CommonError.InvariantError(`no columnNumber can be generated for required codeUnit`, details);
}
exports.columnNumberFrom = columnNumberFrom;
function graphemePositionFrom(text, lineCodeUnit, lineNumber, maybeCodeUnit) {
    return {
        lineCodeUnit,
        lineNumber,
        columnNumber: columnNumberFrom(text, lineCodeUnit),
        maybeCodeUnit,
    };
}
exports.graphemePositionFrom = graphemePositionFrom;
function maybeRegexMatchLength(pattern, text, index) {
    pattern.lastIndex = index;
    const matches = pattern.exec(text);
    if (!matches) {
        return undefined;
    }
    else {
        return matches[0].length;
    }
}
exports.maybeRegexMatchLength = maybeRegexMatchLength;
function maybeNewlineKindAt(text, index) {
    const chr1 = text[index];
    switch (chr1) {
        case `\u000d`: {
            const chr2 = text[index + 1];
            return chr2 === `\u000a` ? "DoubleCharacter" /* DoubleCharacter */ : "SingleCharacter" /* SingleCharacter */;
        }
        case `\u000a`:
        case `\u0085`:
        case `\u2028`:
            return "SingleCharacter" /* SingleCharacter */;
        default:
            return undefined;
    }
}
exports.maybeNewlineKindAt = maybeNewlineKindAt;
// A quick and dirty way to do string formatting.
// Does not handle any escaping.
function expectFormat(template, args) {
    let result = template;
    for (const [key, value] of args.entries()) {
        const formatKey = `{${key}}`;
        if (template.indexOf(formatKey) === -1) {
            throw new _1.CommonError.InvariantError("unknown key", { formatKey });
        }
        result = result.replace(formatKey, value);
    }
    return result;
}
exports.expectFormat = expectFormat;
//# sourceMappingURL=stringUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/traversal.js":
/*!*******************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/traversal.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const parser_1 = __webpack_require__(/*! ../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const result_1 = __webpack_require__(/*! ./result */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/index.js");
// sets Node and NodesById for tryTraverse
function tryTraverseAst(state, nodeIdMapCollection, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn) {
    return tryTraverse(state, nodeIdMapCollection, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn);
}
exports.tryTraverseAst = tryTraverseAst;
// sets Node and NodesById for tryTraverse
function tryTraverseXor(state, nodeIdMapCollection, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn) {
    return tryTraverse(state, nodeIdMapCollection, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn);
}
exports.tryTraverseXor = tryTraverseXor;
function tryTraverse(state, nodesById, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn) {
    try {
        traverseRecursion(state, nodesById, root, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn);
        return result_1.ResultUtils.okFactory(state.result);
    }
    catch (e) {
        return result_1.ResultUtils.errFactory(_1.CommonError.ensureCommonError(state.localizationTemplates, e));
    }
}
exports.tryTraverse = tryTraverse;
// a TExpandNodesFn usable by tryTraverseAst which visits all nodes.
function expectExpandAllAstChildren(_state, astNode, nodeIdMapCollection) {
    const maybeChildIds = nodeIdMapCollection.childIdsById.get(astNode.id);
    if (maybeChildIds) {
        const childIds = maybeChildIds;
        return childIds.map(nodeId => parser_1.NodeIdMapUtils.expectAstNode(nodeIdMapCollection.astNodeById, nodeId));
    }
    else {
        return [];
    }
}
exports.expectExpandAllAstChildren = expectExpandAllAstChildren;
// a TExpandNodesFn usable by tryTraverseXor which visits all nodes.
function expectExpandAllXorChildren(_state, xorNode, nodeIdMapCollection) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */: {
            const astNode = xorNode.node;
            return expectExpandAllAstChildren(_state, astNode, nodeIdMapCollection).map(childAstNode => {
                return {
                    kind: "Ast" /* Ast */,
                    node: childAstNode,
                };
            });
        }
        case "Context" /* Context */: {
            const result = [];
            const contextNode = xorNode.node;
            const maybeChildIds = nodeIdMapCollection.childIdsById.get(contextNode.id);
            if (maybeChildIds !== undefined) {
                const childIds = maybeChildIds;
                for (const childId of childIds) {
                    const maybeAstChild = nodeIdMapCollection.astNodeById.get(childId);
                    if (maybeAstChild) {
                        const astChild = maybeAstChild;
                        result.push({
                            kind: "Ast" /* Ast */,
                            node: astChild,
                        });
                        continue;
                    }
                    const maybeContextChild = nodeIdMapCollection.contextNodeById.get(childId);
                    if (maybeContextChild) {
                        const contextChild = maybeContextChild;
                        result.push({
                            kind: "Context" /* Context */,
                            node: contextChild,
                        });
                        continue;
                    }
                    const details = { nodeId: childId };
                    throw new _1.CommonError.InvariantError(`nodeId should be found in either astNodesById or contextNodesById`, details);
                }
            }
            return result;
        }
        default:
            throw _1.isNever(xorNode);
    }
}
exports.expectExpandAllXorChildren = expectExpandAllXorChildren;
// Returns the TXorNode's parent if one exists.
function maybeExpandXorParent(_state, xorNode, nodeIdMapCollection) {
    const maybeParent = parser_1.NodeIdMapUtils.maybeParentXorNode(nodeIdMapCollection, xorNode.node.id);
    return maybeParent !== undefined ? [maybeParent] : [];
}
exports.maybeExpandXorParent = maybeExpandXorParent;
function traverseRecursion(state, nodesById, node, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn) {
    if (maybeEarlyExitFn && maybeEarlyExitFn(state, node)) {
        return;
    }
    else if (strategy === "BreadthFirst" /* BreadthFirst */) {
        visitNodeFn(state, node);
    }
    for (const child of expandNodesFn(state, node, nodesById)) {
        traverseRecursion(state, nodesById, child, strategy, visitNodeFn, expandNodesFn, maybeEarlyExitFn);
    }
    if (strategy === "DepthFirst" /* DepthFirst */) {
        visitNodeFn(state, node);
    }
}
//# sourceMappingURL=traversal.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/typeUtils.js":
/*!*******************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/typeUtils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=typeUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js":
/*!********************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Inspection = __webpack_require__(/*! ./inspection */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/index.js");
exports.Inspection = Inspection;
__export(__webpack_require__(/*! ./common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js"));
__export(__webpack_require__(/*! ./lexer */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js"));
__export(__webpack_require__(/*! ./localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js"));
__export(__webpack_require__(/*! ./parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js"));
__export(__webpack_require__(/*! ./settings */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/settings.js"));
__export(__webpack_require__(/*! ./tasks */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/tasks.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/activeNodeUtils.js":
/*!****************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/activeNodeUtils.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const parser_1 = __webpack_require__(/*! ../../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const position_1 = __webpack_require__(/*! ../position */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js");
// Read ActiveNode's comments before this.
//
// Searches all leaf Ast.TNodes and Context nodes to find the "active" node.
// ' 1 + ' -> the second operand, a Context node, in an ArithmeticExpression.
// 'let x=|1 in x' -> the value part of the key-value-pair.
// 'foo(|)' -> the zero length ArrayWrapper of an InvokeExpression
//
// First, When the position is on a constant the selected Ast.TNode might have to be shifted one to the right.
// This happens with atomic constants such as '+', '=>', '[', '(' etc.
// However if you shifted right on '(' for 'foo(|)' then the ActiveNode would be ')' instead of the ArrayWrapper.
//
// Second, parser errors also need to be taken care of.
// '1+|' is an error and the latest leaf is '+',
// but the ActiveNode should be the second operand in the ArithmeticExpression.
//
// Third, sometimes we don't want to shift at all.
// Nodes that prevent shifting are called anchor nodes.
// 'if x t|' shouldn't shift to the Constant for 'then', instead the ActiveNode should select 't'.
// 'let x = 1|' shouldn't shift to the Constant for 'in', instead the ActiveNode should select '1'.
function maybeActiveNode(position, nodeIdMapCollection, leafNodeIds) {
    const astSearch = positionAstSearch(position, nodeIdMapCollection, leafNodeIds);
    const maybeContextSearch = positionContextSearch(astSearch, nodeIdMapCollection);
    let maybeLeaf;
    if (astSearch.maybeShiftedNode !== undefined) {
        maybeLeaf = parser_1.NodeIdMapUtils.xorNodeFromAst(astSearch.maybeShiftedNode);
    }
    else if (astSearch.maybeNode !== undefined && isAnchorNode(position, astSearch.maybeNode)) {
        maybeLeaf = parser_1.NodeIdMapUtils.xorNodeFromAst(astSearch.maybeNode);
    }
    else if (maybeContextSearch !== undefined) {
        maybeLeaf = parser_1.NodeIdMapUtils.xorNodeFromContext(maybeContextSearch);
    }
    else if (astSearch.maybeNode !== undefined) {
        maybeLeaf = parser_1.NodeIdMapUtils.xorNodeFromAst(astSearch.maybeNode);
    }
    else {
        maybeLeaf = undefined;
    }
    if (maybeLeaf === undefined) {
        return undefined;
    }
    const leaf = maybeLeaf;
    return {
        position,
        ancestry: parser_1.NodeIdMapUtils.expectAncestry(nodeIdMapCollection, leaf.node.id),
        maybeIdentifierUnderPosition: maybeIdentifierUnderPosition(position, nodeIdMapCollection, leaf),
    };
}
exports.maybeActiveNode = maybeActiveNode;
function expectRoot(activeNode) {
    const ancestry = activeNode.ancestry;
    return ancestry[ancestry.length - 1];
}
exports.expectRoot = expectRoot;
function expectLeaf(activeNode) {
    return activeNode.ancestry[0];
}
exports.expectLeaf = expectLeaf;
function maybePreviousXorNode(activeNode, ancestorIndex, n = 1, maybeNodeKinds = undefined) {
    const maybeXorNode = activeNode.ancestry[ancestorIndex - n];
    if (maybeXorNode !== undefined && maybeNodeKinds !== undefined) {
        return maybeNodeKinds.indexOf(maybeXorNode.node.kind) !== -1 ? maybeXorNode : undefined;
    }
    else {
        return maybeXorNode;
    }
}
exports.maybePreviousXorNode = maybePreviousXorNode;
function maybeNextXorNode(activeNode, ancestorIndex, n = 1) {
    return activeNode.ancestry[ancestorIndex + n];
}
exports.maybeNextXorNode = maybeNextXorNode;
function expectPreviousXorNode(activeNode, ancestorIndex, n = 1, maybeAllowedNodeKinds = undefined) {
    const maybeXorNode = maybePreviousXorNode(activeNode, ancestorIndex, n);
    if (maybeXorNode === undefined) {
        throw new common_1.CommonError.InvariantError("no previous node");
    }
    const xorNode = maybeXorNode;
    if (maybeAllowedNodeKinds !== undefined) {
        const details = {
            fnName: expectPreviousXorNode.name,
            nodeId: xorNode.node.id,
            expectedAny: maybeAllowedNodeKinds,
            actual: xorNode.node.kind,
        };
        const maybeErr = parser_1.AstUtils.testAnyNodeKind(xorNode.node.kind, maybeAllowedNodeKinds, details);
        if (maybeErr) {
            throw maybeErr;
        }
    }
    return maybeXorNode;
}
exports.expectPreviousXorNode = expectPreviousXorNode;
function expectNextXorNode(activeNode, ancestorIndex, n = 1, maybeAllowedNodeKinds = undefined) {
    const maybeXorNode = maybeNextXorNode(activeNode, ancestorIndex, n);
    if (maybeXorNode === undefined) {
        throw new common_1.CommonError.InvariantError("no next node");
    }
    const xorNode = maybeXorNode;
    if (maybeAllowedNodeKinds !== undefined) {
        const details = {
            fnName: expectNextXorNode.name,
            nodeId: xorNode.node.id,
            expectedAny: maybeAllowedNodeKinds,
            actual: xorNode.node.kind,
        };
        const maybeErr = parser_1.AstUtils.testAnyNodeKind(xorNode.node.kind, maybeAllowedNodeKinds, details);
        if (maybeErr) {
            throw maybeErr;
        }
    }
    return maybeXorNode;
}
exports.expectNextXorNode = expectNextXorNode;
const DrilldownConstantKind = [
    "{" /* LeftBrace */,
    "[" /* LeftBracket */,
    "(" /* LeftParenthesis */,
];
const ShiftRightConstantKinds = [
    "," /* Comma */,
    "=" /* Equal */,
    "=>" /* FatArrow */,
    "}" /* RightBrace */,
    "]" /* RightBracket */,
    ")" /* RightParenthesis */,
    ";" /* Semicolon */,
    ...DrilldownConstantKind,
];
function isAnchorNode(position, astNode) {
    if (!position_1.PositionUtils.isInAstNode(position, astNode, true, true)) {
        return false;
    }
    if (astNode.kind === "Identifier" /* Identifier */ || astNode.kind === "GeneralizedIdentifier" /* GeneralizedIdentifier */) {
        return true;
    }
    else if (astNode.kind === "LiteralExpression" /* LiteralExpression */ && astNode.literalKind === "Numeric" /* Numeric */) {
        return true;
    }
    else if (astNode.kind === "Constant" /* Constant */) {
        switch (astNode.constantKind) {
            case "as" /* As */:
            case "each" /* Each */:
            case "else" /* Else */:
            case "error" /* Error */:
            case "if" /* If */:
            case "in" /* In */:
            case "is" /* Is */:
            case "section" /* Section */:
            case "shared" /* Shared */:
            case "let" /* Let */:
            case "meta" /* Meta */:
            case "otherwise" /* Otherwise */:
            case "then" /* Then */:
            case "try" /* Try */:
            case "type" /* Type */:
            case "null" /* Null */:
                return true;
            default:
                return false;
        }
    }
    else {
        return false;
    }
}
function positionAstSearch(position, nodeIdMapCollection, leafNodeIds) {
    const astNodeById = nodeIdMapCollection.astNodeById;
    let maybeCurrentOnOrBefore;
    let maybeCurrentAfter;
    let maybeShiftedNode;
    // Find:
    //  the closest leaf to the left or on position.
    //  the closest leaf to the right of position.
    for (const nodeId of leafNodeIds) {
        const candidate = parser_1.NodeIdMapUtils.expectAstNode(astNodeById, nodeId);
        let isBoundIncluded;
        if (
        // let x|=1
        (candidate.kind === "Constant" /* Constant */ &&
            ShiftRightConstantKinds.indexOf(candidate.constantKind) !== -1) ||
            // let x=|1
            (maybeCurrentOnOrBefore !== undefined &&
                maybeCurrentOnOrBefore.kind === "Constant" /* Constant */ &&
                ShiftRightConstantKinds.indexOf(maybeCurrentOnOrBefore.constantKind) !== -1)) {
            isBoundIncluded = false;
        }
        else {
            isBoundIncluded = true;
        }
        if (!position_1.PositionUtils.isBeforeTokenPosition(position, candidate.tokenRange.positionStart, isBoundIncluded)) {
            if (maybeCurrentOnOrBefore === undefined) {
                maybeCurrentOnOrBefore = candidate;
            }
            else {
                if (candidate.tokenRange.tokenIndexStart > maybeCurrentOnOrBefore.tokenRange.tokenIndexStart) {
                    maybeCurrentOnOrBefore = candidate;
                }
            }
        }
        // Check if after position.
        else {
            if (maybeCurrentAfter === undefined) {
                maybeCurrentAfter = candidate;
            }
            else {
                if (candidate.tokenRange.tokenIndexStart < maybeCurrentAfter.tokenRange.tokenIndexStart) {
                    maybeCurrentAfter = candidate;
                }
            }
        }
    }
    // Might need to shift.
    if (maybeCurrentOnOrBefore !== undefined && maybeCurrentOnOrBefore.kind === "Constant" /* Constant */) {
        const currentOnOrBefore = maybeCurrentOnOrBefore;
        // Requires a shift into an empty ArrayWrapper.
        if (DrilldownConstantKind.indexOf(maybeCurrentOnOrBefore.constantKind) !== -1 &&
            maybeCurrentAfter !== undefined &&
            maybeCurrentAfter.kind === "Constant" /* Constant */ &&
            parser_1.AstUtils.isPairedWrapperConstantKinds(maybeCurrentOnOrBefore.constantKind, maybeCurrentAfter.constantKind)) {
            const parent = parser_1.NodeIdMapUtils.expectParentAstNode(nodeIdMapCollection, currentOnOrBefore.id, [
                "RecordExpression" /* RecordExpression */,
                "RecordLiteral" /* RecordLiteral */,
                "ListExpression" /* ListExpression */,
                "ListLiteral" /* ListLiteral */,
                "InvokeExpression" /* InvokeExpression */,
            ]);
            const arrayWrapper = parser_1.NodeIdMapUtils.expectAstChildByAttributeIndex(nodeIdMapCollection, parent.id, 1, ["ArrayWrapper" /* ArrayWrapper */]);
            maybeShiftedNode = arrayWrapper;
        }
        // Requires a shift to the right.
        else if (ShiftRightConstantKinds.indexOf(currentOnOrBefore.constantKind) !== -1) {
            maybeShiftedNode = maybeCurrentAfter;
        }
        // No shifting.
        else {
            maybeShiftedNode = undefined;
        }
    }
    else {
        maybeShiftedNode = undefined;
    }
    return {
        maybeNode: maybeCurrentOnOrBefore,
        maybeShiftedNode,
    };
}
function positionContextSearch(astNodeSearch, nodeIdMapCollection) {
    if (astNodeSearch.maybeNode === undefined) {
        return undefined;
    }
    const tokenIndexLowBound = astNodeSearch.maybeNode.tokenRange.tokenIndexStart;
    let maybeCurrent = undefined;
    for (const candidate of nodeIdMapCollection.contextNodeById.values()) {
        if (candidate.maybeTokenStart) {
            if (candidate.tokenIndexStart < tokenIndexLowBound) {
                continue;
            }
            if (maybeCurrent === undefined || maybeCurrent.id < candidate.id) {
                maybeCurrent = candidate;
            }
        }
    }
    return maybeCurrent;
}
function maybeIdentifierUnderPosition(position, nodeIdMapCollection, leaf) {
    if (leaf.kind !== "Ast" /* Ast */) {
        return undefined;
    }
    let identifier;
    // If closestLeaf is '@', then check if it's part of an IdentifierExpression.
    if (leaf.node.kind === "Constant" /* Constant */ && leaf.node.constantKind === "@" /* AtSign */) {
        const maybeParentId = nodeIdMapCollection.parentIdById.get(leaf.node.id);
        if (maybeParentId === undefined) {
            return undefined;
        }
        const parentId = maybeParentId;
        const parent = parser_1.NodeIdMapUtils.expectAstNode(nodeIdMapCollection.astNodeById, parentId);
        if (parent.kind !== "IdentifierExpression" /* IdentifierExpression */) {
            return undefined;
        }
        identifier = parent.identifier;
    }
    else if (leaf.node.kind === "Identifier" /* Identifier */ || leaf.node.kind === "GeneralizedIdentifier" /* GeneralizedIdentifier */) {
        identifier = leaf.node;
    }
    else {
        return undefined;
    }
    if (position_1.PositionUtils.isInAstNode(position, identifier, false, true)) {
        return identifier;
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=activeNodeUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js":
/*!******************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const ActiveNodeUtils = __webpack_require__(/*! ./activeNodeUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/activeNodeUtils.js");
exports.ActiveNodeUtils = ActiveNodeUtils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/autocomplete.js":
/*!**************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/autocomplete.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const result_1 = __webpack_require__(/*! ../common/result */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/result/index.js");
const lexer_1 = __webpack_require__(/*! ../lexer */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js");
const parser_1 = __webpack_require__(/*! ../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const activeNode_1 = __webpack_require__(/*! ./activeNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js");
const position_1 = __webpack_require__(/*! ./position */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js");
function tryFrom(settings, maybeActiveNode, nodeIdMapCollection, maybeParseError) {
    if (maybeActiveNode === undefined) {
        return result_1.ResultUtils.okFactory({
            autocompleteKeywords: ExpressionAutocomplete,
        });
    }
    const activeNode = maybeActiveNode;
    const leaf = activeNode.ancestry[0];
    const maybeParseErrorToken = maybeParseError
        ? parser_1.ParseError.maybeTokenFrom(maybeParseError.innerError)
        : undefined;
    let maybePositionName;
    if (position_1.PositionUtils.isInXorNode(activeNode.position, nodeIdMapCollection, leaf, false, true)) {
        if (activeNode.maybeIdentifierUnderPosition !== undefined) {
            maybePositionName = activeNode.maybeIdentifierUnderPosition.literal;
        }
        // Matches 'null', 'true', and 'false'.
        else if (leaf.kind === "Ast" /* Ast */ &&
            leaf.node.kind === "LiteralExpression" /* LiteralExpression */ &&
            (leaf.node.literalKind === "Logical" /* Logical */ || leaf.node.literalKind === "Null" /* Null */)) {
            maybePositionName = leaf.node.literal;
        }
    }
    const triedAutocomplete = traverseAncestors(settings, activeNode, nodeIdMapCollection, maybeParseErrorToken);
    if (result_1.ResultUtils.isErr(triedAutocomplete)) {
        return triedAutocomplete;
    }
    let inspected = handleEdgeCases(triedAutocomplete.value, activeNode, maybeParseErrorToken);
    inspected = filterRecommendations(inspected, maybePositionName);
    return result_1.ResultUtils.okFactory({ autocompleteKeywords: inspected });
}
exports.tryFrom = tryFrom;
// Travel the ancestry path in Active node in [parent, child] pairs.
// Without zipping the values we wouldn't know what we're completing for.
// For example 'if true |' gives us a pair something like [IfExpression, Constant].
// We can now know we failed to parse a 'then' constant.
function traverseAncestors(settings, activeNode, nodeIdMapCollection, maybeParseErrorToken) {
    const ancestry = activeNode.ancestry;
    const numNodes = ancestry.length;
    let maybeInspected;
    try {
        for (let index = 1; index < numNodes; index += 1) {
            const parent = ancestry[index];
            const child = ancestry[index - 1];
            switch (parent.node.kind) {
                case "ErrorHandlingExpression" /* ErrorHandlingExpression */:
                    maybeInspected = autocompleteErrorHandlingExpression(activeNode.position, child, maybeParseErrorToken);
                    break;
                case "ListExpression" /* ListExpression */:
                    maybeInspected = autocompleteListExpression(activeNode, child, index);
                    break;
                case "SectionMember" /* SectionMember */:
                    maybeInspected = autocompleteSectionMember(nodeIdMapCollection, activeNode, parent, child, index);
                    break;
                default: {
                    const key = createMapKey(parent.node.kind, child.node.maybeAttributeIndex);
                    if (AutocompleteExpressionKeys.indexOf(key) !== -1) {
                        if (child.kind === "Context" /* Context */ ||
                            position_1.PositionUtils.isBeforeAstNode(activeNode.position, child.node, false)) {
                            maybeInspected = ExpressionAutocomplete;
                        }
                    }
                    else {
                        const maybeMappedKeywordKind = AutocompleteConstantMap.get(key);
                        if (maybeMappedKeywordKind) {
                            maybeInspected = autocompleteKeywordConstant(activeNode, child, maybeMappedKeywordKind);
                        }
                    }
                    break;
                }
            }
            if (maybeInspected !== undefined) {
                return result_1.ResultUtils.okFactory(maybeInspected);
            }
        }
    }
    catch (err) {
        return result_1.ResultUtils.errFactory(common_1.CommonError.ensureCommonError(settings.localizationTemplates, err));
    }
    return result_1.ResultUtils.okFactory([]);
}
function handleEdgeCases(inspected, activeNode, maybeParseErrorToken) {
    // Check if they're typing for the first time at the start of the file,
    // which defaults to searching for an identifier.
    if (maybeParseErrorToken === undefined &&
        activeNode.ancestry.length === 2 &&
        activeNode.ancestry[0].node.kind === "Identifier" /* Identifier */ &&
        activeNode.ancestry[1].node.kind === "IdentifierExpression" /* IdentifierExpression */) {
        inspected = ExpressionAndSectionAutocomplete;
    }
    if (maybeParseErrorToken !== undefined &&
        position_1.PositionUtils.isInToken(activeNode.position, maybeParseErrorToken, false, true)) {
        inspected = updateWithParseErrorToken(inspected, activeNode, maybeParseErrorToken);
    }
    return inspected;
}
function filterRecommendations(inspected, maybePositionName) {
    if (maybePositionName === undefined) {
        return inspected;
    }
    const positionName = maybePositionName;
    return inspected.filter((kind) => kind.startsWith(positionName));
}
const ExpressionAutocomplete = lexer_1.TExpressionKeywords;
const ExpressionAndSectionAutocomplete = [...lexer_1.TExpressionKeywords, "section" /* Section */];
const AutocompleteExpressionKeys = [
    createMapKey("ErrorRaisingExpression" /* ErrorRaisingExpression */, 1),
    createMapKey("GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */, 2),
    createMapKey("IdentifierPairedExpression" /* IdentifierPairedExpression */, 2),
    createMapKey("IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */, 2),
    createMapKey("IfExpression" /* IfExpression */, 1),
    createMapKey("IfExpression" /* IfExpression */, 3),
    createMapKey("IfExpression" /* IfExpression */, 5),
    createMapKey("InvokeExpression" /* InvokeExpression */, 0),
    createMapKey("InvokeExpression" /* InvokeExpression */, 1),
    createMapKey("InvokeExpression" /* InvokeExpression */, 2),
    createMapKey("ListExpression" /* ListExpression */, 1),
    createMapKey("OtherwiseExpression" /* OtherwiseExpression */, 1),
    createMapKey("ParenthesizedExpression" /* ParenthesizedExpression */, 1),
];
// If we're coming from a constant then we can quickly evaluate using a map.
// This is possible because reading a Constant is binary.
// Either the Constant was read and you're in the next context, or you didn't and you're in the constant's context.
const AutocompleteConstantMap = new Map([
    // Ast.NodeKind.ErrorRaisingExpression
    [createMapKey("ErrorRaisingExpression" /* ErrorRaisingExpression */, 0), "error" /* Error */],
    // Ast.NodeKind.IfExpression
    [createMapKey("IfExpression" /* IfExpression */, 0), "if" /* If */],
    [createMapKey("IfExpression" /* IfExpression */, 2), "then" /* Then */],
    [createMapKey("IfExpression" /* IfExpression */, 4), "else" /* Else */],
    // Ast.NodeKind.OtherwiseExpression
    [createMapKey("OtherwiseExpression" /* OtherwiseExpression */, 0), "otherwise" /* Otherwise */],
    // Ast.NodeKind.Section
    [createMapKey("Section" /* Section */, 1), "section" /* Section */],
]);
// Used with maybeParseError to see if a user could be typing a conjunctive keyword such as 'or'. Eg.
// 'Details[UserName] <> "" o|'
const PartialConjunctionKeywordAutocompleteMap = new Map([
    ["a", ["and" /* And */, "as" /* As */]],
    ["o", ["or" /* Or */]],
    ["m", ["meta" /* Meta */]],
]);
function updateWithParseErrorToken(inspected, activeNode, parseErrorToken) {
    const parseErrorTokenData = parseErrorToken.data;
    const maybeAllowedKeywords = PartialConjunctionKeywordAutocompleteMap.get(parseErrorTokenData[0].toLocaleLowerCase());
    if (maybeAllowedKeywords === undefined) {
        return inspected;
    }
    const allowedKeywords = maybeAllowedKeywords;
    for (const ancestor of activeNode.ancestry) {
        if (parser_1.NodeIdMapUtils.isTUnaryType(ancestor)) {
            return updateUsingConjunctionKeywords(inspected, parseErrorTokenData, allowedKeywords);
        }
    }
    return inspected;
}
// Given a list of possible conjunction keywords, update inspected with any matching conjunction keywords.
function updateUsingConjunctionKeywords(inspected, parseErrorTokenData, allowedKeywords) {
    const newAllowedAutocompleteKeywords = [...inspected];
    for (const keyword of allowedKeywords) {
        if (keyword.startsWith(parseErrorTokenData) && newAllowedAutocompleteKeywords.indexOf(keyword) === -1) {
            newAllowedAutocompleteKeywords.push(keyword);
        }
    }
    return newAllowedAutocompleteKeywords;
}
// A tuple can't easily be used as a Map key as it does a shallow comparison.
// The work around is to stringify the tuple key, even though we lose typing by doing so.
// Hopefully by having a 'createMapKey' function this will prevent bugs.
// [parent XorNode.node.kind, child XorNode.node.maybeAttributeIndex].join(",")
function createMapKey(nodeKind, maybeAttributeIndex) {
    return [nodeKind, maybeAttributeIndex].join(",");
}
function autocompleteKeywordConstant(activeNode, child, keywordKind) {
    if (position_1.PositionUtils.isBeforeXorNode(activeNode.position, child, false)) {
        return undefined;
    }
    else if (child.kind === "Ast" /* Ast */) {
        // So long as you're inside of an Ast Constant there's nothing that can be recommended other than the constant.
        // Note that we previously checked isBeforeXorNode so we can use the quicker isOnAstNodeEnd to check
        // if we're inside of the Ast node.
        return position_1.PositionUtils.isOnAstNodeEnd(activeNode.position, child.node) ? [] : [keywordKind];
    }
    // !isBeforeXorNode && child.kind === XorNodeKind.Context
    return [keywordKind];
}
function autocompleteErrorHandlingExpression(position, child, maybeParseErrorToken) {
    const maybeChildAttributeIndex = child.node.maybeAttributeIndex;
    if (maybeChildAttributeIndex === 0) {
        return ["try" /* Try */];
    }
    else if (maybeChildAttributeIndex === 1) {
        // 'try true o|' creates a ParseError.
        // It's ambiguous if the next token should be either 'otherwise' or 'or'.
        if (maybeParseErrorToken !== undefined) {
            const errorToken = maybeParseErrorToken;
            // First we test if we can autocomplete using the error token.
            if (errorToken.kind === "Identifier" /* Identifier */ &&
                position_1.PositionUtils.isInToken(position, maybeParseErrorToken, false, true)) {
                const tokenData = maybeParseErrorToken.data;
                // If we can exclude 'or' then the only thing we can autocomplete is 'otherwise'.
                if (tokenData.length > 1 && "otherwise" /* Otherwise */.startsWith(tokenData)) {
                    return ["otherwise" /* Otherwise */];
                }
                // In the ambiguous case we don't know what they're typing yet, so we suggest both.
                // In the case of an identifier that doesn't match a 'or' or 'otherwise'
                // we still suggest the only valid keywords allowed.
                // In both cases the return is the same.
                else {
                    return ["or" /* Or */, "otherwise" /* Otherwise */];
                }
            }
            // There exists an error token we can't map it to an OtherwiseExpression.
            else {
                return undefined;
            }
        }
        else if (child.kind === "Ast" /* Ast */ && position_1.PositionUtils.isAfterAstNode(position, child.node, true)) {
            return ["otherwise" /* Otherwise */];
        }
        else {
            return ExpressionAutocomplete;
        }
    }
    else {
        return undefined;
    }
}
function autocompleteListExpression(activeNode, child, ancestorIndex) {
    // '{' or '}'
    if (child.node.maybeAttributeIndex === 0 || child.node.maybeAttributeIndex === 2) {
        return undefined;
    }
    else if (child.node.maybeAttributeIndex !== 1) {
        const details = {
            nodeId: child.node.id,
            maybeAttributeIndex: child.node.maybeAttributeIndex,
        };
        throw new common_1.CommonError.InvariantError("ListExpression child has an invalid maybeAttributeIndex", details);
    }
    // ListExpression -> ArrayWrapper -> Csv -> X
    const nodeOrComma = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(activeNode, ancestorIndex, 3, undefined);
    if (nodeOrComma.node.maybeAttributeIndex !== 0) {
        return undefined;
    }
    // We know it's the node component of the Csv,
    // but we have to drill down one more level if it's a RangeExpression.
    const itemNode = nodeOrComma.node.kind === "RangeExpression" /* RangeExpression */
        ? activeNode_1.ActiveNodeUtils.expectPreviousXorNode(activeNode, ancestorIndex, 4, undefined)
        : nodeOrComma;
    if (itemNode.kind === "Context" /* Context */ || position_1.PositionUtils.isBeforeXorNode(activeNode.position, itemNode, false)) {
        return ExpressionAutocomplete;
    }
    else {
        return undefined;
    }
}
// Test if 'shared' could be what's being typed. Eg.
// 'section s' -> could either be interpreted as either the 'shared' keyword, or the key-value-pair key is 's'.
function autocompleteSectionMember(nodeIdMapCollection, activeNode, parent, child, ancestorIndex) {
    // SectionMember.namePairedExpression
    if (child.node.maybeAttributeIndex === 2) {
        // A test for 'shared', which as we're on namePairedExpression we either parsed it or skipped it.
        const maybeSharedConstant = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, parent.node.id, 1, [
            "Constant" /* Constant */,
        ]);
        // 'shared' was parsed so we can exit.
        if (maybeSharedConstant !== undefined) {
            return undefined;
        }
        // SectionMember -> IdentifierPairedExpression -> Identifier
        const maybeName = activeNode_1.ActiveNodeUtils.maybePreviousXorNode(activeNode, ancestorIndex, 2, [
            "IdentifierPairedExpression" /* IdentifierPairedExpression */,
            "Identifier" /* Identifier */,
        ]);
        // Name hasn't been parsed yet so we can exit.
        if (maybeName === undefined || maybeName.kind !== "Ast" /* Ast */) {
            return undefined;
        }
        const name = maybeName.node;
        if ("shared" /* Shared */.startsWith(name.literal)) {
            return ["shared" /* Shared */];
        }
    }
    return undefined;
}
//# sourceMappingURL=autocomplete.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/index.js":
/*!*******************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const InspectionUtils = __webpack_require__(/*! ./inspectionUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspectionUtils.js");
exports.InspectionUtils = InspectionUtils;
__export(__webpack_require__(/*! ./inspection */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspection.js"));
__export(__webpack_require__(/*! ./position */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js"));
__export(__webpack_require__(/*! ./scope */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspection.js":
/*!************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspection.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const activeNode_1 = __webpack_require__(/*! ./activeNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js");
const autocomplete_1 = __webpack_require__(/*! ./autocomplete */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/autocomplete.js");
const scope_1 = __webpack_require__(/*! ./scope */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/index.js");
function tryFrom(settings, position, nodeIdMapCollection, leafNodeIds, maybeParseError) {
    const maybeActiveNode = activeNode_1.ActiveNodeUtils.maybeActiveNode(position, nodeIdMapCollection, leafNodeIds);
    const triedInspectedScope = scope_1.tryInspectScope(settings, maybeActiveNode, nodeIdMapCollection, leafNodeIds);
    if (common_1.ResultUtils.isErr(triedInspectedScope)) {
        return triedInspectedScope;
    }
    const triedInspectedKeyword = autocomplete_1.tryFrom(settings, maybeActiveNode, nodeIdMapCollection, maybeParseError);
    if (common_1.ResultUtils.isErr(triedInspectedKeyword)) {
        return triedInspectedKeyword;
    }
    return common_1.ResultUtils.okFactory(Object.assign(Object.assign({ maybeActiveNode }, triedInspectedScope.value), triedInspectedKeyword.value));
}
exports.tryFrom = tryFrom;
//# sourceMappingURL=inspection.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspectionUtils.js":
/*!*****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/inspectionUtils.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const activeNode_1 = __webpack_require__(/*! ./activeNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js");
// Should only be called: RecordLiteral, RecordExpression, SectionMember
function isInKeyValuePairAssignment(state) {
    // How far back do we look to find a paired expression?
    //
    // For SectionMember it's a single indirection, eg:
    // 'X -> KeyValuePair'
    //
    // For everything else it's 3, where the extra 2 come from an array of Csvs, eg:
    // 'Current -> ArrayWrapper -> Csv -> KeyValuePair'
    let n;
    if (state.activeNode.ancestry[state.nodeIndex].node.kind === "SectionMember" /* SectionMember */) {
        n = 1;
    }
    else {
        n = 3;
    }
    const maybeKeyValuePair = activeNode_1.ActiveNodeUtils.maybePreviousXorNode(state.activeNode, state.nodeIndex, n, [
        "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */,
        "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */,
        "IdentifierPairedExpression" /* IdentifierPairedExpression */,
        "IdentifierExpressionPairedExpression" /* IdentifierExpressionPairedExpression */,
    ]);
    if (maybeKeyValuePair === undefined) {
        return false;
    }
    const keyValuePair = maybeKeyValuePair;
    const ancestry = state.activeNode.ancestry;
    const keyValuePairAncestryIndex = ancestry.indexOf(keyValuePair);
    if (keyValuePairAncestryIndex === -1) {
        throw new common_1.CommonError.InvariantError("xorNode isn't in ancestry");
    }
    const maybeChild = ancestry[keyValuePairAncestryIndex - 1];
    if (maybeChild === undefined) {
        const details = { keyValuePairId: keyValuePair.node.id };
        throw new common_1.CommonError.InvariantError("expected xorNode to have a child", details);
    }
    return maybeChild.node.maybeAttributeIndex === 2;
}
exports.isInKeyValuePairAssignment = isInKeyValuePairAssignment;
//# sourceMappingURL=inspectionUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js":
/*!****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const PositionUtils = __webpack_require__(/*! ./positionUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/positionUtils.js");
exports.PositionUtils = PositionUtils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/positionUtils.js":
/*!************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/positionUtils.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const parser_1 = __webpack_require__(/*! ../../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
function isBeforeXorNode(position, xorNode, isBoundIncluded) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */:
            return isBeforeAstNode(position, xorNode.node, isBoundIncluded);
        case "Context" /* Context */:
            return isBeforeContextNode(position, xorNode.node, isBoundIncluded);
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.isBeforeXorNode = isBeforeXorNode;
function isInXorNode(position, nodeIdMapCollection, xorNode, isLowerBoundIncluded, isUpperBoundIncluded) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */:
            return isInAstNode(position, xorNode.node, isLowerBoundIncluded, isUpperBoundIncluded);
        case "Context" /* Context */:
            return isInContextNode(position, nodeIdMapCollection, xorNode.node, isLowerBoundIncluded, isUpperBoundIncluded);
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.isInXorNode = isInXorNode;
function isOnXorNodeStart(position, xorNode) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */:
            return isOnAstNodeStart(position, xorNode.node);
        case "Context" /* Context */:
            return isOnContextNodeStart(position, xorNode.node);
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.isOnXorNodeStart = isOnXorNodeStart;
function isOnXorNodeEnd(position, xorNode, nodeIdMapCollection) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */:
            return isOnAstNodeEnd(position, xorNode.node);
        case "Context" /* Context */:
            return isOnContextNodeEnd(position, xorNode.node, nodeIdMapCollection);
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.isOnXorNodeEnd = isOnXorNodeEnd;
function isAfterXorNode(position, nodeIdMapCollection, xorNode, isBoundIncluded) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */:
            return isAfterAstNode(position, xorNode.node, isBoundIncluded);
        case "Context" /* Context */:
            return isAfterContextNode(position, nodeIdMapCollection, xorNode.node, isBoundIncluded);
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.isAfterXorNode = isAfterXorNode;
function isBeforeContextNode(position, contextNode, isBoundIncluded) {
    const maybeTokenStart = contextNode.maybeTokenStart;
    if (maybeTokenStart === undefined) {
        return false;
    }
    const tokenStart = maybeTokenStart;
    return isBeforeTokenPosition(position, tokenStart.positionStart, isBoundIncluded);
}
exports.isBeforeContextNode = isBeforeContextNode;
function isInContextNode(position, nodeIdMapCollection, contextNode, isLowerBoundIncluded, isHigherBoundIncluded) {
    return (!isBeforeContextNode(position, contextNode, isLowerBoundIncluded) &&
        !isAfterContextNode(position, nodeIdMapCollection, contextNode, isHigherBoundIncluded));
}
exports.isInContextNode = isInContextNode;
function isOnContextNodeStart(position, contextNode) {
    return contextNode.maybeTokenStart !== undefined
        ? isOnTokenPosition(position, contextNode.maybeTokenStart.positionStart)
        : false;
}
exports.isOnContextNodeStart = isOnContextNodeStart;
function isOnContextNodeEnd(position, contextNode, nodeIdMapCollection) {
    const maybeLeaf = parser_1.NodeIdMapUtils.maybeRightMostLeaf(nodeIdMapCollection, contextNode.id);
    if (maybeLeaf === undefined) {
        return false;
    }
    return isOnAstNodeEnd(position, maybeLeaf);
}
exports.isOnContextNodeEnd = isOnContextNodeEnd;
function isAfterContextNode(position, nodeIdMapCollection, contextNode, isBoundIncluded) {
    const maybeLeaf = parser_1.NodeIdMapUtils.maybeRightMostLeaf(nodeIdMapCollection, contextNode.id);
    if (maybeLeaf === undefined) {
        // We're assuming position is a valid range for the document.
        // Therefore if the context node didn't have a token (caused by EOF) we can make this assumption.
        if (contextNode.maybeTokenStart === undefined) {
            return false;
        }
        else {
            return isAfterTokenPosition(position, contextNode.maybeTokenStart.positionEnd, isBoundIncluded);
        }
    }
    const leaf = maybeLeaf;
    return isAfterAstNode(position, leaf, isBoundIncluded);
}
exports.isAfterContextNode = isAfterContextNode;
function isBeforeAstNode(position, astNode, isBoundIncluded) {
    return isBeforeTokenPosition(position, astNode.tokenRange.positionStart, isBoundIncluded);
}
exports.isBeforeAstNode = isBeforeAstNode;
function isInAstNode(position, astNode, isLowerBoundIncluded, isHigherBoundIncluded) {
    return (!isBeforeAstNode(position, astNode, isLowerBoundIncluded) &&
        !isAfterAstNode(position, astNode, isHigherBoundIncluded));
}
exports.isInAstNode = isInAstNode;
function isOnAstNodeStart(position, astNode) {
    return isOnTokenPosition(position, astNode.tokenRange.positionStart);
}
exports.isOnAstNodeStart = isOnAstNodeStart;
function isOnAstNodeEnd(position, astNode) {
    return isOnTokenPosition(position, astNode.tokenRange.positionEnd);
}
exports.isOnAstNodeEnd = isOnAstNodeEnd;
function isAfterAstNode(position, astNode, isBoundIncluded) {
    return isAfterTokenPosition(position, astNode.tokenRange.positionEnd, isBoundIncluded);
}
exports.isAfterAstNode = isAfterAstNode;
function isInToken(position, token, isLowerBoundIncluded, isHigherBoundIncluded) {
    return (!isBeforeTokenPosition(position, token.positionStart, isLowerBoundIncluded) &&
        !isAfterTokenPosition(position, token.positionEnd, isHigherBoundIncluded));
}
exports.isInToken = isInToken;
function isBeforeTokenPosition(position, tokenPosition, isBoundIncluded) {
    const positionLineNumber = position.lineNumber;
    if (positionLineNumber < tokenPosition.lineNumber) {
        return true;
    }
    else if (positionLineNumber > tokenPosition.lineNumber) {
        return false;
    }
    else {
        const upperBound = isBoundIncluded ? tokenPosition.lineCodeUnit : tokenPosition.lineCodeUnit + 1;
        return position.lineCodeUnit < upperBound;
    }
}
exports.isBeforeTokenPosition = isBeforeTokenPosition;
function isOnTokenPosition(position, tokenPosition) {
    return position.lineNumber === tokenPosition.lineNumber && position.lineCodeUnit === tokenPosition.lineCodeUnit;
}
exports.isOnTokenPosition = isOnTokenPosition;
function isAfterTokenPosition(position, tokenPosition, isBoundIncluded) {
    const positionLineNumber = position.lineNumber;
    if (positionLineNumber < tokenPosition.lineNumber) {
        return false;
    }
    else if (positionLineNumber > tokenPosition.lineNumber) {
        return true;
    }
    else {
        const upperBound = isBoundIncluded ? tokenPosition.lineCodeUnit : tokenPosition.lineCodeUnit - 1;
        return position.lineCodeUnit > upperBound;
    }
}
exports.isAfterTokenPosition = isAfterTokenPosition;
//# sourceMappingURL=positionUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/identifier.js":
/*!******************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/identifier.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = __webpack_require__(/*! .. */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const parser_1 = __webpack_require__(/*! ../../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const activeNode_1 = __webpack_require__(/*! ../activeNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js");
const position_1 = __webpack_require__(/*! ../position */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js");
function tryInspectIdentifier(settings, activeNode, nodeIdMapCollection, leafNodeIds) {
    const state = {
        nodeIndex: 0,
        result: {
            scope: new Map(),
        },
        activeNode,
        nodeIdMapCollection,
        leafNodeIds,
    };
    try {
        const ancestry = activeNode.ancestry;
        const numNodes = ancestry.length;
        for (let index = 0; index < numNodes; index += 1) {
            state.nodeIndex = index;
            const xorNode = ancestry[index];
            inspectNode(state, xorNode);
        }
        return {
            kind: "Ok" /* Ok */,
            value: Object.assign({}, state.result),
        };
    }
    catch (err) {
        return {
            kind: "Err" /* Err */,
            error: common_1.CommonError.ensureCommonError(settings.localizationTemplates, err),
        };
    }
}
exports.tryInspectIdentifier = tryInspectIdentifier;
function inspectNode(state, xorNode) {
    switch (xorNode.node.kind) {
        case "EachExpression" /* EachExpression */:
            inspectEachExpression(state, xorNode);
            break;
        case "FunctionExpression" /* FunctionExpression */:
            inspectFunctionExpression(state, xorNode);
            break;
        case "Identifier" /* Identifier */:
            inspectIdentifier(state, xorNode, true);
            break;
        case "IdentifierExpression" /* IdentifierExpression */:
            inspectIdentifierExpression(state, xorNode, true);
            break;
        case "IdentifierPairedExpression" /* IdentifierPairedExpression */:
            break;
        case "LetExpression" /* LetExpression */:
            inspectLetExpression(state, xorNode);
            break;
        case "RecordExpression" /* RecordExpression */:
        case "RecordLiteral" /* RecordLiteral */:
            inspectRecordExpressionOrRecordLiteral(state, xorNode);
            break;
        case "SectionMember" /* SectionMember */:
            inspectSectionMember(state, xorNode);
            break;
        default:
            break;
    }
}
// If you came from the TExpression in the EachExpression,
// then add '_' to the scope.
function inspectEachExpression(state, eachExpr) {
    const previous = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex);
    if (previous.node.maybeAttributeIndex !== 1) {
        return;
    }
    mightUpdateScope(state, "_", {
        kind: "Each" /* Each */,
        each: eachExpr,
    });
}
// If position is to the right of '=>',
// then add all parameter names to the scope.
function inspectFunctionExpression(state, fnExpr) {
    if (fnExpr.node.kind !== "FunctionExpression" /* FunctionExpression */) {
        throw expectedNodeKindError(fnExpr, "FunctionExpression" /* FunctionExpression */);
    }
    const previous = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex);
    if (previous.node.maybeAttributeIndex !== 3) {
        return;
    }
    // It's safe to expect an Ast.
    // All attributes would've had to been fully parsed before the expression body context was created,
    // and the previous check ensures that a TXorNode (either context or Ast) exists for the expression body.
    const parameters = parser_1.NodeIdMapUtils.expectAstChildByAttributeIndex(state.nodeIdMapCollection, fnExpr.node.id, 0, [
        "ParameterList" /* ParameterList */,
    ]);
    for (const parameterCsv of parameters.content.elements) {
        const parameterName = parameterCsv.node.name;
        const scopeKey = parameterName.literal;
        let maybeType;
        let isNullable;
        const maybeParameterType = parameterCsv.node.maybeParameterType;
        if (maybeParameterType !== undefined) {
            const asConstant = maybeParameterType.paired;
            switch (asConstant.kind) {
                case "NullablePrimitiveType" /* NullablePrimitiveType */:
                    maybeType = asConstant.paired.primitiveType.constantKind;
                    isNullable = true;
                    break;
                case "PrimitiveType" /* PrimitiveType */:
                    maybeType = asConstant.primitiveType.constantKind;
                    isNullable = false;
                    break;
                default:
                    throw common_1.isNever(asConstant);
            }
        }
        else {
            maybeType = undefined;
            isNullable = true;
        }
        mightUpdateScope(state, scopeKey, {
            kind: "Parameter" /* Parameter */,
            name: parameterName,
            isOptional: parameterCsv.node.maybeOptionalConstant === undefined,
            isNullable,
            maybeType,
        });
    }
}
function inspectIdentifier(state, identifier, isRoot) {
    // Ignore the case of a Context node as there are two possible states:
    // An empty context (no children), or an Ast.TNode instance.
    // Both have no identifier attached to it.
    //
    // Ignore the case of where the parent is an IdentifierExpression as the parent handle adding to the scope.
    if (identifier.kind !== "Ast" /* Ast */ || isParentOfNodeKind(state, "IdentifierExpression" /* IdentifierExpression */)) {
        return;
    }
    if (identifier.node.kind !== "Identifier" /* Identifier */) {
        throw expectedNodeKindError(identifier, "Identifier" /* Identifier */);
    }
    const identifierAstNode = identifier.node;
    // Don't add the identifier to scope if it's the root and position is before the identifier starts.
    // 'a +| b'
    // '|foo'
    const position = state.activeNode.position;
    if (isRoot && position_1.PositionUtils.isBeforeAstNode(position, identifierAstNode, true)) {
        return;
    }
    // Don't add the identifier if you're coming from inside a ParameterList
    // '(foo|, bar) => 1'
    const maybeNext = activeNode_1.ActiveNodeUtils.maybeNextXorNode(state.activeNode, state.nodeIndex);
    if (maybeNext && maybeNext.node.kind === "Parameter" /* Parameter */) {
        return;
    }
    mightUpdateScope(state, identifierAstNode.literal, {
        kind: "Undefined" /* Undefined */,
        xorNode: identifier,
    });
}
function inspectIdentifierExpression(state, identifierExpr, isLeaf) {
    // Don't add the identifier to scope if it's the leaf,
    // and if the position is before the start of the identifier.
    // 'a +| b'
    // '|foo'
    if (isLeaf && position_1.PositionUtils.isBeforeXorNode(state.activeNode.position, identifierExpr, false)) {
        return;
    }
    let key;
    switch (identifierExpr.kind) {
        case "Ast" /* Ast */: {
            if (identifierExpr.node.kind !== "IdentifierExpression" /* IdentifierExpression */) {
                throw expectedNodeKindError(identifierExpr, "IdentifierExpression" /* IdentifierExpression */);
            }
            const identifierExprAstNode = identifierExpr.node;
            const identifier = identifierExprAstNode.identifier;
            const maybeInclusiveConstant = identifierExprAstNode.maybeInclusiveConstant;
            key =
                maybeInclusiveConstant !== undefined
                    ? maybeInclusiveConstant.constantKind + identifier.literal
                    : identifier.literal;
            break;
        }
        case "Context" /* Context */: {
            key = "";
            const nodeIdMapCollection = state.nodeIdMapCollection;
            // Add the optional inclusive constant `@` if it was parsed.
            const maybeInclusiveConstant = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, identifierExpr.node.id, 0, ["Constant" /* Constant */]);
            if (maybeInclusiveConstant !== undefined) {
                const inclusiveConstant = maybeInclusiveConstant.node;
                // Adds the '@' prefix.
                key = inclusiveConstant.constantKind;
            }
            const maybeIdentifier = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, identifierExpr.node.id, 1, ["Identifier" /* Identifier */]);
            if (maybeIdentifier !== undefined) {
                const identifier = maybeIdentifier.node;
                key += identifier.literal;
            }
            break;
        }
        default:
            throw common_1.isNever(identifierExpr);
    }
    if (key.length) {
        mightUpdateScope(state, key, {
            kind: "Undefined" /* Undefined */,
            xorNode: identifierExpr,
        });
    }
}
// If position is to the right of an equals sign,
// then add all keys to the scope EXCEPT for the key that the position is under.
function inspectLetExpression(state, letExpr) {
    const maybePreviousAttributeIndex = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex).node.maybeAttributeIndex;
    if (maybePreviousAttributeIndex !== 3 && !__1.InspectionUtils.isInKeyValuePairAssignment(state)) {
        return;
    }
    const nodeIdMapCollection = state.nodeIdMapCollection;
    let csvArray;
    let maybeAncestorKeyValuePair;
    // If ancestor is an expression
    if (maybePreviousAttributeIndex === 3) {
        csvArray = parser_1.NodeIdMapUtils.expectXorChildByAttributeIndex(nodeIdMapCollection, letExpr.node.id, 1, [
            "ArrayWrapper" /* ArrayWrapper */,
        ]);
        maybeAncestorKeyValuePair = undefined;
    }
    else {
        csvArray = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex, 1, [
            "ArrayWrapper" /* ArrayWrapper */,
        ]);
        maybeAncestorKeyValuePair = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex, 3, [
            "IdentifierPairedExpression" /* IdentifierPairedExpression */,
        ]);
    }
    for (const keyValuePair of xorNodesOnCsvFromCsvArray(nodeIdMapCollection, csvArray)) {
        if (maybeAncestorKeyValuePair && maybeAncestorKeyValuePair.node.id === keyValuePair.node.id) {
            continue;
        }
        const keyValuePairId = keyValuePair.node.id;
        const maybeKey = parser_1.NodeIdMapUtils.maybeAstChildByAttributeIndex(nodeIdMapCollection, keyValuePairId, 0, ["Identifier" /* Identifier */]);
        if (maybeKey === undefined) {
            continue;
        }
        const key = maybeKey;
        const maybeValue = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, keyValuePairId, 2, undefined);
        mightUpdateScope(state, key.literal, {
            kind: "KeyValuePair" /* KeyValuePair */,
            key,
            maybeValue,
        });
    }
}
// If position is to the right of an equals sign,
// then add all keys to scope EXCEPT for the one the that position is under.
function inspectRecordExpressionOrRecordLiteral(state, _) {
    const nodeIdMapCollection = state.nodeIdMapCollection;
    // Only add to scope if you're in the right hand of an assignment.
    if (!__1.InspectionUtils.isInKeyValuePairAssignment(state)) {
        return;
    }
    const csvArray = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex, 1, [
        "ArrayWrapper" /* ArrayWrapper */,
    ]);
    const keyValuePair = activeNode_1.ActiveNodeUtils.expectPreviousXorNode(state.activeNode, state.nodeIndex, 3, [
        "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */,
        "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */,
    ]);
    for (const csv of xorNodesOnCsvFromCsvArray(nodeIdMapCollection, csvArray)) {
        const nodeId = csv.node.id;
        // If position is under this node then don't add it's key to the scope.
        if (csv.node.id === keyValuePair.node.id) {
            continue;
        }
        const maybeKey = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, nodeId, 0, ["GeneralizedIdentifier" /* GeneralizedIdentifier */]);
        if (maybeKey === undefined) {
            continue;
        }
        const key = maybeKey;
        const maybeValue = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, nodeId, 2, undefined);
        if (key.kind === "Ast" /* Ast */) {
            const keyAstNode = key.node;
            mightUpdateScope(state, keyAstNode.literal, {
                kind: "KeyValuePair" /* KeyValuePair */,
                key: keyAstNode,
                maybeValue,
            });
        }
    }
}
function inspectSectionMember(state, sectionMember) {
    if (!__1.InspectionUtils.isInKeyValuePairAssignment(state)) {
        return;
    }
    const nodeIdMapCollection = state.nodeIdMapCollection;
    const sectionMemberArray = activeNode_1.ActiveNodeUtils.expectNextXorNode(state.activeNode, state.nodeIndex, 1, [
        "ArrayWrapper" /* ArrayWrapper */,
    ]);
    const sectionMembers = parser_1.NodeIdMapUtils.expectXorChildren(nodeIdMapCollection, sectionMemberArray.node.id);
    for (const iterSectionMember of sectionMembers) {
        // Ignore if it's the current SectionMember.
        if (iterSectionMember.node.id === sectionMember.node.id) {
            continue;
        }
        const maybeKeyValuePair = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, iterSectionMember.node.id, 2, ["IdentifierPairedExpression" /* IdentifierPairedExpression */]);
        if (maybeKeyValuePair === undefined) {
            continue;
        }
        const keyValuePair = maybeKeyValuePair;
        // Add name to scope.
        const maybeName = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, keyValuePair.node.id, 0, ["Identifier" /* Identifier */]);
        if (maybeName === undefined || maybeName.kind === "Context" /* Context */) {
            continue;
        }
        const name = maybeName.node;
        const maybeValue = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, keyValuePair.node.id, 2, undefined);
        mightUpdateScope(state, name.literal, {
            kind: "SectionMember" /* SectionMember */,
            key: name,
            maybeValue,
        });
    }
}
function expectedNodeKindError(xorNode, expected) {
    const details = {
        xorNodeId: xorNode.node.id,
        expectedNodeKind: expected,
        actualNodeKind: xorNode.node.kind,
    };
    return new common_1.CommonError.InvariantError(`expected xorNode to be of kind ${expected}`, details);
}
function isParentOfNodeKind(state, parentNodeKind) {
    const maybeParent = activeNode_1.ActiveNodeUtils.maybeNextXorNode(state.activeNode, state.nodeIndex);
    return maybeParent !== undefined ? maybeParent.node.kind === parentNodeKind : false;
}
function mightUpdateScope(state, key, scopeItem) {
    const unsafeScope = state.result.scope;
    const maybeScopeItem = unsafeScope.get(key);
    const isUpdateNeeded = maybeScopeItem === undefined ||
        (maybeScopeItem.kind === "Undefined" /* Undefined */ && scopeItem.kind !== "Undefined" /* Undefined */);
    if (isUpdateNeeded) {
        unsafeScope.set(key, scopeItem);
    }
}
// Takes an XorNode TCsvArray and returns collection.elements.map(csv => csv.node),
// plus extra boilerplate to handle TXorNode.
function xorNodesOnCsvFromCsvArray(nodeIdMapCollection, csvArray) {
    const csvNodes = parser_1.NodeIdMapUtils.expectXorChildren(nodeIdMapCollection, csvArray.node.id);
    const result = [];
    for (const csv of csvNodes) {
        const maybeCsvNode = parser_1.NodeIdMapUtils.maybeXorChildByAttributeIndex(nodeIdMapCollection, csv.node.id, 0, undefined);
        if (maybeCsvNode === undefined) {
            break;
        }
        const csvNode = maybeCsvNode;
        result.push(csvNode);
    }
    return result;
}
//# sourceMappingURL=identifier.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/index.js":
/*!*************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./identifier */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/identifier.js"));
__export(__webpack_require__(/*! ./invokeExpression */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/invokeExpression.js"));
__export(__webpack_require__(/*! ./scope */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/scope.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/invokeExpression.js":
/*!************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/invokeExpression.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const parser_1 = __webpack_require__(/*! ../../parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const activeNode_1 = __webpack_require__(/*! ../activeNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/activeNode/index.js");
const position_1 = __webpack_require__(/*! ../position */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/position/index.js");
function inspectInvokeExpression(activeNode, nodeIdMapCollection) {
    const ancestors = activeNode.ancestry;
    const numAncestors = activeNode.ancestry.length;
    const position = activeNode.position;
    for (let index = 0; index < numAncestors; index += 1) {
        const xorNode = ancestors[index];
        if (!isInvokeExpressionContent(position, xorNode)) {
            continue;
        }
        return {
            maybeInvokeExpression: {
                xorNode: xorNode,
                maybeName: maybeInvokeExpressionName(nodeIdMapCollection, xorNode.node.id),
                maybeArguments: inspectInvokeExpressionArguments(nodeIdMapCollection, activeNode, index),
            },
        };
    }
    return {
        maybeInvokeExpression: undefined,
    };
}
exports.inspectInvokeExpression = inspectInvokeExpression;
function isInvokeExpressionContent(position, xorNode) {
    if (xorNode.node.kind !== "InvokeExpression" /* InvokeExpression */) {
        return false;
    }
    // Check if position is in the wrapped contents (InvokeExpression arguments).
    if (xorNode.kind === "Ast" /* Ast */) {
        const invokeExprAstNode = xorNode.node;
        if (!position_1.PositionUtils.isInAstNode(position, invokeExprAstNode.content, true, true)) {
            return false;
        }
    }
    return true;
}
function maybeInvokeExpressionName(nodeIdMapCollection, nodeId) {
    const invokeExprXorNode = parser_1.NodeIdMapUtils.expectXorNode(nodeIdMapCollection, nodeId);
    if (invokeExprXorNode.node.kind !== "InvokeExpression" /* InvokeExpression */) {
        const details = { invokeExprXorNode };
        throw new common_1.CommonError.InvariantError(`expected invokeExprXorNode to have a Ast.NodeKind of ${"InvokeExpression" /* InvokeExpression */}`, details);
    }
    // The only place for an identifier in a RecursivePrimaryExpression is as the head, therefore an InvokeExpression
    // only has a name if the InvokeExpression is the 0th element in the RecursivePrimaryExpressionArray.
    let maybeName;
    if (invokeExprXorNode.node.maybeAttributeIndex === 0) {
        // Grab the RecursivePrimaryExpression's head if it's an IdentifierExpression
        const recursiveArrayXorNode = parser_1.NodeIdMapUtils.expectParentXorNode(nodeIdMapCollection, invokeExprXorNode.node.id);
        const recursiveExprXorNode = parser_1.NodeIdMapUtils.expectParentXorNode(nodeIdMapCollection, recursiveArrayXorNode.node.id);
        const headXorNode = parser_1.NodeIdMapUtils.expectXorChildByAttributeIndex(nodeIdMapCollection, recursiveExprXorNode.node.id, 0, undefined);
        if (headXorNode.node.kind === "IdentifierExpression" /* IdentifierExpression */) {
            if (headXorNode.kind !== "Ast" /* Ast */) {
                const details = {
                    identifierExpressionNodeId: headXorNode.node.id,
                    invokeExpressionNodeId: invokeExprXorNode.node.id,
                };
                throw new common_1.CommonError.InvariantError(`the younger IdentifierExpression sibling should've finished parsing before the InvokeExpression node was reached`, details);
            }
            const identifierExpression = headXorNode.node;
            maybeName =
                identifierExpression.maybeInclusiveConstant === undefined
                    ? identifierExpression.identifier.literal
                    : identifierExpression.maybeInclusiveConstant.constantKind +
                        identifierExpression.identifier.literal;
        }
    }
    return maybeName;
}
function inspectInvokeExpressionArguments(nodeIdMapCollection, activeNode, nodeIndex) {
    // Grab arguments if they exist, else return early.
    const maybeCsvArray = activeNode_1.ActiveNodeUtils.maybePreviousXorNode(activeNode, nodeIndex, 1, [
        "ArrayWrapper" /* ArrayWrapper */,
    ]);
    if (maybeCsvArray === undefined) {
        return undefined;
    }
    // const nodeIdMapCollection: NodeIdMap.Collection = state.nodeIdMapCollection;
    // const position: Position = state.activeNode.position;
    const csvArray = maybeCsvArray;
    const csvNodes = parser_1.NodeIdMapUtils.expectXorChildren(nodeIdMapCollection, csvArray.node.id);
    const numArguments = csvNodes.length;
    const maybeAncestorCsv = activeNode_1.ActiveNodeUtils.maybePreviousXorNode(activeNode, nodeIndex, 2, [
        "Csv" /* Csv */,
    ]);
    const maybePositionArgumentIndex = maybeAncestorCsv !== undefined ? maybeAncestorCsv.node.maybeAttributeIndex : undefined;
    return {
        numArguments,
        positionArgumentIndex: maybePositionArgumentIndex !== undefined ? maybePositionArgumentIndex : 0,
    };
}
//# sourceMappingURL=invokeExpression.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/scope.js":
/*!*************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/scope.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const identifier_1 = __webpack_require__(/*! ./identifier */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/identifier.js");
const invokeExpression_1 = __webpack_require__(/*! ./invokeExpression */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/inspection/scope/invokeExpression.js");
function tryInspectScope(settings, maybeActiveNode, nodeIdMapCollection, leafNodeIds) {
    if (maybeActiveNode === undefined) {
        return {
            kind: "Ok" /* Ok */,
            value: DefaultIdentifierInspection,
        };
    }
    const activeNode = maybeActiveNode;
    try {
        const triedInspectIdentifier = identifier_1.tryInspectIdentifier(settings, maybeActiveNode, nodeIdMapCollection, leafNodeIds);
        if (common_1.ResultUtils.isErr(triedInspectIdentifier)) {
            return triedInspectIdentifier;
        }
        const maybeInspectedInvokeExpression = invokeExpression_1.inspectInvokeExpression(activeNode, nodeIdMapCollection);
        return common_1.ResultUtils.okFactory(Object.assign(Object.assign({}, triedInspectIdentifier.value), maybeInspectedInvokeExpression));
    }
    catch (err) {
        return {
            kind: "Err" /* Err */,
            error: common_1.CommonError.ensureCommonError(settings.localizationTemplates, err),
        };
    }
}
exports.tryInspectScope = tryInspectScope;
const DefaultIdentifierInspection = {
    scope: new Map(),
    maybeInvokeExpression: undefined,
};
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/comment.js":
/*!****************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/comment.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/error.js":
/*!**************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/error.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const localization_1 = __webpack_require__(/*! ../localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js");
class LexError extends Error {
    constructor(innerError) {
        super(innerError.message);
        this.innerError = innerError;
    }
}
exports.LexError = LexError;
class BadLineNumberError extends Error {
    constructor(templates, kind, lineNumber, numLines) {
        super(localization_1.Localization.error_lex_badLineNumber(templates, kind));
        this.kind = kind;
        this.lineNumber = lineNumber;
        this.numLines = numLines;
    }
}
exports.BadLineNumberError = BadLineNumberError;
class BadRangeError extends Error {
    constructor(templates, range, kind) {
        super(localization_1.Localization.error_lex_badRange(templates, kind));
        this.range = range;
        this.kind = kind;
    }
}
exports.BadRangeError = BadRangeError;
class BadStateError extends Error {
    constructor(templates, innerError) {
        super(localization_1.Localization.error_lex_badState(templates));
        this.innerError = innerError;
    }
}
exports.BadStateError = BadStateError;
class ErrorLineMapError extends Error {
    constructor(templates, errorLineMap) {
        super(localization_1.Localization.error_lex_lineMap(templates, errorLineMap));
        this.errorLineMap = errorLineMap;
    }
}
exports.ErrorLineMapError = ErrorLineMapError;
class EndOfStreamError extends Error {
    constructor(templates) {
        super(localization_1.Localization.error_lex_endOfStream(templates));
    }
}
exports.EndOfStreamError = EndOfStreamError;
class ExpectedError extends Error {
    constructor(templates, graphemePosition, kind) {
        super(localization_1.Localization.error_lex_expectedKind(templates, kind));
        this.graphemePosition = graphemePosition;
        this.kind = kind;
    }
}
exports.ExpectedError = ExpectedError;
class UnexpectedEofError extends Error {
    constructor(templates, graphemePosition) {
        super(localization_1.Localization.error_lex_endOfStreamPartwayRead(templates));
        this.graphemePosition = graphemePosition;
    }
}
exports.UnexpectedEofError = UnexpectedEofError;
class UnexpectedReadError extends Error {
    constructor(templates, graphemePosition) {
        super(localization_1.Localization.error_lex_unexpectedRead(templates));
        this.graphemePosition = graphemePosition;
    }
}
exports.UnexpectedReadError = UnexpectedReadError;
class UnterminatedMultilineTokenError extends Error {
    constructor(templates, graphemePosition, kind) {
        super(localization_1.Localization.error_lex_unterminatedMultilineToken(templates, kind));
        this.graphemePosition = graphemePosition;
        this.kind = kind;
    }
}
exports.UnterminatedMultilineTokenError = UnterminatedMultilineTokenError;
function isTLexError(x) {
    return x instanceof LexError || x instanceof common_1.CommonError.CommonError;
}
exports.isTLexError = isTLexError;
function isTInnerLexError(x) {
    return (x instanceof BadLineNumberError ||
        x instanceof BadRangeError ||
        x instanceof BadStateError ||
        x instanceof EndOfStreamError ||
        x instanceof ErrorLineMapError ||
        x instanceof ExpectedError ||
        x instanceof UnexpectedEofError ||
        x instanceof UnexpectedReadError ||
        x instanceof UnterminatedMultilineTokenError);
}
exports.isTInnerLexError = isTInnerLexError;
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js":
/*!**************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const LexError = __webpack_require__(/*! ./error */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/error.js");
exports.LexError = LexError;
const Lexer = __webpack_require__(/*! ./lexer */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexer.js");
exports.Lexer = Lexer;
__export(__webpack_require__(/*! ./comment */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/comment.js"));
__export(__webpack_require__(/*! ./keywords */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/keywords.js"));
__export(__webpack_require__(/*! ./lexerSnapshot */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexerSnapshot.js"));
__export(__webpack_require__(/*! ./token */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/token.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/keywords.js":
/*!*****************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/keywords.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keywords = [
    "and" /* And */,
    "as" /* As */,
    "each" /* Each */,
    "else" /* Else */,
    "error" /* Error */,
    "false" /* False */,
    "if" /* If */,
    "in" /* In */,
    "is" /* Is */,
    "let" /* Let */,
    "meta" /* Meta */,
    "not" /* Not */,
    "or" /* Or */,
    "otherwise" /* Otherwise */,
    "section" /* Section */,
    "shared" /* Shared */,
    "then" /* Then */,
    "true" /* True */,
    "try" /* Try */,
    "type" /* Type */,
    "#binary" /* HashBinary */,
    "#date" /* HashDate */,
    "#datetime" /* HashDateTime */,
    "#datetimezone" /* HashDateTimeZone */,
    "#duration" /* HashDuration */,
    "#infinity" /* HashInfinity */,
    "#nan" /* HashNan */,
    "#sections" /* HashSections */,
    "#shared" /* HashShared */,
    "#table" /* HashTable */,
    "#time" /* HashTime */,
];
exports.TExpressionKeywords = [
    "each" /* Each */,
    "error" /* Error */,
    "false" /* False */,
    "#binary" /* HashBinary */,
    "#date" /* HashDate */,
    "#datetime" /* HashDateTime */,
    "#datetimezone" /* HashDateTimeZone */,
    "#duration" /* HashDuration */,
    "#infinity" /* HashInfinity */,
    "#nan" /* HashNan */,
    "#table" /* HashTable */,
    "#time" /* HashTime */,
    "if" /* If */,
    "let" /* Let */,
    "not" /* Not */,
    "true" /* True */,
    "try" /* Try */,
    "type" /* Type */,
];
//# sourceMappingURL=keywords.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexer.js":
/*!**************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexer.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function stateFrom(settings, text) {
    const splitLines = splitOnLineTerminators(text);
    const tokenizedLines = tokenizedLinesFrom(settings.localizationTemplates, splitLines, "Default" /* Default */);
    return {
        lines: tokenizedLines,
        localizationTemplates: settings.localizationTemplates,
    };
}
exports.stateFrom = stateFrom;
function appendLine(state, text, lineTerminator) {
    const lines = state.lines;
    const numLines = lines.length;
    const maybeLatestLine = lines[numLines - 1];
    const lineModeStart = maybeLatestLine ? maybeLatestLine.lineModeEnd : "Default" /* Default */;
    const untokenizedLine = lineFrom(text, lineTerminator, lineModeStart);
    const tokenizedLine = tokenize(state.localizationTemplates, untokenizedLine, numLines);
    return Object.assign(Object.assign({}, state), { lines: state.lines.concat(tokenizedLine) });
}
exports.appendLine = appendLine;
function tryUpdateLine(state, lineNumber, text) {
    const lines = state.lines;
    const maybeError = maybeBadLineNumberError(state, lineNumber);
    if (maybeError) {
        return common_1.ResultUtils.errFactory(new _1.LexError.LexError(maybeError));
    }
    const line = lines[lineNumber];
    const range = rangeFrom(line, lineNumber);
    return tryUpdateRange(state, range, text);
}
exports.tryUpdateLine = tryUpdateLine;
function tryUpdateRange(state, range, text) {
    const maybeError = maybeBadRangeError(state, range);
    if (maybeError) {
        return common_1.ResultUtils.errFactory(new _1.LexError.LexError(maybeError));
    }
    const splitLines = splitOnLineTerminators(text);
    const rangeStart = range.start;
    const lineStart = state.lines[rangeStart.lineNumber];
    const textPrefix = lineStart.text.substring(0, rangeStart.lineCodeUnit);
    splitLines[0].text = textPrefix + splitLines[0].text;
    const rangeEnd = range.end;
    const lineEnd = state.lines[rangeEnd.lineNumber];
    const textSuffix = lineEnd.text.substr(rangeEnd.lineCodeUnit);
    const lastSplitLine = splitLines[splitLines.length - 1];
    lastSplitLine.text = lastSplitLine.text + textSuffix;
    // make sure we have a line terminator
    lastSplitLine.lineTerminator = lineEnd.lineTerminator;
    const maybePreviousLine = state.lines[rangeStart.lineNumber - 1];
    const previousLineModeEnd = maybePreviousLine !== undefined ? maybePreviousLine.lineModeEnd : "Default" /* Default */;
    const newLines = tokenizedLinesFrom(state.localizationTemplates, splitLines, previousLineModeEnd);
    const lines = [
        ...state.lines.slice(0, rangeStart.lineNumber),
        ...newLines,
        ...retokenizeLines(state, rangeEnd.lineNumber + 1, newLines[newLines.length - 1].lineModeEnd),
    ];
    return common_1.ResultUtils.okFactory({
        lines,
        localizationTemplates: state.localizationTemplates,
    });
}
exports.tryUpdateRange = tryUpdateRange;
function tryDeleteLine(state, lineNumber) {
    const lines = state.lines;
    const maybeError = maybeBadLineNumberError(state, lineNumber);
    if (maybeError) {
        common_1.ResultUtils.errFactory(new _1.LexError.LexError(maybeError));
    }
    return common_1.ResultUtils.okFactory(Object.assign(Object.assign({}, state), { lines: [...lines.slice(0, lineNumber), ...lines.slice(lineNumber + 1)] }));
}
exports.tryDeleteLine = tryDeleteLine;
// deep state comparison
function equalStates(leftState, rightState) {
    return equalLines(leftState.lines, rightState.lines);
}
exports.equalStates = equalStates;
// deep line comparison
// partial equality as ILine.text is ignored
function equalLines(leftLines, rightLines) {
    if (leftLines.length !== rightLines.length) {
        return false;
    }
    const numLines = leftLines.length;
    for (let lineIndex = 0; lineIndex < numLines; lineIndex += 1) {
        const left = leftLines[lineIndex];
        const right = rightLines[lineIndex];
        const leftTokens = left.tokens;
        const rightTokens = right.tokens;
        const isEqualQuickCheck = left.kind === right.kind &&
            left.lineTerminator === right.lineTerminator &&
            left.lineModeStart === right.lineModeStart &&
            left.lineModeEnd === right.lineModeEnd &&
            leftTokens.length === rightTokens.length;
        if (!isEqualQuickCheck) {
            return false;
        }
        // isEqualQuickCheck ensures tokens.length is the same
        const numTokens = leftTokens.length;
        for (let tokenIndex = 0; tokenIndex < numTokens; tokenIndex += 1) {
            if (!equalTokens(leftTokens[tokenIndex], rightTokens[tokenIndex])) {
                return false;
            }
        }
    }
    return true;
}
exports.equalLines = equalLines;
// deep token comparison
function equalTokens(leftToken, rightToken) {
    return (leftToken.kind === rightToken.kind &&
        leftToken.data === rightToken.data &&
        leftToken.positionStart === rightToken.positionStart &&
        leftToken.positionEnd === rightToken.positionEnd);
}
exports.equalTokens = equalTokens;
function isErrorState(state) {
    const linesWithErrors = state.lines.filter(isErrorLine);
    return linesWithErrors.length !== 0;
}
exports.isErrorState = isErrorState;
function isErrorLine(line) {
    switch (line.kind) {
        case "Error" /* Error */:
        case "TouchedWithError" /* TouchedWithError */:
            return true;
        case "Touched" /* Touched */:
        case "Untouched" /* Untouched */:
            return false;
        default:
            throw common_1.isNever(line);
    }
}
exports.isErrorLine = isErrorLine;
function maybeErrorLineMap(state) {
    const errorLines = new Map();
    const lines = state.lines;
    const numLines = lines.length;
    let errorsExist = false;
    for (let index = 0; index < numLines; index += 1) {
        const line = lines[index];
        if (isErrorLine(line)) {
            errorLines.set(index, line);
            errorsExist = true;
        }
    }
    return errorsExist ? errorLines : undefined;
}
exports.maybeErrorLineMap = maybeErrorLineMap;
// Takes a string and splits it on all valid Power Query terminators.
// The split lines retain what newline was used to create the split.
function splitOnLineTerminators(startingText) {
    let lines = startingText.split("\r\n").map((lineText) => {
        return {
            text: lineText,
            lineTerminator: "\r\n",
        };
    });
    const lineTerminators = [
        "\n",
        "\u2028",
        "\u2029",
    ];
    let index = 0;
    while (index < lines.length) {
        let indexWasExpanded = false;
        for (const lineTerminator of lineTerminators) {
            const splitLine = lines[index];
            const text = splitLine.text;
            if (text.indexOf(lineTerminator) !== -1) {
                indexWasExpanded = true;
                const split = text.split(lineTerminator).map((lineText) => {
                    return {
                        text: lineText,
                        lineTerminator,
                    };
                });
                split[split.length - 1].lineTerminator = splitLine.lineTerminator;
                lines = [...lines.slice(0, index), ...split, ...lines.slice(index + 1)];
            }
        }
        if (!indexWasExpanded) {
            index += 1;
        }
    }
    lines[lines.length - 1].lineTerminator = "";
    return lines;
}
function lineFrom(text, lineTerminator, lineModeStart) {
    return {
        kind: "Untouched" /* Untouched */,
        text,
        lineTerminator,
        lineModeStart,
        lineModeEnd: "Default" /* Default */,
        tokens: [],
    };
}
function graphemePositionFrom(text, lineNumber, lineCodeUnit) {
    return common_1.StringUtils.graphemePositionFrom(text, lineCodeUnit, lineNumber, undefined);
}
function rangeFrom(line, lineNumber) {
    return {
        start: {
            lineNumber,
            lineCodeUnit: 0,
        },
        end: {
            lineNumber,
            lineCodeUnit: line.text.length,
        },
    };
}
function tokenizedLinesFrom(localizationTemplates, splitLines, previousLineModeEnd) {
    const numLines = splitLines.length;
    const tokenizedLines = [];
    for (let lineNumber = 0; lineNumber < numLines; lineNumber += 1) {
        const splitLine = splitLines[lineNumber];
        const untokenizedLine = lineFrom(splitLine.text, splitLine.lineTerminator, previousLineModeEnd);
        const tokenizedLine = tokenize(localizationTemplates, untokenizedLine, lineNumber);
        tokenizedLines.push(tokenizedLine);
        previousLineModeEnd = tokenizedLine.lineModeEnd;
    }
    return tokenizedLines;
}
// If an earlier line changed its lineModeEnd, eg. inserting a `"` to start a string literal,
// then the proceeding lines would need to be retokenized.
// Stops retokenizing when previous.lineModeEnd !== current.lineModeStart.
// Returns lines in the range [lineNumber, lines.length -1]
function retokenizeLines(state, lineNumber, previousLineModeEnd) {
    const lines = state.lines;
    const localizationTemplates = state.localizationTemplates;
    if (lines[lineNumber] === undefined) {
        return [];
    }
    const retokenizedLines = [];
    if (previousLineModeEnd !== lines[lineNumber].lineModeStart) {
        const offsetLineNumber = lineNumber;
        let maybeCurrentLine = lines[lineNumber];
        while (maybeCurrentLine) {
            const line = maybeCurrentLine;
            if (previousLineModeEnd !== line.lineModeStart) {
                const untokenizedLine = lineFrom(line.text, line.lineTerminator, previousLineModeEnd);
                const retokenizedLine = tokenize(localizationTemplates, untokenizedLine, offsetLineNumber);
                retokenizedLines.push(retokenizedLine);
                previousLineModeEnd = retokenizedLine.lineModeEnd;
                lineNumber += 1;
                maybeCurrentLine = lines[lineNumber];
            }
            else {
                return [...retokenizedLines, ...lines.slice(lineNumber + 1)];
            }
        }
        return retokenizedLines;
    }
    else {
        return lines.slice(lineNumber);
    }
}
// The main function of the lexer's tokenizer.
function tokenize(localizationTemplates, line, lineNumber) {
    switch (line.kind) {
        // Cannot tokenize something that ended with an error,
        // nothing has changed since the last tokenize.
        // Update the line's text before trying again.
        case "Error" /* Error */:
            return line;
        case "Touched" /* Touched */:
            // The line was already fully lexed once.
            // Without any text changes it should throw eof to help diagnose
            // why it's trying to retokenize.
            return Object.assign(Object.assign({}, line), { kind: "Error" /* Error */, error: new _1.LexError.LexError(new _1.LexError.EndOfStreamError(localizationTemplates)) });
        // Cannot tokenize something that previously ended with an error.
        // Update the line's text before trying again.
        case "TouchedWithError" /* TouchedWithError */:
            return {
                kind: "Error" /* Error */,
                text: line.text,
                lineTerminator: line.lineTerminator,
                lineModeStart: line.lineModeStart,
                lineModeEnd: line.lineModeEnd,
                tokens: line.tokens,
                error: new _1.LexError.LexError(new _1.LexError.BadStateError(localizationTemplates, line.error)),
            };
        case "Untouched" /* Untouched */:
            break;
        default:
            throw common_1.isNever(line);
    }
    const untouchedLine = line;
    const text = untouchedLine.text;
    const textLength = text.length;
    // If there's nothing to tokenize set lineModeEnd to lineModeStart.
    if (textLength === 0) {
        return {
            kind: "Touched" /* Touched */,
            text: line.text,
            lineTerminator: line.lineTerminator,
            lineModeStart: line.lineModeStart,
            lineModeEnd: line.lineModeStart,
            tokens: [],
        };
    }
    let lineMode = line.lineModeStart;
    let currentPosition = 0;
    if (lineMode === "Default" /* Default */) {
        currentPosition = drainWhitespace(text, currentPosition);
    }
    const newTokens = [];
    let continueLexing = currentPosition !== text.length;
    let maybeError;
    // While neither eof nor having encountered an error:
    //  * Lex according to lineModeStart, starting from currentPosition.
    //  * Update currentPosition and lineMode.
    //  * Drain whitespace.
    while (continueLexing) {
        try {
            let readOutcome;
            switch (lineMode) {
                case "Comment" /* Comment */:
                    readOutcome = tokenizeMultilineCommentContentOrEnd(line, currentPosition);
                    break;
                case "Default" /* Default */:
                    readOutcome = tokenizeDefault(localizationTemplates, line, lineNumber, currentPosition);
                    break;
                case "QuotedIdentifier" /* QuotedIdentifier */:
                    readOutcome = tokenizeQuotedIdentifierContentOrEnd(line, currentPosition);
                    break;
                case "String" /* String */:
                    readOutcome = tokenizeStringLiteralContentOrEnd(line, currentPosition);
                    break;
                default:
                    throw common_1.isNever(lineMode);
            }
            lineMode = readOutcome.lineMode;
            const token = readOutcome.token;
            newTokens.push(token);
            if (lineMode === "Default" /* Default */) {
                currentPosition = drainWhitespace(text, token.positionEnd);
            }
            else {
                currentPosition = token.positionEnd;
            }
            if (currentPosition === textLength) {
                continueLexing = false;
            }
        }
        catch (e) {
            let error;
            if (_1.LexError.isTInnerLexError(e)) {
                error = new _1.LexError.LexError(e);
            }
            else {
                error = common_1.CommonError.ensureCommonError(localizationTemplates, e);
            }
            continueLexing = false;
            maybeError = error;
        }
    }
    let partialTokenizeResult;
    if (maybeError) {
        if (newTokens.length) {
            partialTokenizeResult = common_1.PartialResultUtils.mixedFactory({
                tokens: newTokens,
                lineModeEnd: lineMode,
            }, maybeError);
        }
        else {
            partialTokenizeResult = common_1.PartialResultUtils.errFactory(maybeError);
        }
    }
    else {
        partialTokenizeResult = common_1.PartialResultUtils.okFactory({
            tokens: newTokens,
            lineModeEnd: lineMode,
        });
    }
    return updateLineState(line, partialTokenizeResult);
}
// Takes the return from a tokenizeX function to updates the TLine's state.
function updateLineState(line, tokenizePartialResult) {
    switch (tokenizePartialResult.kind) {
        case "Ok" /* Ok */: {
            const tokenizeChanges = tokenizePartialResult.value;
            const newTokens = line.tokens.concat(tokenizeChanges.tokens);
            return {
                kind: "Touched" /* Touched */,
                text: line.text,
                lineTerminator: line.lineTerminator,
                lineModeStart: line.lineModeStart,
                lineModeEnd: tokenizeChanges.lineModeEnd,
                tokens: newTokens,
            };
        }
        case "Mixed" /* Mixed */: {
            const tokenizeChanges = tokenizePartialResult.value;
            const newTokens = line.tokens.concat(tokenizeChanges.tokens);
            return {
                kind: "TouchedWithError" /* TouchedWithError */,
                text: line.text,
                lineTerminator: line.lineTerminator,
                lineModeStart: line.lineModeStart,
                lineModeEnd: tokenizeChanges.lineModeEnd,
                tokens: newTokens,
                error: tokenizePartialResult.error,
            };
        }
        case "Err" /* Err */:
            return {
                kind: "Error" /* Error */,
                text: line.text,
                lineModeStart: line.lineModeStart,
                lineTerminator: line.lineTerminator,
                lineModeEnd: line.lineModeEnd,
                tokens: line.tokens,
                error: tokenizePartialResult.error,
            };
        default:
            throw common_1.isNever(tokenizePartialResult);
    }
}
// read either "*/" or eof
function tokenizeMultilineCommentContentOrEnd(line, positionStart) {
    const text = line.text;
    const indexOfCloseComment = text.indexOf("*/", positionStart);
    if (indexOfCloseComment === -1) {
        return {
            token: readRestOfLine("MultilineCommentContent" /* MultilineCommentContent */, text, positionStart),
            lineMode: "Comment" /* Comment */,
        };
    }
    else {
        const positionEnd = indexOfCloseComment + 2;
        return {
            token: readTokenFrom("MultilineCommentEnd" /* MultilineCommentEnd */, text, positionStart, positionEnd),
            lineMode: "Default" /* Default */,
        };
    }
}
// read either string literal end or eof
function tokenizeQuotedIdentifierContentOrEnd(line, currentPosition) {
    const read = tokenizeStringLiteralContentOrEnd(line, currentPosition);
    switch (read.token.kind) {
        case "StringContent" /* StringLiteralContent */:
            return {
                lineMode: "QuotedIdentifier" /* QuotedIdentifier */,
                token: Object.assign(Object.assign({}, read.token), { kind: "QuotedIdentifierContent" /* QuotedIdentifierContent */ }),
            };
        case "StringLiteralEnd" /* StringLiteralEnd */:
            return {
                lineMode: "Default" /* Default */,
                token: Object.assign(Object.assign({}, read.token), { kind: "QuotedIdentifierEnd" /* QuotedIdentifierEnd */ }),
            };
        default:
            const details = { read };
            throw new common_1.CommonError.InvariantError("tokenizeStringLiteralContentOrEnd returned an unexpected kind", details);
    }
}
// read either string literal end or eof
function tokenizeStringLiteralContentOrEnd(line, currentPosition) {
    const text = line.text;
    const maybePositionEnd = maybeIndexOfStringEnd(text, currentPosition);
    if (maybePositionEnd === undefined) {
        return {
            token: readRestOfLine("StringContent" /* StringLiteralContent */, text, currentPosition),
            lineMode: "String" /* String */,
        };
    }
    else {
        const positionEnd = maybePositionEnd + 1;
        return {
            token: readTokenFrom("StringLiteralEnd" /* StringLiteralEnd */, text, currentPosition, positionEnd),
            lineMode: "Default" /* Default */,
        };
    }
}
function tokenizeDefault(localizationTemplates, line, lineNumber, positionStart) {
    const text = line.text;
    const chr1 = text[positionStart];
    let token;
    let lineMode = "Default" /* Default */;
    if (chr1 === "!") {
        token = readConstant("Bang" /* Bang */, text, positionStart, 1);
    }
    else if (chr1 === "&") {
        token = readConstant("Ampersand" /* Ampersand */, text, positionStart, 1);
    }
    else if (chr1 === "(") {
        token = readConstant("LeftParenthesis" /* LeftParenthesis */, text, positionStart, 1);
    }
    else if (chr1 === ")") {
        token = readConstant("RightParenthesis" /* RightParenthesis */, text, positionStart, 1);
    }
    else if (chr1 === "*") {
        token = readConstant("Asterisk" /* Asterisk */, text, positionStart, 1);
    }
    else if (chr1 === "+") {
        token = readConstant("Plus" /* Plus */, text, positionStart, 1);
    }
    else if (chr1 === ",") {
        token = readConstant("Comma" /* Comma */, text, positionStart, 1);
    }
    else if (chr1 === "-") {
        token = readConstant("Minus" /* Minus */, text, positionStart, 1);
    }
    else if (chr1 === ";") {
        token = readConstant("Semicolon" /* Semicolon */, text, positionStart, 1);
    }
    else if (chr1 === "?") {
        token = readConstant("QuestionMark" /* QuestionMark */, text, positionStart, 1);
    }
    else if (chr1 === "@") {
        token = readConstant("AtSign" /* AtSign */, text, positionStart, 1);
    }
    else if (chr1 === "[") {
        token = readConstant("LeftBracket" /* LeftBracket */, text, positionStart, 1);
    }
    else if (chr1 === "]") {
        token = readConstant("RightBracket" /* RightBracket */, text, positionStart, 1);
    }
    else if (chr1 === "{") {
        token = readConstant("LeftBrace" /* LeftBrace */, text, positionStart, 1);
    }
    else if (chr1 === "}") {
        token = readConstant("RightBrace" /* RightBrace */, text, positionStart, 1);
    }
    else if (chr1 === '"') {
        const read = readOrStartStringLiteral(text, positionStart);
        token = read.token;
        lineMode = read.lineMode;
    }
    else if (chr1 === "0") {
        const chr2 = text[positionStart + 1];
        if (chr2 === "x" || chr2 === "X") {
            token = readHexLiteral(localizationTemplates, text, lineNumber, positionStart);
        }
        else {
            token = readNumericLiteral(localizationTemplates, text, lineNumber, positionStart);
        }
    }
    else if ("1" <= chr1 && chr1 <= "9") {
        token = readNumericLiteral(localizationTemplates, text, lineNumber, positionStart);
    }
    else if (chr1 === ".") {
        const chr2 = text[positionStart + 1];
        if (chr2 === undefined) {
            throw new _1.LexError.UnexpectedEofError(localizationTemplates, graphemePositionFrom(text, lineNumber, positionStart));
        }
        else if ("1" <= chr2 && chr2 <= "9") {
            token = readNumericLiteral(localizationTemplates, text, lineNumber, positionStart);
        }
        else if (chr2 === ".") {
            const chr3 = text[positionStart + 2];
            if (chr3 === ".") {
                token = readConstant("Ellipsis" /* Ellipsis */, text, positionStart, 3);
            }
            else {
                token = readConstant("DotDot" /* DotDot */, text, positionStart, 2);
            }
        }
        else {
            throw unexpectedReadError(localizationTemplates, text, lineNumber, positionStart);
        }
    }
    else if (chr1 === ">") {
        const chr2 = text[positionStart + 1];
        if (chr2 === "=") {
            token = readConstant("GreaterThanEqualTo" /* GreaterThanEqualTo */, text, positionStart, 2);
        }
        else {
            token = readConstant("GreaterThan" /* GreaterThan */, text, positionStart, 1);
        }
    }
    else if (chr1 === "<") {
        const chr2 = text[positionStart + 1];
        if (chr2 === "=") {
            token = readConstant("LessThanEqualTo" /* LessThanEqualTo */, text, positionStart, 2);
        }
        else if (chr2 === ">") {
            token = readConstant("NotEqual" /* NotEqual */, text, positionStart, 2);
        }
        else {
            token = readConstant("LessThan" /* LessThan */, text, positionStart, 1);
        }
    }
    else if (chr1 === "=") {
        const chr2 = text[positionStart + 1];
        if (chr2 === ">") {
            token = readConstant("FatArrow" /* FatArrow */, text, positionStart, 2);
        }
        else {
            token = readConstant("Equal" /* Equal */, text, positionStart, 1);
        }
    }
    else if (chr1 === "/") {
        const chr2 = text[positionStart + 1];
        if (chr2 === "/") {
            token = readLineComment(text, positionStart);
        }
        else if (chr2 === "*") {
            const read = readOrStartMultilineComment(text, positionStart);
            token = read.token;
            lineMode = read.lineMode;
        }
        else {
            token = readConstant("Division" /* Division */, text, positionStart, 1);
        }
    }
    else if (chr1 === "#") {
        const chr2 = text[positionStart + 1];
        if (chr2 === '"') {
            const read = readOrStartQuotedIdentifier(text, positionStart);
            token = read.token;
            lineMode = read.lineMode;
        }
        else {
            token = readKeyword(localizationTemplates, text, lineNumber, positionStart);
        }
    }
    else {
        token = readKeywordOrIdentifier(localizationTemplates, text, lineNumber, positionStart);
    }
    return {
        token,
        lineMode,
    };
}
// newlines are not considered whitespace
function drainWhitespace(text, position) {
    let continueDraining = text[position] !== undefined;
    while (continueDraining) {
        const maybeLength = common_1.StringUtils.maybeRegexMatchLength(common_1.Pattern.RegExpWhitespace, text, position);
        if (maybeLength) {
            position += maybeLength;
        }
        else {
            continueDraining = false;
        }
    }
    return position;
}
function readOrStartStringLiteral(text, currentPosition) {
    const maybePositionEnd = maybeIndexOfStringEnd(text, currentPosition + 1);
    if (maybePositionEnd !== undefined) {
        const positionEnd = maybePositionEnd + 1;
        return {
            token: readTokenFrom("StringLiteral" /* StringLiteral */, text, currentPosition, positionEnd),
            lineMode: "Default" /* Default */,
        };
    }
    else {
        return {
            token: readRestOfLine("StringLiteralStart" /* StringLiteralStart */, text, currentPosition),
            lineMode: "String" /* String */,
        };
    }
}
function readHexLiteral(localizationTemplates, text, lineNumber, positionStart) {
    const maybePositionEnd = maybeIndexOfRegexEnd(common_1.Pattern.RegExpHex, text, positionStart);
    if (maybePositionEnd === undefined) {
        throw new _1.LexError.ExpectedError(localizationTemplates, graphemePositionFrom(text, lineNumber, positionStart), "HexLiteral" /* HexLiteral */);
    }
    const positionEnd = maybePositionEnd;
    return readTokenFrom("HexLiteral" /* HexLiteral */, text, positionStart, positionEnd);
}
function readNumericLiteral(localizationTemplates, text, lineNumber, positionStart) {
    const maybePositionEnd = maybeIndexOfRegexEnd(common_1.Pattern.RegExpNumeric, text, positionStart);
    if (maybePositionEnd === undefined) {
        throw new _1.LexError.ExpectedError(localizationTemplates, graphemePositionFrom(text, lineNumber, positionStart), "Numeric" /* Numeric */);
    }
    const positionEnd = maybePositionEnd;
    return readTokenFrom("NumericLiteral" /* NumericLiteral */, text, positionStart, positionEnd);
}
function readLineComment(text, positionStart) {
    return readRestOfLine("LineComment" /* LineComment */, text, positionStart);
}
function readOrStartMultilineComment(text, positionStart) {
    const indexOfCloseComment = text.indexOf("*/", positionStart + 2);
    if (indexOfCloseComment === -1) {
        return {
            token: readRestOfLine("MultilineCommentStart" /* MultilineCommentStart */, text, positionStart),
            lineMode: "Comment" /* Comment */,
        };
    }
    else {
        const positionEnd = indexOfCloseComment + 2;
        return {
            token: readTokenFrom("MultilineComment" /* MultilineComment */, text, positionStart, positionEnd),
            lineMode: "Default" /* Default */,
        };
    }
}
function readKeyword(localizationTemplates, text, lineNumber, positionStart) {
    const maybeLineToken = maybeReadKeyword(text, positionStart);
    if (maybeLineToken) {
        return maybeLineToken;
    }
    else {
        throw unexpectedReadError(localizationTemplates, text, lineNumber, positionStart);
    }
}
function maybeReadKeyword(text, currentPosition) {
    const identifierPositionStart = text[currentPosition] === "#" ? currentPosition + 1 : currentPosition;
    const maybeIdentifierPositionEnd = maybeIndexOfRegexEnd(common_1.Pattern.RegExpIdentifier, text, identifierPositionStart);
    if (maybeIdentifierPositionEnd === undefined) {
        return undefined;
    }
    const identifierPositionEnd = maybeIdentifierPositionEnd;
    const data = text.substring(currentPosition, identifierPositionEnd);
    const maybeKeywordTokenKind = maybeKeywordLineTokenKindFrom(data);
    if (maybeKeywordTokenKind === undefined) {
        return undefined;
    }
    else {
        return {
            kind: maybeKeywordTokenKind,
            positionStart: currentPosition,
            positionEnd: identifierPositionEnd,
            data,
        };
    }
}
function readOrStartQuotedIdentifier(text, currentPosition) {
    const maybePositionEnd = maybeIndexOfStringEnd(text, currentPosition + 2);
    if (maybePositionEnd !== undefined) {
        const positionEnd = maybePositionEnd + 1;
        return {
            token: readTokenFrom("Identifier" /* Identifier */, text, currentPosition, positionEnd),
            lineMode: "Default" /* Default */,
        };
    }
    else {
        return {
            token: readRestOfLine("QuotedIdentifierStart" /* QuotedIdentifierStart */, text, currentPosition),
            lineMode: "QuotedIdentifier" /* QuotedIdentifier */,
        };
    }
}
// The case for quoted identifier has already been taken care of.
// The null-literal is also read here.
function readKeywordOrIdentifier(localizationTemplates, text, lineNumber, positionStart) {
    // keyword
    if (text[positionStart] === "#") {
        return readKeyword(localizationTemplates, text, lineNumber, positionStart);
    }
    // either keyword or identifier
    else {
        const maybePositionEnd = maybeIndexOfRegexEnd(common_1.Pattern.RegExpIdentifier, text, positionStart);
        if (maybePositionEnd === undefined) {
            throw new _1.LexError.ExpectedError(localizationTemplates, graphemePositionFrom(text, lineNumber, positionStart), "KeywordOrIdentifier" /* KeywordOrIdentifier */);
        }
        const positionEnd = maybePositionEnd;
        const data = text.substring(positionStart, positionEnd);
        const maybeKeywordTokenKind = maybeKeywordLineTokenKindFrom(data);
        let tokenKind;
        if (maybeKeywordTokenKind !== undefined) {
            tokenKind = maybeKeywordTokenKind;
        }
        else if (data === "null") {
            tokenKind = "NullLiteral" /* NullLiteral */;
        }
        else {
            tokenKind = "Identifier" /* Identifier */;
        }
        return {
            kind: tokenKind,
            positionStart,
            positionEnd,
            data,
        };
    }
}
function readConstant(lineTokenKind, text, positionStart, length) {
    const positionEnd = positionStart + length;
    return readTokenFrom(lineTokenKind, text, positionStart, positionEnd);
}
function readTokenFrom(lineTokenKind, text, positionStart, positionEnd) {
    return {
        kind: lineTokenKind,
        positionStart,
        positionEnd,
        data: text.substring(positionStart, positionEnd),
    };
}
function readRestOfLine(lineTokenKind, text, positionStart) {
    const positionEnd = text.length;
    return readTokenFrom(lineTokenKind, text, positionStart, positionEnd);
}
function maybeIndexOfRegexEnd(pattern, text, positionStart) {
    const maybeLength = common_1.StringUtils.maybeRegexMatchLength(pattern, text, positionStart);
    return maybeLength !== undefined ? positionStart + maybeLength : undefined;
}
function maybeKeywordLineTokenKindFrom(data) {
    switch (data) {
        case "and" /* And */:
            return "KeywordAnd" /* KeywordAnd */;
        case "as" /* As */:
            return "KeywordAs" /* KeywordAs */;
        case "each" /* Each */:
            return "KeywordEach" /* KeywordEach */;
        case "else" /* Else */:
            return "KeywordElse" /* KeywordElse */;
        case "error" /* Error */:
            return "KeywordError" /* KeywordError */;
        case "false" /* False */:
            return "KeywordFalse" /* KeywordFalse */;
        case "if" /* If */:
            return "KeywordIf" /* KeywordIf */;
        case "in" /* In */:
            return "KeywordIn" /* KeywordIn */;
        case "is" /* Is */:
            return "KeywordIs" /* KeywordIs */;
        case "let" /* Let */:
            return "KeywordLet" /* KeywordLet */;
        case "meta" /* Meta */:
            return "KeywordMeta" /* KeywordMeta */;
        case "not" /* Not */:
            return "KeywordNot" /* KeywordNot */;
        case "or" /* Or */:
            return "KeywordOr" /* KeywordOr */;
        case "otherwise" /* Otherwise */:
            return "KeywordOtherwise" /* KeywordOtherwise */;
        case "section" /* Section */:
            return "KeywordSection" /* KeywordSection */;
        case "shared" /* Shared */:
            return "KeywordShared" /* KeywordShared */;
        case "then" /* Then */:
            return "KeywordThen" /* KeywordThen */;
        case "true" /* True */:
            return "KeywordTrue" /* KeywordTrue */;
        case "try" /* Try */:
            return "KeywordTry" /* KeywordTry */;
        case "type" /* Type */:
            return "KeywordType" /* KeywordType */;
        case "#binary" /* HashBinary */:
            return "KeywordHashBinary" /* KeywordHashBinary */;
        case "#date" /* HashDate */:
            return "KeywordHashDate" /* KeywordHashDate */;
        case "#datetime" /* HashDateTime */:
            return "KeywordHashDateTime" /* KeywordHashDateTime */;
        case "#datetimezone" /* HashDateTimeZone */:
            return "KeywordHashDateTimeZone" /* KeywordHashDateTimeZone */;
        case "#duration" /* HashDuration */:
            return "KeywordHashDuration" /* KeywordHashDuration */;
        case "#infinity" /* HashInfinity */:
            return "KeywordHashInfinity" /* KeywordHashInfinity */;
        case "#nan" /* HashNan */:
            return "KeywordHashNan" /* KeywordHashNan */;
        case "#sections" /* HashSections */:
            return "KeywordHashSections" /* KeywordHashSections */;
        case "#shared" /* HashShared */:
            return "KeywordHashShared" /* KeywordHashShared */;
        case "#table" /* HashTable */:
            return "KeywordHashTable" /* KeywordHashTable */;
        case "#time" /* HashTime */:
            return "KeywordHashTime" /* KeywordHashTime */;
        default:
            return undefined;
    }
}
function maybeIndexOfStringEnd(text, positionStart) {
    let indexLow = positionStart;
    let positionEnd = text.indexOf('"', indexLow);
    while (positionEnd !== -1) {
        if (text[positionEnd + 1] === '"') {
            indexLow = positionEnd + 2;
            positionEnd = text.indexOf('"', indexLow);
        }
        else {
            return positionEnd;
        }
    }
    return undefined;
}
function unexpectedReadError(localizationTemplates, text, lineNumber, lineCodeUnit) {
    return new _1.LexError.UnexpectedReadError(localizationTemplates, graphemePositionFrom(text, lineNumber, lineCodeUnit));
}
function maybeBadLineNumberError(state, lineNumber) {
    const numLines = state.lines.length;
    if (lineNumber >= numLines) {
        return new _1.LexError.BadLineNumberError(state.localizationTemplates, "GreaterThanNumLines" /* GreaterThanNumLines */, lineNumber, numLines);
    }
    else if (lineNumber < 0) {
        return new _1.LexError.BadLineNumberError(state.localizationTemplates, "LessThanZero" /* LessThanZero */, lineNumber, numLines);
    }
    else {
        return undefined;
    }
}
// Validator for Range.
function maybeBadRangeError(state, range) {
    const start = range.start;
    const end = range.end;
    const numLines = state.lines.length;
    let maybeKind;
    if (start.lineNumber === end.lineNumber && start.lineCodeUnit > end.lineCodeUnit) {
        maybeKind = "SameLine_LineCodeUnitStart_Higher" /* SameLine_LineCodeUnitStart_Higher */;
    }
    else if (start.lineNumber > end.lineNumber) {
        maybeKind = "LineNumberStart_GreaterThan_LineNumberEnd" /* LineNumberStart_GreaterThan_LineNumberEnd */;
    }
    else if (start.lineNumber < 0) {
        maybeKind = "LineNumberStart_LessThan_Zero" /* LineNumberStart_LessThan_Zero */;
    }
    else if (start.lineNumber >= numLines) {
        maybeKind = "LineNumberStart_GreaterThan_NumLines" /* LineNumberStart_GreaterThan_NumLines */;
    }
    else if (end.lineNumber >= numLines) {
        maybeKind = "LineNumberEnd_GreaterThan_NumLines" /* LineNumberEnd_GreaterThan_NumLines */;
    }
    if (maybeKind) {
        const kind = maybeKind;
        return new _1.LexError.BadRangeError(state.localizationTemplates, range, kind);
    }
    const lines = state.lines;
    const rangeStart = range.start;
    const rangeEnd = range.end;
    const lineStart = lines[rangeStart.lineNumber];
    const lineEnd = lines[rangeEnd.lineNumber];
    if (rangeStart.lineCodeUnit > lineStart.text.length) {
        maybeKind = "LineCodeUnitStart_GreaterThan_LineLength" /* LineCodeUnitStart_GreaterThan_LineLength */;
    }
    else if (rangeEnd.lineCodeUnit > lineEnd.text.length) {
        maybeKind = "LineCodeUnitEnd_GreaterThan_LineLength" /* LineCodeUnitEnd_GreaterThan_LineLength */;
    }
    if (maybeKind) {
        return new _1.LexError.BadRangeError(state.localizationTemplates, range, maybeKind);
    }
    return undefined;
}
//# sourceMappingURL=lexer.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexerSnapshot.js":
/*!**********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/lexerSnapshot.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
class LexerSnapshot {
    constructor(text, tokens, comments, lineTerminators) {
        this.text = text;
        this.tokens = tokens;
        this.comments = comments;
        this.lineTerminators = lineTerminators;
    }
    static tryFrom(state) {
        try {
            return common_1.ResultUtils.okFactory(LexerSnapshot.factory(state));
        }
        catch (e) {
            let error;
            if (_1.LexError.isTInnerLexError(e)) {
                error = new _1.LexError.LexError(e);
            }
            else {
                error = common_1.CommonError.ensureCommonError(state.localizationTemplates, e);
            }
            return common_1.ResultUtils.errFactory(error);
        }
    }
    static graphemePositionStartFrom(text, lineTerminators, flatLineToken) {
        const positionStart = flatLineToken.positionStart;
        const positionEnd = flatLineToken.positionEnd;
        let substringPositionStart = 0;
        let substringPositionEnd = text.length;
        for (const lineTerminator of lineTerminators) {
            if (lineTerminator.codeUnit < positionStart.codeUnit) {
                substringPositionStart = lineTerminator.codeUnit + lineTerminator.text.length;
            }
            if (lineTerminator.codeUnit >= positionEnd.codeUnit) {
                substringPositionEnd = lineTerminator.codeUnit + lineTerminator.text.length;
                break;
            }
        }
        return common_1.StringUtils.graphemePositionFrom(text.substring(substringPositionStart, substringPositionEnd), positionStart.lineCodeUnit, positionStart.lineNumber, positionEnd.codeUnit);
    }
    graphemePositionStartFrom(token) {
        return LexerSnapshot.graphemePositionStartFrom(this.text, this.lineTerminators, token);
    }
    columnNumberStartFrom(token) {
        return this.graphemePositionStartFrom(token).columnNumber;
    }
    static factory(state) {
        // class properties
        const tokens = [];
        const comments = [];
        const flattenedLines = flattenLineTokens(state);
        const flatTokens = flattenedLines.flatLineTokens;
        const numFlatTokens = flatTokens.length;
        const text = flattenedLines.text;
        const localizationTemplates = state.localizationTemplates;
        let flatIndex = 0;
        while (flatIndex < numFlatTokens) {
            const flatToken = flatTokens[flatIndex];
            switch (flatToken.kind) {
                case "LineComment" /* LineComment */:
                    comments.push(readLineComment(flatToken));
                    break;
                case "MultilineComment" /* MultilineComment */:
                    comments.push(readSingleLineMultilineComment(flatToken));
                    break;
                case "MultilineCommentStart" /* MultilineCommentStart */: {
                    const concatenatedTokenRead = readMultilineComment(localizationTemplates, flattenedLines, flatToken);
                    comments.push(concatenatedTokenRead.comment);
                    flatIndex = concatenatedTokenRead.flatIndexEnd;
                    break;
                }
                case "QuotedIdentifierStart" /* QuotedIdentifierStart */: {
                    const concatenatedTokenRead = readQuotedIdentifier(localizationTemplates, flattenedLines, flatToken);
                    tokens.push(concatenatedTokenRead.token);
                    flatIndex = concatenatedTokenRead.flatIndexEnd;
                    break;
                }
                case "StringLiteralStart" /* StringLiteralStart */: {
                    const concatenatedTokenRead = readStringLiteral(localizationTemplates, flattenedLines, flatToken);
                    tokens.push(concatenatedTokenRead.token);
                    flatIndex = concatenatedTokenRead.flatIndexEnd;
                    break;
                }
                default:
                    // UNSAFE MARKER
                    //
                    // Purpose of code block:
                    //      Translate LineTokenKind to LineToken.
                    //
                    // Why are you trying to avoid a safer approach?
                    //      A proper mapping would require a switch statement, one case per kind in LineNodeKind
                    //
                    // Why is it safe?
                    //      Almost all of LineTokenKind and TokenKind have a 1-to-1 mapping.
                    //      The edge cases (multiline tokens) have already been taken care of above.
                    //      set(remaining variants of LineTokenKind) === set(LineKind)
                    const positionStart = flatToken.positionStart;
                    const positionEnd = flatToken.positionEnd;
                    tokens.push({
                        kind: flatToken.kind,
                        data: flatToken.data,
                        positionStart,
                        positionEnd,
                    });
            }
            flatIndex += 1;
        }
        return new LexerSnapshot(text, tokens, comments, flattenedLines.lineTerminators);
    }
}
exports.LexerSnapshot = LexerSnapshot;
function readLineComment(flatToken) {
    const positionStart = flatToken.positionStart;
    const positionEnd = flatToken.positionEnd;
    return {
        kind: "Line" /* Line */,
        data: flatToken.data,
        containsNewline: true,
        positionStart,
        positionEnd,
    };
}
// a multiline comment that spans a single line
function readSingleLineMultilineComment(flatToken) {
    const positionStart = flatToken.positionStart;
    const positionEnd = flatToken.positionEnd;
    return {
        kind: "Multiline" /* Multiline */,
        data: flatToken.data,
        containsNewline: positionStart.lineNumber !== positionEnd.lineNumber,
        positionStart,
        positionEnd,
    };
}
function readMultilineComment(localizationTemplates, flattenedLines, tokenStart) {
    const collection = collectWhileContent(flattenedLines.flatLineTokens, tokenStart, "MultilineCommentContent" /* MultilineCommentContent */);
    const maybeTokenEnd = collection.maybeTokenEnd;
    if (!maybeTokenEnd) {
        throw new _1.LexError.UnterminatedMultilineTokenError(localizationTemplates, LexerSnapshot.graphemePositionStartFrom(flattenedLines.text, flattenedLines.lineTerminators, tokenStart), "MultilineComment" /* MultilineComment */);
    }
    else if (maybeTokenEnd.kind !== "MultilineCommentEnd" /* MultilineCommentEnd */) {
        const details = { foundTokenEnd: maybeTokenEnd };
        const message = "once a multiline token starts it should either reach a paired end token, or eof";
        throw new common_1.CommonError.InvariantError(message, details);
    }
    else {
        const tokenEnd = maybeTokenEnd;
        const positionStart = tokenStart.positionStart;
        const positionEnd = tokenEnd.positionEnd;
        return {
            comment: {
                kind: "Multiline" /* Multiline */,
                data: flattenedLines.text.substring(positionStart.codeUnit, positionEnd.codeUnit),
                containsNewline: positionStart.lineNumber !== positionEnd.lineNumber,
                positionStart,
                positionEnd,
            },
            flatIndexEnd: tokenEnd.flatIndex,
        };
    }
}
function readQuotedIdentifier(localizationTemplates, flattenedLines, tokenStart) {
    const collection = collectWhileContent(flattenedLines.flatLineTokens, tokenStart, "QuotedIdentifierContent" /* QuotedIdentifierContent */);
    const maybeTokenEnd = collection.maybeTokenEnd;
    if (!maybeTokenEnd) {
        throw new _1.LexError.UnterminatedMultilineTokenError(localizationTemplates, LexerSnapshot.graphemePositionStartFrom(flattenedLines.text, flattenedLines.lineTerminators, tokenStart), "QuotedIdentifier" /* QuotedIdentifier */);
    }
    else if (maybeTokenEnd.kind !== "QuotedIdentifierEnd" /* QuotedIdentifierEnd */) {
        const details = { foundTokenEnd: maybeTokenEnd };
        const message = "once a multiline token starts it should either reach a paired end token, or eof";
        throw new common_1.CommonError.InvariantError(message, details);
    }
    else {
        const tokenEnd = maybeTokenEnd;
        const positionStart = tokenStart.positionStart;
        const positionEnd = tokenEnd.positionEnd;
        return {
            token: {
                kind: "Identifier" /* Identifier */,
                data: flattenedLines.text.substring(positionStart.codeUnit, positionEnd.codeUnit),
                positionStart,
                positionEnd,
            },
            flatIndexEnd: tokenEnd.flatIndex,
        };
    }
}
function readStringLiteral(localizationTemplates, flattenedLines, tokenStart) {
    const collection = collectWhileContent(flattenedLines.flatLineTokens, tokenStart, "StringContent" /* StringLiteralContent */);
    const maybeTokenEnd = collection.maybeTokenEnd;
    if (!maybeTokenEnd) {
        throw new _1.LexError.UnterminatedMultilineTokenError(localizationTemplates, LexerSnapshot.graphemePositionStartFrom(flattenedLines.text, flattenedLines.lineTerminators, tokenStart), "String" /* String */);
    }
    else if (maybeTokenEnd.kind !== "StringLiteralEnd" /* StringLiteralEnd */) {
        const details = { foundTokenEnd: maybeTokenEnd };
        const message = "once a multiline token starts it should either reach a paired end token, or eof";
        throw new common_1.CommonError.InvariantError(message, details);
    }
    else {
        const tokenEnd = maybeTokenEnd;
        const positionStart = tokenStart.positionStart;
        const positionEnd = tokenEnd.positionEnd;
        return {
            token: {
                kind: "StringLiteral" /* StringLiteral */,
                data: flattenedLines.text.substring(positionStart.codeUnit, positionEnd.codeUnit),
                positionStart,
                positionEnd,
            },
            flatIndexEnd: tokenEnd.flatIndex,
        };
    }
}
function collectWhileContent(flatTokens, tokenStart, contentKind) {
    const collectedTokens = [];
    const numTokens = flatTokens.length;
    let flatIndex = tokenStart.flatIndex + 1;
    while (flatIndex < numTokens) {
        const token = flatTokens[flatIndex];
        if (token.kind !== contentKind) {
            break;
        }
        collectedTokens.push(token);
        flatIndex += 1;
    }
    return {
        tokenStart,
        collectedTokens: collectedTokens,
        maybeTokenEnd: flatTokens[flatIndex],
    };
}
function flattenLineTokens(state) {
    const lines = state.lines;
    const lineTerminators = [];
    const numLines = lines.length;
    let text = "";
    const flatLineTokens = [];
    let lineTextOffset = 0;
    let flatIndex = 0;
    for (let lineNumber = 0; lineNumber < numLines; lineNumber += 1) {
        const line = lines[lineNumber];
        text += line.text;
        if (lineNumber !== numLines - 1) {
            text += line.lineTerminator;
        }
        for (const lineToken of line.tokens) {
            const linePositionStart = lineToken.positionStart;
            const linePositionEnd = lineToken.positionEnd;
            flatLineTokens.push({
                kind: lineToken.kind,
                data: lineToken.data,
                positionStart: {
                    codeUnit: lineTextOffset + linePositionStart,
                    lineCodeUnit: linePositionStart,
                    lineNumber,
                },
                positionEnd: {
                    codeUnit: lineTextOffset + linePositionEnd,
                    lineCodeUnit: linePositionEnd,
                    lineNumber,
                },
                flatIndex,
            });
            flatIndex += 1;
        }
        const lineTerminatorCodeUnit = lineTextOffset + line.text.length;
        lineTerminators.push({
            codeUnit: lineTerminatorCodeUnit,
            text: line.lineTerminator,
        });
        lineTextOffset = lineTerminatorCodeUnit + line.lineTerminator.length;
    }
    return {
        text,
        lineTerminators,
        flatLineTokens,
    };
}
//# sourceMappingURL=lexerSnapshot.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/token.js":
/*!**************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/token.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=token.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js":
/*!*********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var localization_1 = __webpack_require__(/*! ./localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/localization.js");
exports.Localization = localization_1.Localization;
var templates_1 = __webpack_require__(/*! ./templates */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates.js");
exports.DefaultTemplates = templates_1.DefaultTemplates;
exports.TemplatesByLocale = templates_1.TemplatesByLocale;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/localization.js":
/*!****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/localization.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function localizeTokenKind(localizationTemplates, tokenKind) {
    switch (tokenKind) {
        case "Ampersand" /* Ampersand */:
            return localizationTemplates.tokenKind_ampersand;
        case "Asterisk" /* Asterisk */:
            return localizationTemplates.tokenKind_asterisk;
        case "AtSign" /* AtSign */:
            return localizationTemplates.tokenKind_atSign;
        case "Bang" /* Bang */:
            return localizationTemplates.tokenKind_bang;
        case "Comma" /* Comma */:
            return localizationTemplates.tokenKind_comma;
        case "Division" /* Division */:
            return localizationTemplates.tokenKind_division;
        case "DotDot" /* DotDot */:
            return localizationTemplates.tokenKind_dotDot;
        case "Ellipsis" /* Ellipsis */:
            return localizationTemplates.tokenKind_ellipsis;
        case "Equal" /* Equal */:
            return localizationTemplates.tokenKind_equal;
        case "FatArrow" /* FatArrow */:
            return localizationTemplates.tokenKind_fatArrow;
        case "GreaterThan" /* GreaterThan */:
            return localizationTemplates.tokenKind_greaterThan;
        case "GreaterThanEqualTo" /* GreaterThanEqualTo */:
            return localizationTemplates.tokenKind_greaterThanEqualTo;
        case "HexLiteral" /* HexLiteral */:
            return localizationTemplates.tokenKind_hexLiteral;
        case "Identifier" /* Identifier */:
            return localizationTemplates.tokenKind_identifier;
        case "KeywordAnd" /* KeywordAnd */:
            return localizationTemplates.tokenKind_keywordAnd;
        case "KeywordAs" /* KeywordAs */:
            return localizationTemplates.tokenKind_keywordAs;
        case "KeywordEach" /* KeywordEach */:
            return localizationTemplates.tokenKind_keywordEach;
        case "KeywordElse" /* KeywordElse */:
            return localizationTemplates.tokenKind_keywordElse;
        case "KeywordError" /* KeywordError */:
            return localizationTemplates.tokenKind_keywordError;
        case "KeywordFalse" /* KeywordFalse */:
            return localizationTemplates.tokenKind_keywordFalse;
        case "KeywordHashBinary" /* KeywordHashBinary */:
            return localizationTemplates.tokenKind_keywordHashBinary;
        case "KeywordHashDate" /* KeywordHashDate */:
            return localizationTemplates.tokenKind_keywordHashDate;
        case "KeywordHashDateTime" /* KeywordHashDateTime */:
            return localizationTemplates.tokenKind_keywordHashDateTime;
        case "KeywordHashDateTimeZone" /* KeywordHashDateTimeZone */:
            return localizationTemplates.tokenKind_keywordHashDateTimeZone;
        case "KeywordHashDuration" /* KeywordHashDuration */:
            return localizationTemplates.tokenKind_keywordHashDuration;
        case "KeywordHashInfinity" /* KeywordHashInfinity */:
            return localizationTemplates.tokenKind_keywordHashInfinity;
        case "KeywordHashNan" /* KeywordHashNan */:
            return localizationTemplates.tokenKind_keywordHashNan;
        case "KeywordHashSections" /* KeywordHashSections */:
            return localizationTemplates.tokenKind_keywordHashSections;
        case "KeywordHashShared" /* KeywordHashShared */:
            return localizationTemplates.tokenKind_keywordShared;
        case "KeywordHashTable" /* KeywordHashTable */:
            return localizationTemplates.tokenKind_keywordHashTable;
        case "KeywordHashTime" /* KeywordHashTime */:
            return localizationTemplates.tokenKind_keywordHashTime;
        case "KeywordIf" /* KeywordIf */:
            return localizationTemplates.tokenKind_keywordIf;
        case "KeywordIn" /* KeywordIn */:
            return localizationTemplates.tokenKind_keywordIn;
        case "KeywordIs" /* KeywordIs */:
            return localizationTemplates.tokenKind_keywordIs;
        case "KeywordLet" /* KeywordLet */:
            return localizationTemplates.tokenKind_keywordLet;
        case "KeywordMeta" /* KeywordMeta */:
            return localizationTemplates.tokenKind_keywordMeta;
        case "KeywordNot" /* KeywordNot */:
            return localizationTemplates.tokenKind_notEqual;
        case "KeywordOr" /* KeywordOr */:
            return localizationTemplates.tokenKind_keywordOr;
        case "KeywordOtherwise" /* KeywordOtherwise */:
            return localizationTemplates.tokenKind_keywordOtherwise;
        case "KeywordSection" /* KeywordSection */:
            return localizationTemplates.tokenKind_keywordSection;
        case "KeywordShared" /* KeywordShared */:
            return localizationTemplates.tokenKind_keywordShared;
        case "KeywordThen" /* KeywordThen */:
            return localizationTemplates.tokenKind_keywordThen;
        case "KeywordTrue" /* KeywordTrue */:
            return localizationTemplates.tokenKind_keywordTrue;
        case "KeywordTry" /* KeywordTry */:
            return localizationTemplates.tokenKind_keywordTry;
        case "KeywordType" /* KeywordType */:
            return localizationTemplates.tokenKind_keywordType;
        case "LeftBrace" /* LeftBrace */:
            return localizationTemplates.tokenKind_leftBrace;
        case "LeftBracket" /* LeftBracket */:
            return localizationTemplates.tokenKind_leftBracket;
        case "LeftParenthesis" /* LeftParenthesis */:
            return localizationTemplates.tokenKind_leftParenthesis;
        case "LessThan" /* LessThan */:
            return localizationTemplates.tokenKind_lessThan;
        case "LessThanEqualTo" /* LessThanEqualTo */:
            return localizationTemplates.tokenKind_lessThanEqualTo;
        case "Minus" /* Minus */:
            return localizationTemplates.tokenKind_minus;
        case "NotEqual" /* NotEqual */:
            return localizationTemplates.tokenKind_notEqual;
        case "NullLiteral" /* NullLiteral */:
            return localizationTemplates.tokenKind_nullLiteral;
        case "NumericLiteral" /* NumericLiteral */:
            return localizationTemplates.tokenKind_numericLiteral;
        case "Plus" /* Plus */:
            return localizationTemplates.tokenKind_plus;
        case "QuestionMark" /* QuestionMark */:
            return localizationTemplates.tokenKind_questionMark;
        case "RightBrace" /* RightBrace */:
            return localizationTemplates.tokenKind_rightBrace;
        case "RightBracket" /* RightBracket */:
            return localizationTemplates.tokenKind_rightBracket;
        case "RightParenthesis" /* RightParenthesis */:
            return localizationTemplates.tokenKind_rightParenthesis;
        case "Semicolon" /* Semicolon */:
            return localizationTemplates.tokenKind_semicolon;
        case "StringLiteral" /* StringLiteral */:
            return localizationTemplates.tokenKind_stringLiteral;
        default:
            throw common_1.isNever(tokenKind);
    }
}
exports.localizeTokenKind = localizeTokenKind;
exports.Localization = {
    error_common_invariantError: (templates, invariantBroken, maybeJsonifyableDetails) => {
        if (maybeJsonifyableDetails !== undefined) {
            return common_1.StringUtils.expectFormat(templates.error_common_invariantError_1_details, new Map([
                ["invariantBroken", invariantBroken],
                ["details", JSON.stringify(maybeJsonifyableDetails, undefined, 4)],
            ]));
        }
        else {
            return common_1.StringUtils.expectFormat(templates.error_common_invariantError_2_noDetails, new Map([["invariantBroken", invariantBroken]]));
        }
    },
    error_common_unknown: (templates, message) => {
        return common_1.StringUtils.expectFormat(templates.error_common_unknown, message);
    },
    error_lex_badLineNumber: (templates, kind) => {
        switch (kind) {
            case "GreaterThanNumLines" /* GreaterThanNumLines */:
                return templates.error_lex_badLineNumber_1_greaterThanNumLines;
            case "LessThanZero" /* LessThanZero */:
                return templates.error_lex_badLineNumber_2_lessThanZero;
            default:
                throw common_1.isNever(kind);
        }
    },
    error_lex_badRange: (templates, kind) => {
        switch (kind) {
            case "SameLine_LineCodeUnitStart_Higher" /* SameLine_LineCodeUnitStart_Higher */:
                return templates.error_lex_badRange_7_sameLine_codeUnitStartGreaterThanCodeUnitEnd;
            case "LineNumberStart_GreaterThan_LineNumberEnd" /* LineNumberStart_GreaterThan_LineNumberEnd */:
                return templates.error_lex_badRange_4_lineNumberStart_greaterThanLineNumberEnd;
            case "LineNumberStart_LessThan_Zero" /* LineNumberStart_LessThan_Zero */:
                return templates.error_lex_badRange_6_lineNumberStart_lessThanZero;
            case "LineNumberStart_GreaterThan_NumLines" /* LineNumberStart_GreaterThan_NumLines */:
                return templates.error_lex_badRange_5_lineNumberStart_greaterThanNumLines;
            case "LineNumberEnd_GreaterThan_NumLines" /* LineNumberEnd_GreaterThan_NumLines */:
                return templates.error_lex_badRange_2_lineNumberEnd_greaterThanLineNumbers;
            case "LineCodeUnitStart_GreaterThan_LineLength" /* LineCodeUnitStart_GreaterThan_LineLength */:
                return templates.error_lex_badRange_3_lineNumberStart_greaterThanLineLength;
            case "LineCodeUnitEnd_GreaterThan_LineLength" /* LineCodeUnitEnd_GreaterThan_LineLength */:
                return templates.error_lex_badRange_1_lineNumberEnd_greaterThanLineLength;
            default:
                throw common_1.isNever(kind);
        }
    },
    error_lex_badState: (templates) => templates.error_lex_badState,
    error_lex_endOfStream: (templates) => templates.error_lex_endOfStream,
    error_lex_endOfStreamPartwayRead: (templates) => templates.error_lex_endOfStreamPartwayRead,
    error_lex_expectedKind: (templates, kind) => {
        switch (kind) {
            case "HexLiteral" /* HexLiteral */:
                return templates.error_lex_expectedKind_1_hex;
            case "KeywordOrIdentifier" /* KeywordOrIdentifier */:
                return templates.error_lex_expectedKind_2_keywordOrIdentifier;
            case "Numeric" /* Numeric */:
                return templates.error_lex_expectedKind_3_numeric;
            default:
                throw common_1.isNever(kind);
        }
    },
    error_lex_lineMap: (templates, errorLineMap) => {
        const lineNumbers = [...errorLineMap.keys()]
            .map((lineNumber) => lineNumber.toString())
            .join(",");
        return common_1.StringUtils.expectFormat(templates.error_lex_lineMap, new Map([["lineNumbers", lineNumbers]]));
    },
    error_lex_unexpectedRead: (templates) => templates.error_lex_unexpectedRead,
    error_lex_unterminatedMultilineToken: (templates, kind) => {
        switch (kind) {
            case "MultilineComment" /* MultilineComment */:
                return templates.error_lex_unterminatedMultilineToken_1_comment;
            case "QuotedIdentifier" /* QuotedIdentifier */:
                return templates.error_lex_unterminatedMultilineToken_2_quotedIdentifier;
            case "String" /* String */:
                return templates.error_lex_unterminatedMultilineToken_3_string;
            default:
                throw common_1.isNever(kind);
        }
    },
    error_parse_csvContinuation: (templates, kind) => {
        switch (kind) {
            case "DanglingComma" /* DanglingComma */:
                return templates.error_parse_csvContinuation_1_danglingComma;
            case "LetExpression" /* LetExpression */:
                return templates.error_parse_csvContinuation_2_letExpression;
            default:
                throw common_1.isNever(kind);
        }
    },
    error_parse_expectAnyTokenKind: (templates, expectedAnyTokenKinds, maybeFoundToken) => {
        const localizedExpectedAnyTokenKinds = expectedAnyTokenKinds
            .map((tokenKind) => localizeTokenKind(templates, tokenKind))
            .join(", ");
        if (maybeFoundToken !== undefined) {
            return common_1.StringUtils.expectFormat(templates.error_parse_expectAnyTokenKind_1_other, new Map([
                ["foundTokenKind", localizeTokenKind(templates, maybeFoundToken.token.kind)],
                ["expectedAnyTokenKinds", localizedExpectedAnyTokenKinds],
            ]));
        }
        else {
            return common_1.StringUtils.expectFormat(templates.error_parse_expectAnyTokenKind_2_endOfStream, new Map([["expectedAnyTokenKinds", localizedExpectedAnyTokenKinds]]));
        }
    },
    error_parse_expectGeneralizedIdentifier: (templates, maybeFoundToken) => {
        if (maybeFoundToken !== undefined) {
            return templates.error_parse_expectGeneralizedIdentifier_1_other;
        }
        else {
            return templates.error_parse_expectGeneralizedIdentifier_2_endOfStream;
        }
    },
    error_parse_expectTokenKind: (templates, expectedTokenKind, maybeFoundToken) => {
        const localizedExpectedTokenKind = localizeTokenKind(templates, expectedTokenKind);
        if (maybeFoundToken !== undefined) {
            return common_1.StringUtils.expectFormat(templates.error_parse_expectTokenKind_1_other, new Map([
                ["expectedTokenKind", localizedExpectedTokenKind],
                ["foundTokenKind", localizeTokenKind(templates, maybeFoundToken.token.kind)],
            ]));
        }
        else {
            return common_1.StringUtils.expectFormat(templates.error_parse_expectTokenKind_2_endOfStream, new Map([["expectedTokenKind", localizedExpectedTokenKind]]));
        }
    },
    error_parse_invalidPrimitiveType: (templates, token) => {
        return common_1.StringUtils.expectFormat(templates.error_parse_invalidPrimitiveType, new Map([["foundTokenKind", localizeTokenKind(templates, token.kind)]]));
    },
    error_parse_requiredParameterAfterOptional: (templates) => templates.error_parse_requiredParameterAfterOptional,
    error_parse_unterminated_bracket: (templates) => templates.error_parse_unterminated_bracket,
    error_parse_unterminated_parenthesis: (templates) => templates.error_parse_unterminated_parenthesis,
    error_parse_unusedTokens: (templates) => templates.error_parse_unusedTokens,
};
//# sourceMappingURL=localization.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates.js":
/*!*************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const enUs = __webpack_require__(/*! ./templates/en-US.json */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates/en-US.json");
exports.TemplatesByLocale = new Map([["en-us", enUs]]);
exports.DefaultTemplates = enUs;
//# sourceMappingURL=templates.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates/en-US.json":
/*!*********************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/templates/en-US.json ***!
  \*********************************************************************************************************************/
/*! exports provided: error_common_invariantError_1_details, _error_common_invariantError_1_details.comment, error_common_invariantError_2_noDetails, _error_common_invariantError_2_noDetails.comment, error_common_unknown, _error_common_unknown.comment, error_lex_badLineNumber_1_greaterThanNumLines, _error_lex_badLineNumber_1_greaterThanNumLines.comment, error_lex_badLineNumber_2_lessThanZero, _error_lex_badLineNumber_2_lessThanZero.comment, error_lex_badRange_1_lineNumberEnd_greaterThanLineLength, _error_lex_badRange_1_lineNumberEnd_greaterThanLineLength.comment, error_lex_badRange_2_lineNumberEnd_greaterThanLineNumbers, _error_lex_badRange_2_lineNumberEnd_greaterThanLineNumbers.comment, error_lex_badRange_3_lineNumberStart_greaterThanLineLength, _error_lex_badRange_3_lineNumberStart_greaterThanLineLength.comment, error_lex_badRange_4_lineNumberStart_greaterThanLineNumberEnd, _error_lex_badRange_4_lineNumberStart_greaterThanLineNumberEnd.comment, error_lex_badRange_5_lineNumberStart_greaterThanNumLines, _error_lex_badRange_5_lineNumberStart_greaterThanNumLines.comment, error_lex_badRange_6_lineNumberStart_lessThanZero, _error_lex_badRange_6_lineNumberStart_lessThanZero.comment, error_lex_badRange_7_sameLine_codeUnitStartGreaterThanCodeUnitEnd, _error_lex_badRange_7_sameLine_codeUnitStartGreaterThanCodeUnitEnd.comment, error_lex_badState, _error_lex_badState.comment, error_lex_endOfStream, _error_lex_endOfStream.comment, error_lex_endOfStreamPartwayRead, _error_lex_endOfStreamPartwayRead.comment, error_lex_expectedKind_1_hex, _error_lex_expectedKind_1_hex.comment, error_lex_expectedKind_2_keywordOrIdentifier, _error_lex_expectedKind_2_keywordOrIdentifier.comment, error_lex_expectedKind_3_numeric, _error_lex_expectedKind_3_numeric.comment, error_lex_lineMap, _error_lex_lineMap.comment, error_lex_unexpectedRead, _error_lex_unexpectedRead.comment, error_lex_unterminatedMultilineToken_1_comment, _error_lex_unterminatedMultilineToken_1_comment.comment, error_lex_unterminatedMultilineToken_2_quotedIdentifier, _error_lex_unterminatedMultilineToken_2_quotedIdentifier.comment, error_lex_unterminatedMultilineToken_3_string, _error_lex_unterminatedMultilineToken_3_string.comment, error_parse_csvContinuation_1_danglingComma, _error_parse_csvContinuation_1_danglingComma.comment, error_parse_csvContinuation_2_letExpression, _error_parse_csvContinuation_2_letExpression.comment, error_parse_expectAnyTokenKind_1_other, _error_parse_expectAnyTokenKind_1_other.comment, error_parse_expectAnyTokenKind_2_endOfStream, _error_parse_expectAnyTokenKind_2_endOfStream.comment, error_parse_expectGeneralizedIdentifier_1_other, _error_parse_expectGeneralizedIdentifier_1_other.comment, error_parse_expectGeneralizedIdentifier_2_endOfStream, _error_parse_expectGeneralizedIdentifier_2_endOfStream.comment, error_parse_expectTokenKind_1_other, _error_parse_expectTokenKind_1_other.comment, error_parse_expectTokenKind_2_endOfStream, _error_parse_expectTokenKind_2_endOfStream.comment, error_parse_invalidPrimitiveType, _error_parse_invalidPrimitiveType.comment, error_parse_requiredParameterAfterOptional, _error_parse_requiredParameterAfterOptional.comment, error_parse_unterminated_bracket, _error_parse_unterminated_bracket.comment, error_parse_unterminated_parenthesis, _error_parse_unterminated_parenthesis.comment, error_parse_unusedTokens, _error_parse_unusedTokens.comment, tokenKind_ampersand, _tokenKind_ampersand.comment, tokenKind_asterisk, _tokenKind_asterisk.comment, tokenKind_atSign, _tokenKind_atSign.comment, tokenKind_bang, _tokenKind_bang.comment, tokenKind_comma, _tokenKind_comma.comment, tokenKind_division, _tokenKind_division.comment, tokenKind_dotDot, _tokenKind_dotDot.comment, tokenKind_ellipsis, _tokenKind_ellipsis.comment, tokenKind_equal, _tokenKind_equal.comment, tokenKind_fatArrow, _tokenKind_fatArrow.comment, tokenKind_greaterThan, _tokenKind_greaterThan.comment, tokenKind_greaterThanEqualTo, _tokenKind_greaterThanEqualTo.comment, tokenKind_hexLiteral, _tokenKind_hexLiteral.comment, tokenKind_identifier, _tokenKind_identifier.comment, tokenKind_keywordAnd, _tokenKind_keywordAnd.comment, tokenKind_keywordAs, _tokenKind_keywordAs.comment, tokenKind_keywordEach, _tokenKind_keywordEach.comment, tokenKind_keywordElse, _tokenKind_keywordElse.comment, tokenKind_keywordError, _tokenKind_keywordError.comment, tokenKind_keywordFalse, _tokenKind_keywordFalse.comment, tokenKind_keywordHashBinary, _tokenKind_keywordHashBinary.comment, tokenKind_keywordHashDate, _tokenKind_keywordHashDate.comment, tokenKind_keywordHashDateTime, _tokenKind_keywordHashDateTime.comment, tokenKind_keywordHashDateTimeZone, _tokenKind_keywordHashDateTimeZone.comment, tokenKind_keywordHashDuration, _tokenKind_keywordHashDuration.comment, tokenKind_keywordHashInfinity, _tokenKind_keywordHashInfinity.comment, tokenKind_keywordHashNan, _tokenKind_keywordHashNan.comment, tokenKind_keywordHashSections, _tokenKind_keywordHashSections.comment, tokenKind_keywordHashShared, _tokenKind_keywordHashShared.comment, tokenKind_keywordHashTable, _tokenKind_keywordHashTable.comment, tokenKind_keywordHashTime, _tokenKind_keywordHashTime.comment, tokenKind_keywordIf, _tokenKind_keywordIf.comment, tokenKind_keywordIn, _tokenKind_keywordIn.comment, tokenKind_keywordIs, _tokenKind_keywordIs.comment, tokenKind_keywordLet, _tokenKind_keywordLet.comment, tokenKind_keywordMeta, _tokenKind_keywordMeta.comment, tokenKind_keywordNot, _tokenKind_keywordNot.comment, tokenKind_keywordOr, _tokenKind_keywordOr.comment, tokenKind_keywordOtherwise, _tokenKind_keywordOtherwise.comment, tokenKind_keywordSection, _tokenKind_keywordSection.comment, tokenKind_keywordShared, _tokenKind_keywordShared.comment, tokenKind_keywordThen, _tokenKind_keywordThen.comment, tokenKind_keywordTrue, _tokenKind_keywordTrue.comment, tokenKind_keywordTry, _tokenKind_keywordTry.comment, tokenKind_keywordType, _tokenKind_keywordType.comment, tokenKind_leftBrace, _tokenKind_leftBrace.comment, tokenKind_leftBracket, _tokenKind_leftBracket.comment, tokenKind_leftParenthesis, _tokenKind_leftParenthesis.comment, tokenKind_lessThan, _tokenKind_lessThan.comment, tokenKind_lessThanEqualTo, _tokenKind_lessThanEqualTo.comment, tokenKind_minus, _tokenKind_minus.comment, tokenKind_notEqual, _tokenKind_notEqual.comment, tokenKind_nullLiteral, _tokenKind_nullLiteral.comment, tokenKind_numericLiteral, tokenKind_plus, _tokenKind_plus.comment, tokenKind_questionMark, _tokenKind_questionMark.comment, tokenKind_rightBrace, _tokenKind_rightBrace.comment, tokenKind_rightBracket, _tokenKind_rightBracket.comment, tokenKind_rightParenthesis, _tokenKind_rightParenthesis.comment, tokenKind_semicolon, _tokenKind_semicolon.comment, tokenKind_stringLiteral, _tokenKind_stringLiteral.comment, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"error_common_invariantError_1_details\":\"InvariantError: {invariantBroken} - {details}\",\"_error_common_invariantError_1_details.comment\":\"A fatal error, such as division by 0. Not intended to be user facing.\",\"error_common_invariantError_2_noDetails\":\"InvariantError: {invariantBroken}\",\"_error_common_invariantError_2_noDetails.comment\":\"A fatal error, such as division by 0. Not intended to be user facing.\",\"error_common_unknown\":\"An unknown error was encountered, innerError: {innerError}\",\"_error_common_unknown.comment\":\"A fatal error from unknown causes. Possibly user facing. {Locked=\\\"innerError\\\"}\",\"error_lex_badLineNumber_1_greaterThanNumLines\":\"lineNumber is greater than or equal to the number of lines\",\"_error_lex_badLineNumber_1_greaterThanNumLines.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing\",\"error_lex_badLineNumber_2_lessThanZero\":\"lineNumber is less than or equal 0\",\"_error_lex_badLineNumber_2_lessThanZero.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing.\",\"error_lex_badRange_1_lineNumberEnd_greaterThanLineLength\":\"end.lineCodeUnit is higher than line's length\",\"_error_lex_badRange_1_lineNumberEnd_greaterThanLineLength.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing.\",\"error_lex_badRange_2_lineNumberEnd_greaterThanLineNumbers\":\"end.lineNumber is higher than State's number of lines\",\"_error_lex_badRange_2_lineNumberEnd_greaterThanLineNumbers.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing.\",\"error_lex_badRange_3_lineNumberStart_greaterThanLineLength\":\"start.lineCodeUnit is higher than line's length\",\"_error_lex_badRange_3_lineNumberStart_greaterThanLineLength.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing. {Locked=\\\"start.lineCodeUnit\\\"}\",\"error_lex_badRange_4_lineNumberStart_greaterThanLineNumberEnd\":\"start.lineNumber is larger than end.lineNumber\",\"_error_lex_badRange_4_lineNumberStart_greaterThanLineNumberEnd.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing. {Locked=\\\"start.lineNumber\\\"}\",\"error_lex_badRange_5_lineNumberStart_greaterThanNumLines\":\"start.lineNumber is higher than State's number of lines\",\"_error_lex_badRange_5_lineNumberStart_greaterThanNumLines.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing. {Locked=\\\"start.lineNumber\\\"}\",\"error_lex_badRange_6_lineNumberStart_lessThanZero\":\"start.lineNumber is less than 0\",\"_error_lex_badRange_6_lineNumberStart_lessThanZero.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing. {Locked=\\\"start.lineNumber\\\"}\",\"error_lex_badRange_7_sameLine_codeUnitStartGreaterThanCodeUnitEnd\":\"Start and end shared the same line, but start.lineCodeUnit was higher than end.lineCodeUnit\",\"_error_lex_badRange_7_sameLine_codeUnitStartGreaterThanCodeUnitEnd.comment\":\"A low level error caused by a library consumer providing a bad number range. Not intended to be user facing. {Locked=\\\"start.lineCodeUnit\\\"}\",\"error_lex_badState\":\"The lexer encountered an error last run. Either feed the lexer more text or review previous error.\",\"_error_lex_badState.comment\":\"The text failed to previously lex, and will continue to fail until more text is added. Not intended to be user facing.\",\"error_lex_endOfStream\":\"The lexer reached end-of-stream\",\"_error_lex_endOfStream.comment\":\"The text failed to previously lex, and will continue to fail until more text is added. Not intended to be user facing.\",\"error_lex_endOfStreamPartwayRead\":\"While attempting to read a token the document stream ended part way through\",\"_error_lex_endOfStreamPartwayRead.comment\":\"The lexer reached EOF partway through reading a token. Not intended to be user facing.\",\"error_lex_expectedKind_1_hex\":\"Expected a hex literal\",\"_error_lex_expectedKind_1_hex.comment\":\"The lexer expected a hex literal ('0xdeadbeef') but failed to find one. Intended to be user facing.\",\"error_lex_expectedKind_2_keywordOrIdentifier\":\"Expected a keyword or identifier\",\"_error_lex_expectedKind_2_keywordOrIdentifier.comment\":\"The lexer expected a hex literal ('foo') but failed to find one. Intended to be user facing.\",\"error_lex_expectedKind_3_numeric\":\"Expected a numeric literal\",\"_error_lex_expectedKind_3_numeric.comment\":\"The lexer expected a hex literal ('foo') but failed to find one. Intended to be user facing.\",\"error_lex_lineMap\":\"Error on line(s): {lineNumbers}\",\"_error_lex_lineMap.comment\":\"A comma separated set of line numbers containing errors. Possibly user facing.\",\"error_lex_unexpectedRead\":\"Unexpected read during tokenization\",\"_error_lex_unexpectedRead.comment\":\"A generic lex error. Possibly user facing.\",\"error_lex_unterminatedMultilineToken_1_comment\":\"Unterminated multiline comment\",\"_error_lex_unterminatedMultilineToken_1_comment.comment\":\"The lexer found an unterminated multiline comment. Expected to be user facing.\",\"error_lex_unterminatedMultilineToken_2_quotedIdentifier\":\"Unterminated quoted identifier\",\"_error_lex_unterminatedMultilineToken_2_quotedIdentifier.comment\":\"The lexer found an unterminated quoted identifier. Expected to be user facing.\",\"error_lex_unterminatedMultilineToken_3_string\":\"Unterminated string\",\"_error_lex_unterminatedMultilineToken_3_string.comment\":\"The lexer found an unterminated multiline string. Expected to be user facing.\",\"error_parse_csvContinuation_1_danglingComma\":\"Did you leave a dangling comma?\",\"_error_parse_csvContinuation_1_danglingComma.comment\":\"A common parser error caused by a trailing comma, eg. '{1,2,}'. Expected to be user facing.\",\"error_parse_csvContinuation_2_letExpression\":\"A comma cannot proceed an 'in'\",\"_error_parse_csvContinuation_2_letExpression.comment\":\"A common parser error caused by a trailing comma, eg. 'let x = 1, in x'. Expected to be user facing. {Locked=\\\"'in'\\\"}\",\"error_parse_expectAnyTokenKind_1_other\":\"Expected to find one of the following, but a {foundTokenKind} was found instead: {expectedAnyTokenKinds}\",\"_error_parse_expectAnyTokenKind_1_other.comment\":\"A common parser error where expectedAnyTokenKinds is a csv collection of localized tokenKind strings and foundTokenKind is a localized tokenKind string. Expected to be user facing.\",\"error_parse_expectAnyTokenKind_2_endOfStream\":\"Expected to find one of the following, but the end-of-stream was reached instead: {expectedAnyTokenKinds}\",\"_error_parse_expectAnyTokenKind_2_endOfStream.comment\":\"A common parser error where foundTokenKind is a localized tokenKind string. Expected to be user facing.\",\"error_parse_expectGeneralizedIdentifier_1_other\":\"Expected to find a generalized identifier\",\"_error_parse_expectGeneralizedIdentifier_1_other.comment\":\"A common parser error. Expected to be user facing.\",\"error_parse_expectGeneralizedIdentifier_2_endOfStream\":\"Expected to find a generalized identifier but the end-of-stream was reached first\",\"_error_parse_expectGeneralizedIdentifier_2_endOfStream.comment\":\"A common parser error. Expected to be user facing.\",\"error_parse_expectTokenKind_1_other\":\"Expected to find a {expectedTokenKind}, but a {foundTokenKind} was found instead\",\"_error_parse_expectTokenKind_1_other.comment\":\"A common parser error where expectedTokenKind and foundTokenKind are a localized tokenKind string. Expected to be user facing.\",\"error_parse_expectTokenKind_2_endOfStream\":\"Expected to find a {expectedTokenKind}, but the end-of-stream was reached instead\",\"_error_parse_expectTokenKind_2_endOfStream.comment\":\"A common parser error where expectedTokenKind is a localized tokenKind string. Expected to be user facing.\",\"error_parse_invalidPrimitiveType\":\"Expected to find a primitive literal, but a {foundTokenKind} was found instead\",\"_error_parse_invalidPrimitiveType.comment\":\"A common parser error where foundTokenKind is a localized tokenKind string. Expected to be user facing.\",\"error_parse_requiredParameterAfterOptional\":\"You cannot have a non-optional parameter after an optional parameter\",\"_error_parse_requiredParameterAfterOptional.comment\":\"Optional parameters must come after non-optional parameters, eg. ('(optional x, y) => x + y') causes an error. Expected to be user facing.\",\"error_parse_unterminated_bracket\":\"Unterminated bracket\",\"_error_parse_unterminated_bracket.comment\":\"A common parser where it could not disambiguate a bracket. Expected to be user facing.\",\"error_parse_unterminated_parenthesis\":\"Unterminated parenthesis\",\"_error_parse_unterminated_parenthesis.comment\":\"A common parser where it could not disambiguate a parenthesis. Expected to be user facing.\",\"error_parse_unusedTokens\":\"Finished parsing but more tokens remain\",\"_error_parse_unusedTokens.comment\":\"A common parser where not every token was parsed. Possibly user facing.\",\"tokenKind_ampersand\":\"ampersand <'&'>\",\"_tokenKind_ampersand.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'&'>\\\"}\",\"tokenKind_asterisk\":\"asterisk <'*'>\",\"_tokenKind_asterisk.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'*'>\\\"}\",\"tokenKind_atSign\":\"at sign <'@'>\",\"_tokenKind_atSign.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'@'>\\\"}\",\"tokenKind_bang\":\"exclamation mark <'!'>\",\"_tokenKind_bang.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'!'>\\\"}\",\"tokenKind_comma\":\"comma <','>\",\"_tokenKind_comma.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<','>\\\"}\",\"tokenKind_division\":\"division operator <'/'>\",\"_tokenKind_division.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'/'>\\\"}\",\"tokenKind_dotDot\":\"dot dot <'..'>\",\"_tokenKind_dotDot.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'..'>\\\"}\",\"tokenKind_ellipsis\":\"ellipsis <'...'>\",\"_tokenKind_ellipsis.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'...'>\\\"}\",\"tokenKind_equal\":\"equal operator <'='>\",\"_tokenKind_equal.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'='>\\\"}\",\"tokenKind_fatArrow\":\"goes to ('=>')\",\"_tokenKind_fatArrow.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('=>')\\\"}\",\"tokenKind_greaterThan\":\"greater than operator ('>')\",\"_tokenKind_greaterThan.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('>')\\\"}\",\"tokenKind_greaterThanEqualTo\":\"greater than or equal to operator ('>=')\",\"_tokenKind_greaterThanEqualTo.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('>=')\\\"}\",\"tokenKind_hexLiteral\":\"hex literal\",\"_tokenKind_hexLiteral.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing.\",\"tokenKind_identifier\":\"identifier\",\"_tokenKind_identifier.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing.\",\"tokenKind_keywordAnd\":\"keyword <'and'>\",\"_tokenKind_keywordAnd.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'and'>\\\"}\",\"tokenKind_keywordAs\":\"keyword <'as'>\",\"_tokenKind_keywordAs.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'as'>\\\"}\",\"tokenKind_keywordEach\":\"keyword <'each'>\",\"_tokenKind_keywordEach.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'each'>\\\"}\",\"tokenKind_keywordElse\":\"keyword <'else'>\",\"_tokenKind_keywordElse.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'else'>\\\"}\",\"tokenKind_keywordError\":\"keyword <'error'>\",\"_tokenKind_keywordError.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'error'>\\\"}\",\"tokenKind_keywordFalse\":\"keyword <'false'>\",\"_tokenKind_keywordFalse.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'false'>\\\"}\",\"tokenKind_keywordHashBinary\":\"keyword <'#binary'>\",\"_tokenKind_keywordHashBinary.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#binary'>\\\"}\",\"tokenKind_keywordHashDate\":\"keyword <'#date'>\",\"_tokenKind_keywordHashDate.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#date'>\\\"}\",\"tokenKind_keywordHashDateTime\":\"keyword <'#datetime'>\",\"_tokenKind_keywordHashDateTime.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#datetime'>\\\"}\",\"tokenKind_keywordHashDateTimeZone\":\"keyword <'#datetimezone'>\",\"_tokenKind_keywordHashDateTimeZone.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#datetimezone'>\\\"}\",\"tokenKind_keywordHashDuration\":\"keyword <'#duration'>\",\"_tokenKind_keywordHashDuration.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#duration'>\\\"}\",\"tokenKind_keywordHashInfinity\":\"keyword <'#infinity'>\",\"_tokenKind_keywordHashInfinity.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#infinity'>\\\"}\",\"tokenKind_keywordHashNan\":\"keyword <'#nan'>\",\"_tokenKind_keywordHashNan.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#nan'>\\\"}\",\"tokenKind_keywordHashSections\":\"keyword <'#sections'>\",\"_tokenKind_keywordHashSections.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#sections'>\\\"}\",\"tokenKind_keywordHashShared\":\"keyword <'#shared'>\",\"_tokenKind_keywordHashShared.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#shared'>\\\"}\",\"tokenKind_keywordHashTable\":\"keyword <'#table'>\",\"_tokenKind_keywordHashTable.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#table'>\\\"}\",\"tokenKind_keywordHashTime\":\"keyword <'#time'>\",\"_tokenKind_keywordHashTime.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'#time'>\\\"}\",\"tokenKind_keywordIf\":\"keyword <'if'>\",\"_tokenKind_keywordIf.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'if'>\\\"}\",\"tokenKind_keywordIn\":\"keyword <'in'>\",\"_tokenKind_keywordIn.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'in'>\\\"}\",\"tokenKind_keywordIs\":\"keyword <'is'>\",\"_tokenKind_keywordIs.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'is'>\\\"}\",\"tokenKind_keywordLet\":\"keyword <'let'>\",\"_tokenKind_keywordLet.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'let'>\\\"}\",\"tokenKind_keywordMeta\":\"keyword <'meta'>\",\"_tokenKind_keywordMeta.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'meta'>\\\"}\",\"tokenKind_keywordNot\":\"keyword <'not'>\",\"_tokenKind_keywordNot.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'not'>\\\"}\",\"tokenKind_keywordOr\":\"keyword <'or'>\",\"_tokenKind_keywordOr.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'or'>\\\"}\",\"tokenKind_keywordOtherwise\":\"keyword <'otherwise'>\",\"_tokenKind_keywordOtherwise.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'otherwise'>\\\"}\",\"tokenKind_keywordSection\":\"keyword <'section'>\",\"_tokenKind_keywordSection.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'section'>\\\"}\",\"tokenKind_keywordShared\":\"keyword <'shared'>\",\"_tokenKind_keywordShared.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'shared'>\\\"}\",\"tokenKind_keywordThen\":\"keyword <'then'>\",\"_tokenKind_keywordThen.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'then'>\\\"}\",\"tokenKind_keywordTrue\":\"keyword <'true'>\",\"_tokenKind_keywordTrue.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'true'>\\\"}\",\"tokenKind_keywordTry\":\"keyword <'try'>\",\"_tokenKind_keywordTry.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'try'>\\\"}\",\"tokenKind_keywordType\":\"keyword <'type'>\",\"_tokenKind_keywordType.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'type'>\\\"}\",\"tokenKind_leftBrace\":\"left brace <'{'>\",\"_tokenKind_leftBrace.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'{'>\\\"}\",\"tokenKind_leftBracket\":\"left bracket <'['>\",\"_tokenKind_leftBracket.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'['>\\\"}\",\"tokenKind_leftParenthesis\":\"left parenthesis <'('>\",\"_tokenKind_leftParenthesis.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'('>\\\"}\",\"tokenKind_lessThan\":\"less than operator ('<')\",\"_tokenKind_lessThan.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('<')\\\"}\",\"tokenKind_lessThanEqualTo\":\"less than or equal to operator ('<=')\",\"_tokenKind_lessThanEqualTo.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('<=')\\\"}\",\"tokenKind_minus\":\"minus <'-'>\",\"_tokenKind_minus.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'-'>\\\"}\",\"tokenKind_notEqual\":\"not equal to operator ('<>')\",\"_tokenKind_notEqual.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"('<>')\\\"}\",\"tokenKind_nullLiteral\":\"<'null'>\",\"_tokenKind_nullLiteral.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'null'>\\\"}\",\"tokenKind_numericLiteral\":\"numeric literal\",\"tokenKind_plus\":\"addition operator <'+'>\",\"_tokenKind_plus.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'+'>\\\"}\",\"tokenKind_questionMark\":\"question mark <'?'>\",\"_tokenKind_questionMark.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'?'>\\\"}\",\"tokenKind_rightBrace\":\"right brace <'}'>\",\"_tokenKind_rightBrace.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<'}'>\\\"}\",\"tokenKind_rightBracket\":\"right bracket <']'>\",\"_tokenKind_rightBracket.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<']'>\\\"}\",\"tokenKind_rightParenthesis\":\"right parenthesis <')'>\",\"_tokenKind_rightParenthesis.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<')'>\\\"}\",\"tokenKind_semicolon\":\"semicolon <';'>\",\"_tokenKind_semicolon.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing. {Locked=\\\"<';'>\\\"}\",\"tokenKind_stringLiteral\":\"string\",\"_tokenKind_stringLiteral.comment\":\"The localized representation of a tokenKind enum. Expected to be user facing.\"}");

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParser.js":
/*!*****************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParser.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=IParser.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/IParserStateUtils.js":
/*!****************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/IParserStateUtils.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = __webpack_require__(/*! .. */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const nodeIdMap_1 = __webpack_require__(/*! ../nodeIdMap */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js");
// ---------------------------
// ---------- State ----------
// ---------------------------
// If you have a custom parser + parser state, then you'll have to create your own newState function.
// See `benchmark.ts` for an example.
function newState(settings, lexerSnapshot) {
    const maybeCurrentToken = lexerSnapshot.tokens[0];
    return {
        localizationTemplates: settings.localizationTemplates,
        lexerSnapshot,
        tokenIndex: 0,
        maybeCurrentToken,
        maybeCurrentTokenKind: maybeCurrentToken !== undefined ? maybeCurrentToken.kind : undefined,
        contextState: __1.ParseContextUtils.newState(),
        maybeCurrentContextNode: undefined,
    };
}
exports.newState = newState;
function applyState(originalState, otherState) {
    originalState.tokenIndex = otherState.tokenIndex;
    originalState.maybeCurrentToken = otherState.maybeCurrentToken;
    originalState.maybeCurrentTokenKind = otherState.maybeCurrentTokenKind;
    originalState.contextState = otherState.contextState;
    originalState.maybeCurrentContextNode = otherState.maybeCurrentContextNode;
}
exports.applyState = applyState;
// Due to performance reasons the backup no longer can include a naive deep copy of the context state.
// Instead it's assumed that a backup is made immediately before a try/catch read block.
// This means the state begins in a parsing context and the backup will either be immediately consumed or dropped.
// Therefore we only care about the delta between before and after the try/catch block.
// Thanks to the invariants above and the fact the ids for nodes are an auto-incrementing integer
// we can easily just drop all delete all context nodes past the id of when the backup was created.
function fastStateBackup(state) {
    return {
        tokenIndex: state.tokenIndex,
        contextStateIdCounter: state.contextState.idCounter,
        maybeContextNodeId: state.maybeCurrentContextNode !== undefined ? state.maybeCurrentContextNode.id : undefined,
    };
}
exports.fastStateBackup = fastStateBackup;
// See state.fastSnapshot for more information.
function applyFastStateBackup(state, backup) {
    state.tokenIndex = backup.tokenIndex;
    state.maybeCurrentToken = state.lexerSnapshot.tokens[state.tokenIndex];
    state.maybeCurrentTokenKind = state.maybeCurrentToken !== undefined ? state.maybeCurrentToken.kind : undefined;
    const contextState = state.contextState;
    const nodeIdMapCollection = state.contextState.nodeIdMapCollection;
    const backupIdCounter = backup.contextStateIdCounter;
    contextState.idCounter = backupIdCounter;
    const newContextNodeIds = [];
    const newAstNodeIds = [];
    for (const nodeId of nodeIdMapCollection.astNodeById.keys()) {
        if (nodeId > backupIdCounter) {
            newAstNodeIds.push(nodeId);
        }
    }
    for (const nodeId of nodeIdMapCollection.contextNodeById.keys()) {
        if (nodeId > backupIdCounter) {
            newContextNodeIds.push(nodeId);
        }
    }
    for (const nodeId of newAstNodeIds.sort().reverse()) {
        const maybeParent = nodeIdMapCollection.parentIdById.get(nodeId);
        const parentWillBeDeleted = maybeParent !== undefined && maybeParent >= backupIdCounter;
        __1.ParseContextUtils.deleteAst(state.contextState, nodeId, parentWillBeDeleted);
    }
    for (const nodeId of newContextNodeIds.sort().reverse()) {
        __1.ParseContextUtils.deleteContext(state.contextState, nodeId);
    }
    if (backup.maybeContextNodeId) {
        state.maybeCurrentContextNode = nodeIdMap_1.NodeIdMapUtils.expectContextNode(state.contextState.nodeIdMapCollection.contextNodeById, backup.maybeContextNodeId);
    }
    else {
        state.maybeCurrentContextNode = undefined;
    }
}
exports.applyFastStateBackup = applyFastStateBackup;
function startContext(state, nodeKind) {
    const newContextNode = __1.ParseContextUtils.startContext(state.contextState, nodeKind, state.tokenIndex, state.maybeCurrentToken, state.maybeCurrentContextNode);
    state.maybeCurrentContextNode = newContextNode;
}
exports.startContext = startContext;
function endContext(state, astNode) {
    if (state.maybeCurrentContextNode === undefined) {
        throw new common_1.CommonError.InvariantError("maybeContextNode should be truthy, can't end a context if it doesn't exist.");
    }
    const maybeParentOfContextNode = __1.ParseContextUtils.endContext(state.contextState, state.maybeCurrentContextNode, astNode);
    state.maybeCurrentContextNode = maybeParentOfContextNode;
}
exports.endContext = endContext;
function deleteContext(state, maybeNodeId) {
    let nodeId;
    if (maybeNodeId === undefined) {
        if (state.maybeCurrentContextNode === undefined) {
            throw new common_1.CommonError.InvariantError("maybeContextNode should be truthy, can't delete a context if it doesn't exist.");
        }
        else {
            const currentContextNode = state.maybeCurrentContextNode;
            nodeId = currentContextNode.id;
        }
    }
    else {
        nodeId = maybeNodeId;
    }
    state.maybeCurrentContextNode = __1.ParseContextUtils.deleteContext(state.contextState, nodeId);
}
exports.deleteContext = deleteContext;
function incrementAttributeCounter(state) {
    if (state.maybeCurrentContextNode === undefined) {
        throw new common_1.CommonError.InvariantError(`maybeCurrentContextNode should be truthy`);
    }
    const currentContextNode = state.maybeCurrentContextNode;
    currentContextNode.attributeCounter += 1;
}
exports.incrementAttributeCounter = incrementAttributeCounter;
// -------------------------
// ---------- IsX ----------
// -------------------------
function isTokenKind(state, tokenKind, tokenIndex) {
    const maybeToken = state.lexerSnapshot.tokens[tokenIndex];
    if (maybeToken) {
        return maybeToken.kind === tokenKind;
    }
    else {
        return false;
    }
}
exports.isTokenKind = isTokenKind;
function isNextTokenKind(state, tokenKind) {
    return isTokenKind(state, tokenKind, state.tokenIndex + 1);
}
exports.isNextTokenKind = isNextTokenKind;
function isOnTokenKind(state, tokenKind, tokenIndex = state.tokenIndex) {
    return isTokenKind(state, tokenKind, tokenIndex);
}
exports.isOnTokenKind = isOnTokenKind;
function isOnConstantKind(state, constantKind) {
    if (isOnTokenKind(state, "Identifier" /* Identifier */)) {
        const currentToken = state.lexerSnapshot.tokens[state.tokenIndex];
        if (currentToken === undefined || currentToken.data === undefined) {
            const details = { currentToken };
            throw new common_1.CommonError.InvariantError(`expected data on Token`, details);
        }
        const data = currentToken.data;
        return data === constantKind;
    }
    else {
        return false;
    }
}
exports.isOnConstantKind = isOnConstantKind;
function isOnGeneralizedIdentifierStart(state, tokenIndex = state.tokenIndex) {
    const maybeToken = state.lexerSnapshot.tokens[tokenIndex];
    if (maybeToken === undefined) {
        return false;
    }
    const tokenKind = maybeToken.kind;
    switch (tokenKind) {
        case "Identifier" /* Identifier */:
        case "KeywordAnd" /* KeywordAnd */:
        case "KeywordAs" /* KeywordAs */:
        case "KeywordEach" /* KeywordEach */:
        case "KeywordElse" /* KeywordElse */:
        case "KeywordError" /* KeywordError */:
        case "KeywordFalse" /* KeywordFalse */:
        case "KeywordHashBinary" /* KeywordHashBinary */:
        case "KeywordHashDate" /* KeywordHashDate */:
        case "KeywordHashDateTime" /* KeywordHashDateTime */:
        case "KeywordHashDateTimeZone" /* KeywordHashDateTimeZone */:
        case "KeywordHashDuration" /* KeywordHashDuration */:
        case "KeywordHashInfinity" /* KeywordHashInfinity */:
        case "KeywordHashNan" /* KeywordHashNan */:
        case "KeywordHashSections" /* KeywordHashSections */:
        case "KeywordHashShared" /* KeywordHashShared */:
        case "KeywordHashTable" /* KeywordHashTable */:
        case "KeywordHashTime" /* KeywordHashTime */:
        case "KeywordIf" /* KeywordIf */:
        case "KeywordIn" /* KeywordIn */:
        case "KeywordIs" /* KeywordIs */:
        case "KeywordLet" /* KeywordLet */:
        case "KeywordMeta" /* KeywordMeta */:
        case "KeywordNot" /* KeywordNot */:
        case "KeywordOr" /* KeywordOr */:
        case "KeywordOtherwise" /* KeywordOtherwise */:
        case "KeywordSection" /* KeywordSection */:
        case "KeywordShared" /* KeywordShared */:
        case "KeywordThen" /* KeywordThen */:
        case "KeywordTrue" /* KeywordTrue */:
        case "KeywordTry" /* KeywordTry */:
        case "KeywordType" /* KeywordType */:
            return true;
        default:
            return false;
    }
}
exports.isOnGeneralizedIdentifierStart = isOnGeneralizedIdentifierStart;
// Assumes a call to readPrimaryExpression has already happened.
function isRecursivePrimaryExpressionNext(state, tokenIndexStart = state.tokenIndex) {
    return (
    // section-access-expression
    // this.isOnTokenKind(TokenKind.Bang)
    // field-access-expression
    isTokenKind(state, "LeftBrace" /* LeftBrace */, tokenIndexStart) ||
        // item-access-expression
        isTokenKind(state, "LeftBracket" /* LeftBracket */, tokenIndexStart) ||
        // invoke-expression
        isTokenKind(state, "LeftParenthesis" /* LeftParenthesis */, tokenIndexStart));
}
exports.isRecursivePrimaryExpressionNext = isRecursivePrimaryExpressionNext;
// -----------------------------
// ---------- Expects ----------
// -----------------------------
function expectContextNodeMetadata(state) {
    if (state.maybeCurrentContextNode === undefined) {
        throw new common_1.CommonError.InvariantError("maybeCurrentContextNode should be truthy");
    }
    const currentContextNode = state.maybeCurrentContextNode;
    const maybeTokenStart = currentContextNode.maybeTokenStart;
    if (maybeTokenStart === undefined) {
        throw new common_1.CommonError.InvariantError(`maybeTokenStart should be truthy`);
    }
    const tokenStart = maybeTokenStart;
    // inclusive token index
    const tokenIndexEnd = state.tokenIndex - 1;
    const maybeTokenEnd = state.lexerSnapshot.tokens[tokenIndexEnd];
    if (maybeTokenEnd === undefined) {
        throw new common_1.CommonError.InvariantError(`maybeTokenEnd should be truthy`);
    }
    const tokenEnd = maybeTokenEnd;
    const tokenRange = {
        tokenIndexStart: currentContextNode.tokenIndexStart,
        tokenIndexEnd,
        positionStart: tokenStart.positionStart,
        positionEnd: tokenEnd.positionEnd,
    };
    const contextNode = state.maybeCurrentContextNode;
    return {
        id: contextNode.id,
        maybeAttributeIndex: currentContextNode.maybeAttributeIndex,
        tokenRange,
    };
}
exports.expectContextNodeMetadata = expectContextNodeMetadata;
function expectTokenAt(state, tokenIndex) {
    const lexerSnapshot = state.lexerSnapshot;
    const maybeToken = lexerSnapshot.tokens[tokenIndex];
    if (maybeToken) {
        return maybeToken;
    }
    else {
        throw new common_1.CommonError.InvariantError(`this.tokens[${tokenIndex}] is falsey`);
    }
}
exports.expectTokenAt = expectTokenAt;
// -------------------------------
// ---------- Csv Tests ----------
// -------------------------------
// All of these tests assume you're in a given context and have just read a `,`.
// Eg. testCsvEndLetExpression assumes you're in a LetExpression context and have just read a `,`.
function testCsvContinuationLetExpression(state) {
    if (state.maybeCurrentTokenKind === "KeywordIn" /* KeywordIn */) {
        return new __1.ParseError.ExpectedCsvContinuationError(state.localizationTemplates, "LetExpression" /* LetExpression */, maybeCurrentTokenWithColumnNumber(state));
    }
    return undefined;
}
exports.testCsvContinuationLetExpression = testCsvContinuationLetExpression;
function testCsvContinuationDanglingComma(state, tokenKind) {
    if (state.maybeCurrentTokenKind === tokenKind) {
        return new __1.ParseError.ExpectedCsvContinuationError(state.localizationTemplates, "DanglingComma" /* DanglingComma */, maybeCurrentTokenWithColumnNumber(state));
    }
    else {
        return undefined;
    }
}
exports.testCsvContinuationDanglingComma = testCsvContinuationDanglingComma;
// ---------------------------
// ---------- Tests ----------
// ---------------------------
function testIsOnTokenKind(state, expectedTokenKind) {
    if (expectedTokenKind !== state.maybeCurrentTokenKind) {
        const maybeToken = maybeCurrentTokenWithColumnNumber(state);
        return new __1.ParseError.ExpectedTokenKindError(state.localizationTemplates, expectedTokenKind, maybeToken);
    }
    else {
        return undefined;
    }
}
exports.testIsOnTokenKind = testIsOnTokenKind;
function testIsOnAnyTokenKind(state, expectedAnyTokenKinds) {
    const isError = state.maybeCurrentTokenKind === undefined || expectedAnyTokenKinds.indexOf(state.maybeCurrentTokenKind) === -1;
    if (isError) {
        const maybeToken = maybeCurrentTokenWithColumnNumber(state);
        return new __1.ParseError.ExpectedAnyTokenKindError(state.localizationTemplates, expectedAnyTokenKinds, maybeToken);
    }
    else {
        return undefined;
    }
}
exports.testIsOnAnyTokenKind = testIsOnAnyTokenKind;
function testNoMoreTokens(state) {
    if (state.tokenIndex !== state.lexerSnapshot.tokens.length) {
        const token = expectTokenAt(state, state.tokenIndex);
        return new __1.ParseError.UnusedTokensRemainError(state.localizationTemplates, token, state.lexerSnapshot.graphemePositionStartFrom(token));
    }
    else {
        return undefined;
    }
}
exports.testNoMoreTokens = testNoMoreTokens;
// -------------------------------------
// ---------- Error factories ----------
// -------------------------------------
function unterminatedParenthesesError(state) {
    const token = expectTokenAt(state, state.tokenIndex);
    return new __1.ParseError.UnterminatedParenthesesError(state.localizationTemplates, token, state.lexerSnapshot.graphemePositionStartFrom(token));
}
exports.unterminatedParenthesesError = unterminatedParenthesesError;
function unterminatedBracketError(state) {
    const token = expectTokenAt(state, state.tokenIndex);
    return new __1.ParseError.UnterminatedBracketError(state.localizationTemplates, token, state.lexerSnapshot.graphemePositionStartFrom(token));
}
exports.unterminatedBracketError = unterminatedBracketError;
// ---------------------------------------------
// ---------- Column number factories ----------
// ---------------------------------------------
function maybeCurrentTokenWithColumnNumber(state) {
    return maybeTokenWithColumnNumber(state, state.tokenIndex);
}
exports.maybeCurrentTokenWithColumnNumber = maybeCurrentTokenWithColumnNumber;
function maybeTokenWithColumnNumber(state, tokenIndex) {
    const maybeToken = state.lexerSnapshot.tokens[tokenIndex];
    if (maybeToken === undefined) {
        return undefined;
    }
    const currentToken = maybeToken;
    return {
        token: currentToken,
        columnNumber: state.lexerSnapshot.columnNumberStartFrom(currentToken),
    };
}
exports.maybeTokenWithColumnNumber = maybeTokenWithColumnNumber;
//# sourceMappingURL=IParserStateUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js":
/*!****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IParserStateUtils = __webpack_require__(/*! ./IParserStateUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/IParserStateUtils.js");
exports.IParserStateUtils = IParserStateUtils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/ast.js":
/*!*****************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/ast.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ast.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/astUtils.js":
/*!**********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/astUtils.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function maybeUnaryOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "Plus" /* Plus */:
            return "+" /* Positive */;
        case "Minus" /* Minus */:
            return "-" /* Negative */;
        case "KeywordNot" /* KeywordNot */:
            return "not" /* Not */;
        default:
            return undefined;
    }
}
exports.maybeUnaryOperatorKindFrom = maybeUnaryOperatorKindFrom;
function maybeArithmeticOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "Asterisk" /* Asterisk */:
            return "*" /* Multiplication */;
        case "Division" /* Division */:
            return "/" /* Division */;
        case "Plus" /* Plus */:
            return "+" /* Addition */;
        case "Minus" /* Minus */:
            return "-" /* Subtraction */;
        case "Ampersand" /* Ampersand */:
            return "&" /* And */;
        default:
            return undefined;
    }
}
exports.maybeArithmeticOperatorKindFrom = maybeArithmeticOperatorKindFrom;
function maybeEqualityOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "Equal" /* Equal */:
            return "=" /* EqualTo */;
        case "NotEqual" /* NotEqual */:
            return "<>" /* NotEqualTo */;
        default:
            return undefined;
    }
}
exports.maybeEqualityOperatorKindFrom = maybeEqualityOperatorKindFrom;
function maybeLogicalOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "KeywordAnd" /* KeywordAnd */:
            return "and" /* And */;
        case "KeywordOr" /* KeywordOr */:
            return "or" /* Or */;
        default:
            return undefined;
    }
}
exports.maybeLogicalOperatorKindFrom = maybeLogicalOperatorKindFrom;
function maybeRelationalOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "LessThan" /* LessThan */:
            return "<" /* LessThan */;
        case "LessThanEqualTo" /* LessThanEqualTo */:
            return "<=" /* LessThanEqualTo */;
        case "GreaterThan" /* GreaterThan */:
            return ">" /* GreaterThan */;
        case "GreaterThanEqualTo" /* GreaterThanEqualTo */:
            return ">=" /* GreaterThanEqualTo */;
        default:
            return undefined;
    }
}
exports.maybeRelationalOperatorKindFrom = maybeRelationalOperatorKindFrom;
function maybeBinOpExpressionOperatorKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        // ArithmeticOperator
        case "Asterisk" /* Asterisk */:
            return "*" /* Multiplication */;
        case "Division" /* Division */:
            return "/" /* Division */;
        case "Plus" /* Plus */:
            return "+" /* Addition */;
        case "Minus" /* Minus */:
            return "-" /* Subtraction */;
        case "Ampersand" /* Ampersand */:
            return "&" /* And */;
        // EqualityOperator
        case "Equal" /* Equal */:
            return "=" /* EqualTo */;
        case "NotEqual" /* NotEqual */:
            return "<>" /* NotEqualTo */;
        // LogicalOperator
        case "KeywordAnd" /* KeywordAnd */:
            return "and" /* And */;
        case "KeywordOr" /* KeywordOr */:
            return "or" /* Or */;
        // RelationalOperator
        case "LessThan" /* LessThan */:
            return "<" /* LessThan */;
        case "LessThanEqualTo" /* LessThanEqualTo */:
            return "<=" /* LessThanEqualTo */;
        case "GreaterThan" /* GreaterThan */:
            return ">" /* GreaterThan */;
        case "GreaterThanEqualTo" /* GreaterThanEqualTo */:
            return ">=" /* GreaterThanEqualTo */;
        // Keyword operator
        case "KeywordAs" /* KeywordAs */:
            return "as" /* As */;
        case "KeywordIs" /* KeywordIs */:
            return "is" /* Is */;
        case "KeywordMeta" /* KeywordMeta */:
            return "meta" /* Meta */;
        default:
            return undefined;
    }
}
exports.maybeBinOpExpressionOperatorKindFrom = maybeBinOpExpressionOperatorKindFrom;
function binOpExpressionOperatorPrecedence(operator) {
    switch (operator) {
        case "meta" /* Meta */:
            return 110;
        case "*" /* Multiplication */:
        case "/" /* Division */:
            return 100;
        case "+" /* Addition */:
        case "-" /* Subtraction */:
        case "&" /* And */:
            return 90;
        case ">" /* GreaterThan */:
        case ">=" /* GreaterThanEqualTo */:
        case "<" /* LessThan */:
        case "<=" /* LessThanEqualTo */:
            return 80;
        case "=" /* EqualTo */:
        case "<>" /* NotEqualTo */:
            return 70;
        case "as" /* As */:
            return 60;
        case "is" /* Is */:
            return 50;
        case "and" /* And */:
            return 40;
        case "or" /* Or */:
            return 30;
        default:
            throw common_1.isNever(operator);
    }
}
exports.binOpExpressionOperatorPrecedence = binOpExpressionOperatorPrecedence;
function maybeLiteralKindFrom(maybeTokenKind) {
    switch (maybeTokenKind) {
        case "HexLiteral" /* HexLiteral */:
        case "KeywordHashNan" /* KeywordHashNan */:
        case "KeywordHashInfinity" /* KeywordHashInfinity */:
        case "NumericLiteral" /* NumericLiteral */:
            return "Numeric" /* Numeric */;
        case "KeywordFalse" /* KeywordFalse */:
        case "KeywordTrue" /* KeywordTrue */:
            return "Logical" /* Logical */;
        case "NullLiteral" /* NullLiteral */:
            return "Null" /* Null */;
        case "StringLiteral" /* StringLiteral */:
            return "Str" /* Str */;
        default:
            return undefined;
    }
}
exports.maybeLiteralKindFrom = maybeLiteralKindFrom;
function primitiveTypeConstantKindFrom(node) {
    switch (node.kind) {
        case "AsNullablePrimitiveType" /* AsNullablePrimitiveType */:
            return primitiveTypeConstantKindFrom(node.paired);
        case "NullablePrimitiveType" /* NullablePrimitiveType */:
            return node.paired.primitiveType.constantKind;
        case "PrimitiveType" /* PrimitiveType */:
            return node.primitiveType.constantKind;
        default:
            throw common_1.isNever(node);
    }
}
exports.primitiveTypeConstantKindFrom = primitiveTypeConstantKindFrom;
function isPrimitiveTypeConstantKind(maybePrimitiveTypeConstantKind) {
    switch (maybePrimitiveTypeConstantKind) {
        case "nullable" /* Nullable */:
        case "optional" /* Optional */:
        case "any" /* Any */:
        case "anynonnull" /* AnyNonNull */:
        case "binary" /* Binary */:
        case "date" /* Date */:
        case "datetime" /* DateTime */:
        case "datetimezone" /* DateTimeZone */:
        case "duration" /* Duration */:
        case "function" /* Function */:
        case "list" /* List */:
        case "logical" /* Logical */:
        case "none" /* None */:
        case "number" /* Number */:
        case "record" /* Record */:
        case "table" /* Table */:
        case "text" /* Text */:
        case "time" /* Time */:
            return true;
        default:
            return false;
    }
}
exports.isPrimitiveTypeConstantKind = isPrimitiveTypeConstantKind;
function isTBinOpExpression(node) {
    switch (node.kind) {
        case "ArithmeticExpression" /* ArithmeticExpression */:
        case "AsExpression" /* AsExpression */:
        case "EqualityExpression" /* EqualityExpression */:
        case "IsExpression" /* IsExpression */:
        case "LogicalExpression" /* LogicalExpression */:
        case "MetadataExpression" /* MetadataExpression */:
        case "RelationalExpression" /* RelationalExpression */:
            return true;
        default:
            return false;
    }
}
exports.isTBinOpExpression = isTBinOpExpression;
function isPairedWrapperConstantKinds(x, y) {
    if (x.length !== 1 || y.length !== 1) {
        return false;
    }
    // If given x === ')' and y === '(', then swap positions.
    const low = x < y ? x : y;
    const high = low === x ? y : x;
    return ((low === "{" /* LeftBrace */ && high === "}" /* RightBrace */) ||
        (low === "[" /* LeftBracket */ && high === "]" /* RightBracket */) ||
        (low === "(" /* LeftParenthesis */ && high === ")" /* RightParenthesis */));
}
exports.isPairedWrapperConstantKinds = isPairedWrapperConstantKinds;
function testAnyNodeKind(value, allowedNodeKinds, details = undefined) {
    return allowedNodeKinds.indexOf(value) === -1
        ? new common_1.CommonError.InvariantError(`NodeKind value is not an allowed NodeKind value`, details)
        : undefined;
}
exports.testAnyNodeKind = testAnyNodeKind;
//# sourceMappingURL=astUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/index.js":
/*!*******************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const Ast = __webpack_require__(/*! ./ast */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/ast.js");
exports.Ast = Ast;
const AstUtils = __webpack_require__(/*! ./astUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/astUtils.js");
exports.AstUtils = AstUtils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/context.js":
/*!*************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/context.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/contextUtils.js":
/*!******************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/contextUtils.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const nodeIdMap_1 = __webpack_require__(/*! ../nodeIdMap */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js");
function newState() {
    return {
        root: {
            maybeNode: undefined,
        },
        nodeIdMapCollection: {
            astNodeById: new Map(),
            contextNodeById: new Map(),
            parentIdById: new Map(),
            childIdsById: new Map(),
            maybeRightMostLeaf: undefined,
        },
        idCounter: 0,
        leafNodeIds: [],
    };
}
exports.newState = newState;
function nextId(state) {
    state.idCounter += 1;
    return state.idCounter;
}
exports.nextId = nextId;
function nextAttributeIndex(parentNode) {
    const result = parentNode.attributeCounter;
    parentNode.attributeCounter += 1;
    return result;
}
exports.nextAttributeIndex = nextAttributeIndex;
function startContext(state, nodeKind, tokenIndexStart, maybeTokenStart, maybeParentNode) {
    const nodeIdMapCollection = state.nodeIdMapCollection;
    let maybeAttributeIndex;
    const nodeId = nextId(state);
    // If a parent context Node exists, update the parent/child mapping attributes and attributeCounter.
    if (maybeParentNode) {
        const childIdsById = nodeIdMapCollection.childIdsById;
        const parentNode = maybeParentNode;
        const parentId = parentNode.id;
        maybeAttributeIndex = nextAttributeIndex(parentNode);
        nodeIdMapCollection.parentIdById.set(nodeId, parentId);
        const maybeExistingChildren = childIdsById.get(parentId);
        if (maybeExistingChildren) {
            const existingChildren = maybeExistingChildren;
            childIdsById.set(parentId, [...existingChildren, nodeId]);
        }
        else {
            childIdsById.set(parentId, [nodeId]);
        }
    }
    const contextNode = {
        id: nodeId,
        kind: nodeKind,
        tokenIndexStart,
        maybeTokenStart,
        attributeCounter: 0,
        isClosed: false,
        maybeAttributeIndex,
    };
    nodeIdMapCollection.contextNodeById.set(nodeId, contextNode);
    if (state.root.maybeNode === undefined) {
        state.root.maybeNode = contextNode;
    }
    return contextNode;
}
exports.startContext = startContext;
// Returns the Node's parent context (if one exists).
function endContext(state, contextNode, astNode) {
    const nodeIdMapCollection = state.nodeIdMapCollection;
    contextNode.isClosed = true;
    if (astNode.isLeaf) {
        state.leafNodeIds.push(contextNode.id);
    }
    // Ending a context should return the context's parent node (if one exists).
    const maybeParentId = nodeIdMapCollection.parentIdById.get(contextNode.id);
    const maybeParentNode = maybeParentId !== undefined ? nodeIdMapCollection.contextNodeById.get(maybeParentId) : undefined;
    // Move nodeId from contextNodeMap to astNodeMap.
    if (!nodeIdMapCollection.contextNodeById.delete(contextNode.id)) {
        throw new common_1.CommonError.InvariantError("can't end a context that doesn't belong to state");
    }
    nodeIdMapCollection.astNodeById.set(astNode.id, astNode);
    // Update maybeRightMostLeaf when applicable
    if (astNode.isLeaf) {
        if (nodeIdMapCollection.maybeRightMostLeaf === undefined ||
            nodeIdMapCollection.maybeRightMostLeaf.tokenRange.tokenIndexStart < astNode.tokenRange.tokenIndexStart) {
            const unsafeNodeIdMapCollection = nodeIdMapCollection;
            unsafeNodeIdMapCollection.maybeRightMostLeaf = astNode;
        }
    }
    return maybeParentNode;
}
exports.endContext = endContext;
function deleteAst(state, nodeId, parentWillBeDeleted) {
    const nodeIdMapCollection = state.nodeIdMapCollection;
    const astNodeById = nodeIdMapCollection.astNodeById;
    const parentIdById = nodeIdMapCollection.parentIdById;
    const childIdsById = nodeIdMapCollection.childIdsById;
    if (!astNodeById.has(nodeId)) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`Ast nodeId not in state.`, details);
    }
    // If Node was a leaf node, remove it from the list of leaf nodes.
    removeLeafOrNoop(state, nodeId);
    const maybeParentId = parentIdById.get(nodeId);
    const maybeChildIds = childIdsById.get(nodeId);
    // Not a leaf node.
    if (maybeChildIds !== undefined) {
        const childIds = maybeChildIds;
        const details = {
            childIds,
            nodeId,
        };
        throw new common_1.CommonError.InvariantError(`Ast maybeChildIds !== undefined`, details);
    }
    // Is a leaf node, not root node.
    // Delete the node from the list of children under the node's parent.
    else if (maybeParentId) {
        const parentId = maybeParentId;
        if (astNodeById.has(parentId) && !parentWillBeDeleted) {
            const details = {
                parentId,
                nodeId,
            };
            throw new common_1.CommonError.InvariantError(`parent is a Ast node not marked for deletion`, details);
        }
        removeOrReplaceChildId(nodeIdMapCollection, parentId, nodeId, undefined);
    }
    // Else is root node, is leaf node.
    // No children updates need to be taken.
    // Remove the node from existence.
    astNodeById.delete(nodeId);
    childIdsById.delete(nodeId);
    parentIdById.delete(nodeId);
}
exports.deleteAst = deleteAst;
function deleteContext(state, nodeId) {
    const nodeIdMapCollection = state.nodeIdMapCollection;
    const contextNodeById = nodeIdMapCollection.contextNodeById;
    const parentIdById = nodeIdMapCollection.parentIdById;
    const childIdsById = nodeIdMapCollection.childIdsById;
    const maybeContextNode = contextNodeById.get(nodeId);
    if (maybeContextNode === undefined) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`Context nodeId not in state.`, details);
    }
    const contextNode = maybeContextNode;
    // If Node was a leaf node, remove it from the list of leaf nodes.
    removeLeafOrNoop(state, nodeId);
    const maybeParentId = parentIdById.get(nodeId);
    const maybeChildIds = childIdsById.get(nodeId);
    // Not a leaf node.
    if (maybeChildIds !== undefined) {
        const childIds = maybeChildIds;
        if (childIds.length !== 1) {
            const details = {
                childIds,
                nodeId,
            };
            throw new common_1.CommonError.InvariantError(`Context childIds.length !== 0`, details);
        }
        const childId = childIds[0];
        // Not a leaf node, is the Root node.
        // Promote the child to the root if it's a Context node.
        if (maybeParentId === undefined) {
            parentIdById.delete(childId);
            const maybeChildContext = contextNodeById.get(childId);
            if (maybeChildContext) {
                const childContext = maybeChildContext;
                state.root.maybeNode = childContext;
            }
        }
        // Not a leaf node, not the Root node.
        // Replace the node from the list of children under the node's parent using the node's child
        else {
            const parentId = maybeParentId;
            removeOrReplaceChildId(nodeIdMapCollection, parentId, nodeId, childId);
        }
        // The child Node inherits the attributeIndex.
        const childXorNode = nodeIdMap_1.NodeIdMapUtils.expectXorNode(state.nodeIdMapCollection, childId);
        const mutableChildXorNode = childXorNode.node;
        mutableChildXorNode.maybeAttributeIndex = contextNode.maybeAttributeIndex;
    }
    // Is a leaf node, not root node.
    // Delete the node from the list of children under the node's parent.
    else if (maybeParentId) {
        const parentId = maybeParentId;
        removeOrReplaceChildId(nodeIdMapCollection, parentId, nodeId, undefined);
    }
    // Else is root node, is leaf node.
    // No children updates need to be taken.
    // Remove the node from existence.
    contextNodeById.delete(nodeId);
    childIdsById.delete(nodeId);
    parentIdById.delete(nodeId);
    // Return the node's parent if it exits
    return maybeParentId !== undefined ? nodeIdMap_1.NodeIdMapUtils.expectContextNode(contextNodeById, maybeParentId) : undefined;
}
exports.deleteContext = deleteContext;
function removeLeafOrNoop(state, nodeId) {
    const leafNodeIds = state.leafNodeIds;
    const maybeLeafIndex = leafNodeIds.indexOf(nodeId);
    if (maybeLeafIndex !== -1) {
        const leafIndex = maybeLeafIndex;
        state.leafNodeIds = [...leafNodeIds.slice(0, leafIndex), ...leafNodeIds.slice(leafIndex + 1)];
    }
}
function removeOrReplaceChildId(nodeIdMapCollection, parentId, childId, maybeReplacementId) {
    const childIdsById = nodeIdMapCollection.childIdsById;
    const childIds = nodeIdMap_1.NodeIdMapUtils.expectChildIds(childIdsById, parentId);
    const replacementIndex = childIds.indexOf(childId);
    if (replacementIndex === -1) {
        const details = {
            parentId,
            childId,
        };
        throw new common_1.CommonError.InvariantError(`childId isn't a child of parentId`, details);
    }
    const beforeChildId = childIds.slice(0, replacementIndex);
    const afterChildId = childIds.slice(replacementIndex + 1);
    let maybeNewChildIds;
    if (maybeReplacementId) {
        const replacementId = maybeReplacementId;
        nodeIdMapCollection.parentIdById.set(replacementId, parentId);
        if (childIds.length === 1) {
            maybeNewChildIds = [replacementId];
        }
        else {
            maybeNewChildIds = [...beforeChildId, replacementId, ...afterChildId];
        }
    }
    else {
        if (childIds.length === 1) {
            maybeNewChildIds = undefined;
        }
        else {
            maybeNewChildIds = [...beforeChildId, ...afterChildId];
        }
    }
    if (maybeNewChildIds) {
        const newChildIds = maybeNewChildIds;
        childIdsById.set(parentId, newChildIds);
    }
    else {
        childIdsById.delete(parentId);
    }
    const maybeParent = nodeIdMapCollection.contextNodeById.get(parentId) || undefined;
    if (maybeParent !== undefined && maybeReplacementId === undefined) {
        maybeParent.attributeCounter -= 1;
    }
}
//# sourceMappingURL=contextUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/index.js":
/*!***********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const ParseContext = __webpack_require__(/*! ./context */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/context.js");
exports.ParseContext = ParseContext;
const ParseContextUtils = __webpack_require__(/*! ./contextUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/contextUtils.js");
exports.ParseContextUtils = ParseContextUtils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/error.js":
/*!***************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/error.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const localization_1 = __webpack_require__(/*! ../localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js");
class ParseError extends Error {
    constructor(innerError, state) {
        super(innerError.message);
        this.innerError = innerError;
        this.state = state;
    }
}
exports.ParseError = ParseError;
class ExpectedCsvContinuationError extends Error {
    constructor(templates, kind, maybeFoundToken) {
        super(localization_1.Localization.error_parse_csvContinuation(templates, kind));
        this.kind = kind;
        this.maybeFoundToken = maybeFoundToken;
    }
}
exports.ExpectedCsvContinuationError = ExpectedCsvContinuationError;
class ExpectedAnyTokenKindError extends Error {
    constructor(templates, expectedAnyTokenKinds, maybeFoundToken) {
        super(localization_1.Localization.error_parse_expectAnyTokenKind(templates, expectedAnyTokenKinds, maybeFoundToken));
        this.expectedAnyTokenKinds = expectedAnyTokenKinds;
        this.maybeFoundToken = maybeFoundToken;
    }
}
exports.ExpectedAnyTokenKindError = ExpectedAnyTokenKindError;
class ExpectedTokenKindError extends Error {
    constructor(templates, expectedTokenKind, maybeFoundToken) {
        super(localization_1.Localization.error_parse_expectTokenKind(templates, expectedTokenKind, maybeFoundToken));
        this.expectedTokenKind = expectedTokenKind;
        this.maybeFoundToken = maybeFoundToken;
    }
}
exports.ExpectedTokenKindError = ExpectedTokenKindError;
class ExpectedGeneralizedIdentifierError extends Error {
    constructor(templates, maybeFoundToken) {
        super(localization_1.Localization.error_parse_expectGeneralizedIdentifier(templates, maybeFoundToken));
        this.maybeFoundToken = maybeFoundToken;
    }
}
exports.ExpectedGeneralizedIdentifierError = ExpectedGeneralizedIdentifierError;
class InvalidPrimitiveTypeError extends Error {
    constructor(templates, token, positionStart) {
        super(localization_1.Localization.error_parse_invalidPrimitiveType(templates, token));
        this.token = token;
        this.positionStart = positionStart;
    }
}
exports.InvalidPrimitiveTypeError = InvalidPrimitiveTypeError;
class RequiredParameterAfterOptionalParameterError extends Error {
    constructor(templates, missingOptionalToken, positionStart) {
        super(localization_1.Localization.error_parse_requiredParameterAfterOptional(templates));
        this.missingOptionalToken = missingOptionalToken;
        this.positionStart = positionStart;
    }
}
exports.RequiredParameterAfterOptionalParameterError = RequiredParameterAfterOptionalParameterError;
class UnterminatedBracketError extends Error {
    constructor(templates, openBracketToken, positionStart) {
        super(localization_1.Localization.error_parse_unterminated_bracket(templates));
        this.openBracketToken = openBracketToken;
        this.positionStart = positionStart;
    }
}
exports.UnterminatedBracketError = UnterminatedBracketError;
class UnterminatedParenthesesError extends Error {
    constructor(templates, openParenthesesToken, positionStart) {
        super(localization_1.Localization.error_parse_unterminated_parenthesis(templates));
        this.openParenthesesToken = openParenthesesToken;
        this.positionStart = positionStart;
    }
}
exports.UnterminatedParenthesesError = UnterminatedParenthesesError;
class UnusedTokensRemainError extends Error {
    constructor(templates, firstUnusedToken, positionStart) {
        super(localization_1.Localization.error_parse_unusedTokens(templates));
        this.firstUnusedToken = firstUnusedToken;
        this.positionStart = positionStart;
    }
}
exports.UnusedTokensRemainError = UnusedTokensRemainError;
function isTParseError(x) {
    return x instanceof ParseError || x instanceof common_1.CommonError.CommonError;
}
exports.isTParseError = isTParseError;
function isTInnerParseError(x) {
    return (x instanceof ExpectedAnyTokenKindError ||
        x instanceof ExpectedCsvContinuationError ||
        x instanceof ExpectedGeneralizedIdentifierError ||
        x instanceof ExpectedTokenKindError ||
        x instanceof InvalidPrimitiveTypeError ||
        x instanceof RequiredParameterAfterOptionalParameterError ||
        x instanceof UnterminatedBracketError ||
        x instanceof UnterminatedParenthesesError ||
        x instanceof UnusedTokensRemainError);
}
exports.isTInnerParseError = isTInnerParseError;
function maybeTokenFrom(err) {
    if ((err instanceof ExpectedAnyTokenKindError ||
        err instanceof ExpectedCsvContinuationError ||
        err instanceof ExpectedGeneralizedIdentifierError ||
        err instanceof ExpectedTokenKindError) &&
        err.maybeFoundToken) {
        return err.maybeFoundToken.token;
    }
    else if (err instanceof InvalidPrimitiveTypeError) {
        return err.token;
    }
    else if (err instanceof RequiredParameterAfterOptionalParameterError) {
        return err.missingOptionalToken;
    }
    else if (err instanceof UnterminatedBracketError) {
        return err.openBracketToken;
    }
    else if (err instanceof UnterminatedParenthesesError) {
        return err.openParenthesesToken;
    }
    else if (err instanceof UnusedTokensRemainError) {
        return err.firstUnusedToken;
    }
    else {
        return undefined;
    }
}
exports.maybeTokenFrom = maybeTokenFrom;
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js":
/*!***************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ParseError = __webpack_require__(/*! ./error */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/error.js");
exports.ParseError = ParseError;
const Parser = __webpack_require__(/*! ./parsers */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/index.js");
exports.Parser = Parser;
__export(__webpack_require__(/*! ./ast */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/ast/index.js"));
__export(__webpack_require__(/*! ./context */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/context/index.js"));
__export(__webpack_require__(/*! ./IParser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParser.js"));
__export(__webpack_require__(/*! ./IParserState */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js"));
__export(__webpack_require__(/*! ./nodeIdMap */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js":
/*!*************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const NodeIdMap = __webpack_require__(/*! ./nodeIdMap */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMap.js");
exports.NodeIdMap = NodeIdMap;
const NodeIdMapUtils = __webpack_require__(/*! ./nodeIdMapUtils */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMapUtils.js");
exports.NodeIdMapUtils = NodeIdMapUtils;
__export(__webpack_require__(/*! ./xorNode */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/xorNode.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMap.js":
/*!*****************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMap.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=nodeIdMap.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMapUtils.js":
/*!**********************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/nodeIdMapUtils.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
function xorNodeFromAst(node) {
    return {
        kind: "Ast" /* Ast */,
        node,
    };
}
exports.xorNodeFromAst = xorNodeFromAst;
function xorNodeFromContext(node) {
    return {
        kind: "Context" /* Context */,
        node,
    };
}
exports.xorNodeFromContext = xorNodeFromContext;
function maybeXorNode(nodeIdMapCollection, nodeId) {
    const maybeAstNode = nodeIdMapCollection.astNodeById.get(nodeId);
    if (maybeAstNode) {
        const astNode = maybeAstNode;
        return {
            kind: "Ast" /* Ast */,
            node: astNode,
        };
    }
    const maybeContextNode = nodeIdMapCollection.contextNodeById.get(nodeId);
    if (maybeContextNode) {
        const contextNode = maybeContextNode;
        return {
            kind: "Context" /* Context */,
            node: contextNode,
        };
    }
    return undefined;
}
exports.maybeXorNode = maybeXorNode;
function maybeNthSiblingXorNode(nodeIdMapCollection, rootId, offset) {
    const childXorNode = expectXorNode(nodeIdMapCollection, rootId);
    if (childXorNode.node.maybeAttributeIndex === undefined) {
        return undefined;
    }
    const attributeIndex = childXorNode.node.maybeAttributeIndex + offset;
    if (attributeIndex < 0) {
        return undefined;
    }
    const parentXorNode = expectParentXorNode(nodeIdMapCollection, rootId, undefined);
    const childIds = expectChildIds(nodeIdMapCollection.childIdsById, parentXorNode.node.id);
    if (childIds.length >= attributeIndex) {
        return undefined;
    }
    return maybeXorNode(nodeIdMapCollection, childIds[attributeIndex]);
}
exports.maybeNthSiblingXorNode = maybeNthSiblingXorNode;
function maybeNextSiblingXorNode(nodeIdMapCollection, nodeId) {
    return maybeNthSiblingXorNode(nodeIdMapCollection, nodeId, 1);
}
exports.maybeNextSiblingXorNode = maybeNextSiblingXorNode;
function maybeParentXorNode(nodeIdMapCollection, childId, maybeAllowedNodeKinds = undefined) {
    const maybeAstNode = maybeParentAstNode(nodeIdMapCollection, childId, maybeAllowedNodeKinds);
    if (maybeAstNode !== undefined) {
        return xorNodeFromAst(maybeAstNode);
    }
    const maybeContextNode = maybeParentContextNode(nodeIdMapCollection, childId, maybeAllowedNodeKinds);
    if (maybeContextNode !== undefined) {
        return xorNodeFromContext(maybeContextNode);
    }
    return undefined;
}
exports.maybeParentXorNode = maybeParentXorNode;
function maybeParentAstNode(nodeIdMapCollection, childId, maybeAllowedNodeKinds = undefined) {
    const maybeParentId = nodeIdMapCollection.parentIdById.get(childId);
    if (maybeParentId === undefined) {
        return undefined;
    }
    const maybeParent = nodeIdMapCollection.astNodeById.get(maybeParentId);
    if (maybeParent === undefined) {
        return undefined;
    }
    const parent = maybeParent;
    if (maybeAllowedNodeKinds !== undefined && maybeAllowedNodeKinds.indexOf(parent.kind) === -1) {
        return undefined;
    }
    return parent;
}
exports.maybeParentAstNode = maybeParentAstNode;
function maybeParentContextNode(nodeIdMapCollection, childId, maybeAllowedNodeKinds = undefined) {
    const maybeParentId = nodeIdMapCollection.parentIdById.get(childId);
    if (maybeParentId === undefined) {
        return undefined;
    }
    const maybeParent = nodeIdMapCollection.contextNodeById.get(maybeParentId);
    if (maybeParent === undefined) {
        return undefined;
    }
    const parent = maybeParent;
    if (maybeAllowedNodeKinds !== undefined && maybeAllowedNodeKinds.indexOf(parent.kind) === -1) {
        return undefined;
    }
    return parent;
}
exports.maybeParentContextNode = maybeParentContextNode;
function maybeAstChildren(nodeIdMapCollection, parentId) {
    const maybeChildIds = nodeIdMapCollection.childIdsById.get(parentId);
    if (maybeChildIds === undefined) {
        return undefined;
    }
    const childIds = maybeChildIds;
    const astNodeById = nodeIdMapCollection.astNodeById;
    return childIds.map(childId => expectAstNode(astNodeById, childId));
}
exports.maybeAstChildren = maybeAstChildren;
// Both Ast.TNode and ParserContext.Node store an attribute index
// when defined represents which child index they are under for their parent.
//
// This function grabs the parent and if they have a child matching the attribute index it is returned as an XorNode.
// If the parent doesn't have a matching child that means (assuming a valid attributeIndex is given) the parent is
// a ParserContext.Node which failed to fully parse all of their attributes.
//
// An optional array of Ast.NodeKind can be given for validation purposes.
// If the child's node kind isn't in the given array, then an exception is thrown.
function maybeXorChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    // Grab the node's childIds.
    const maybeChildIds = nodeIdMapCollection.childIdsById.get(parentId);
    if (maybeChildIds === undefined) {
        return undefined;
    }
    const childIds = maybeChildIds;
    // Iterate over the children and try to find one which matches attributeIndex.
    for (const childId of childIds) {
        const xorNode = expectXorNode(nodeIdMapCollection, childId);
        if (xorNode.node.maybeAttributeIndex === attributeIndex) {
            // If a Ast.NodeKind is given, validate the Ast.TNode at the given index matches the Ast.NodeKind.
            if (maybeChildNodeKinds !== undefined && maybeChildNodeKinds.indexOf(xorNode.node.kind) === -1) {
                const details = {
                    childId,
                    expectedAny: maybeChildNodeKinds,
                    actual: xorNode.node.kind,
                };
                throw new common_1.CommonError.InvariantError(`incorrect node kind for attribute`, details);
            }
            else {
                return xorNode;
            }
        }
    }
    return undefined;
}
exports.maybeXorChildByAttributeIndex = maybeXorChildByAttributeIndex;
function maybeAstChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    const maybeNode = maybeXorChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds);
    if (maybeNode === undefined || maybeNode.kind === "Context" /* Context */) {
        return undefined;
    }
    else {
        return maybeNode.node;
    }
}
exports.maybeAstChildByAttributeIndex = maybeAstChildByAttributeIndex;
function maybeContextChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    const maybeNode = maybeXorChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds);
    if (maybeNode === undefined || maybeNode.kind === "Ast" /* Ast */) {
        return undefined;
    }
    else {
        return maybeNode.node;
    }
}
exports.maybeContextChildByAttributeIndex = maybeContextChildByAttributeIndex;
function maybeInvokeExpressionName(nodeIdMapCollection, nodeId) {
    const invokeExprXorNode = expectXorNode(nodeIdMapCollection, nodeId);
    if (invokeExprXorNode.node.kind !== "InvokeExpression" /* InvokeExpression */) {
        const details = { invokeExprXorNode };
        throw new common_1.CommonError.InvariantError(`expected invokeExprXorNode to have a Ast.NodeKind of ${"InvokeExpression" /* InvokeExpression */}`, details);
    }
    // The only place for an identifier in a RecursivePrimaryExpression is as the head, therefore an InvokeExpression
    // only has a name if the InvokeExpression is the 0th element in the RecursivePrimaryExpressionArray.
    let maybeName;
    if (invokeExprXorNode.node.maybeAttributeIndex === 0) {
        // Grab the RecursivePrimaryExpression's head if it's an IdentifierExpression
        const recursiveArrayXorNode = expectParentXorNode(nodeIdMapCollection, invokeExprXorNode.node.id);
        const recursiveExprXorNode = expectParentXorNode(nodeIdMapCollection, recursiveArrayXorNode.node.id);
        const headXorNode = expectXorChildByAttributeIndex(nodeIdMapCollection, recursiveExprXorNode.node.id, 0, undefined);
        if (headXorNode.node.kind === "IdentifierExpression" /* IdentifierExpression */) {
            if (headXorNode.kind !== "Ast" /* Ast */) {
                const details = {
                    identifierExpressionNodeId: headXorNode.node.id,
                    invokeExpressionNodeId: invokeExprXorNode.node.id,
                };
                throw new common_1.CommonError.InvariantError(`the younger IdentifierExpression sibling should've finished parsing before the InvokeExpression node was reached`, details);
            }
            const identifierExpression = headXorNode.node;
            maybeName =
                identifierExpression.maybeInclusiveConstant === undefined
                    ? identifierExpression.identifier.literal
                    : identifierExpression.maybeInclusiveConstant.constantKind +
                        identifierExpression.identifier.literal;
        }
    }
    return maybeName;
}
exports.maybeInvokeExpressionName = maybeInvokeExpressionName;
function expectAstNode(astNodeById, nodeId) {
    return expectInMap(astNodeById, nodeId, "astNodeById");
}
exports.expectAstNode = expectAstNode;
function expectContextNode(contextNodeById, nodeId) {
    return expectInMap(contextNodeById, nodeId, "contextNodeById");
}
exports.expectContextNode = expectContextNode;
function expectXorNode(nodeIdMapCollection, nodeId) {
    const maybeNode = maybeXorNode(nodeIdMapCollection, nodeId);
    if (maybeNode === undefined) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`nodeId wasn't an astNode nor contextNode`, details);
    }
    return maybeNode;
}
exports.expectXorNode = expectXorNode;
function expectParentXorNode(nodeIdMapCollection, nodeId, maybeAllowedNodeKinds = undefined) {
    const maybeNode = maybeParentXorNode(nodeIdMapCollection, nodeId, maybeAllowedNodeKinds);
    if (maybeNode === undefined) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`nodeId doesn't have a parent`, details);
    }
    return maybeNode;
}
exports.expectParentXorNode = expectParentXorNode;
function expectParentAstNode(nodeIdMapCollection, nodeId, maybeAllowedNodeKinds = undefined) {
    const maybeNode = maybeParentAstNode(nodeIdMapCollection, nodeId, maybeAllowedNodeKinds);
    if (maybeNode === undefined) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`nodeId doesn't have a parent`, details);
    }
    return maybeNode;
}
exports.expectParentAstNode = expectParentAstNode;
function expectXorChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    const maybeNode = maybeXorChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds);
    if (maybeNode === undefined) {
        const details = { parentId, attributeIndex };
        throw new common_1.CommonError.InvariantError(`parentId doesn't have a child at the given index`, details);
    }
    return maybeNode;
}
exports.expectXorChildByAttributeIndex = expectXorChildByAttributeIndex;
function expectAstChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    const maybeNode = maybeAstChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds);
    if (maybeNode === undefined) {
        const details = { parentId, attributeIndex };
        throw new common_1.CommonError.InvariantError(`parentId doesn't have an Ast child at the given index`, details);
    }
    return maybeNode;
}
exports.expectAstChildByAttributeIndex = expectAstChildByAttributeIndex;
function expectContextChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds) {
    const maybeNode = maybeContextChildByAttributeIndex(nodeIdMapCollection, parentId, attributeIndex, maybeChildNodeKinds);
    if (maybeNode === undefined) {
        const details = { parentId, attributeIndex };
        throw new common_1.CommonError.InvariantError(`parentId doesn't have a context child at the given index`, details);
    }
    return maybeNode;
}
exports.expectContextChildByAttributeIndex = expectContextChildByAttributeIndex;
function expectXorNodes(nodeIdMapCollection, nodeIds) {
    return nodeIds.map(nodeId => expectXorNode(nodeIdMapCollection, nodeId));
}
exports.expectXorNodes = expectXorNodes;
function expectChildIds(childIdsById, nodeId) {
    return expectInMap(childIdsById, nodeId, "childIdsById");
}
exports.expectChildIds = expectChildIds;
function expectAstChildren(nodeIdMapCollection, parentId) {
    const astNodeById = nodeIdMapCollection.astNodeById;
    return expectChildIds(nodeIdMapCollection.childIdsById, parentId).map(childId => expectAstNode(astNodeById, childId));
}
exports.expectAstChildren = expectAstChildren;
function expectXorChildren(nodeIdMapCollection, parentId) {
    const maybeChildIds = nodeIdMapCollection.childIdsById.get(parentId);
    if (maybeChildIds === undefined) {
        return [];
    }
    const childIds = maybeChildIds;
    return expectXorNodes(nodeIdMapCollection, childIds);
}
exports.expectXorChildren = expectXorChildren;
// There are a few assumed invariants about children:
//  * Children are read left to right.
//  * Children are placed in childIdsById in the order they were read.
//  * Therefore the right-most child is the most recently read which also appears last in the document.
function maybeRightMostLeaf(nodeIdMapCollection, rootId, maybeCondition = undefined) {
    const astNodeById = nodeIdMapCollection.astNodeById;
    let nodeIdsToExplore = [rootId];
    let maybeRightMost;
    while (nodeIdsToExplore.length) {
        const nodeId = nodeIdsToExplore.pop();
        const maybeAstNode = astNodeById.get(nodeId);
        let addChildren = false;
        // Check if Ast.TNode or ParserContext.Node
        if (maybeAstNode !== undefined) {
            const astNode = maybeAstNode;
            if (maybeCondition && !maybeCondition(astNode)) {
                continue;
            }
            // Is leaf, check if it's more right than the previous record.
            // As it's a leaf there are no children to add.
            if (astNode.isLeaf) {
                // Is the first leaf encountered.
                if (maybeRightMost === undefined) {
                    maybeRightMost = astNode;
                }
                // Compare current leaf node to the existing record.
                else if (astNode.tokenRange.tokenIndexStart > maybeRightMost.tokenRange.tokenIndexStart) {
                    maybeRightMost = astNode;
                }
            }
            // Is not a leaf, no previous record exists.
            // Add all children to the queue.
            else if (maybeRightMost === undefined) {
                addChildren = true;
            }
            // Is not a leaf, previous record exists.
            // Check if we can cull the branch, otherwise add all children to the queue.
            else if (astNode.tokenRange.tokenIndexEnd > maybeRightMost.tokenRange.tokenIndexStart) {
                addChildren = true;
            }
        }
        // Must be a ParserContext.Node.
        // Add all children to the queue as ParserContext.Nodes can have Ast children which are leafs.
        else {
            addChildren = true;
        }
        if (addChildren) {
            const maybeChildIds = nodeIdMapCollection.childIdsById.get(nodeId);
            if (maybeChildIds !== undefined) {
                // Add the child ids in reversed order to prioritize visiting the right most nodes first.
                const childIds = maybeChildIds;
                const reversedChildIds = [...childIds];
                reversedChildIds.reverse();
                nodeIdsToExplore = [...reversedChildIds, ...nodeIdsToExplore];
            }
        }
    }
    return maybeRightMost;
}
exports.maybeRightMostLeaf = maybeRightMostLeaf;
function maybeRightMostLeafWhere(nodeIdMapCollection, rootId, maybeCondition) {
    return maybeRightMostLeaf(nodeIdMapCollection, rootId, maybeCondition);
}
exports.maybeRightMostLeafWhere = maybeRightMostLeafWhere;
function leftMostXorNode(nodeIdMapCollection, rootId) {
    let currentNode = expectXorNode(nodeIdMapCollection, rootId);
    let potentialNode = expectXorChildByAttributeIndex(nodeIdMapCollection, currentNode.node.id, 0, undefined);
    while (potentialNode !== undefined) {
        currentNode = potentialNode;
        potentialNode = expectXorChildByAttributeIndex(nodeIdMapCollection, currentNode.node.id, 0, undefined);
    }
    return currentNode;
}
exports.leftMostXorNode = leftMostXorNode;
function isTUnaryType(xorNode) {
    return xorNode.node.kind === "UnaryExpression" /* UnaryExpression */ || isTTypeExpression(xorNode);
}
exports.isTUnaryType = isTUnaryType;
function isTTypeExpression(xorNode) {
    return xorNode.node.kind === "TypePrimaryType" /* TypePrimaryType */ || isTPrimaryExpression(xorNode);
}
exports.isTTypeExpression = isTTypeExpression;
function isTPrimaryExpression(xorNode) {
    switch (xorNode.node.kind) {
        case "LiteralExpression" /* LiteralExpression */:
        case "ListExpression" /* ListExpression */:
        case "RecordExpression" /* RecordExpression */:
        case "IdentifierExpression" /* IdentifierExpression */:
        case "ParenthesizedExpression" /* ParenthesizedExpression */:
        case "InvokeExpression" /* InvokeExpression */:
        case "RecursivePrimaryExpression" /* RecursivePrimaryExpression */:
        case "NotImplementedExpression" /* NotImplementedExpression */:
            return true;
        default:
            return isTFieldAccessExpression(xorNode);
    }
}
exports.isTPrimaryExpression = isTPrimaryExpression;
function isTFieldAccessExpression(xorNode) {
    return xorNode.node.kind === "FieldSelector" /* FieldSelector */ || xorNode.node.kind === "FieldProjection" /* FieldProjection */;
}
exports.isTFieldAccessExpression = isTFieldAccessExpression;
function expectAncestry(nodeIdMapCollection, rootId) {
    const ancestryIds = [rootId];
    let maybeParentId = nodeIdMapCollection.parentIdById.get(rootId);
    while (maybeParentId) {
        const parentId = maybeParentId;
        ancestryIds.push(parentId);
        maybeParentId = nodeIdMapCollection.parentIdById.get(parentId);
    }
    return expectXorNodes(nodeIdMapCollection, ancestryIds);
}
exports.expectAncestry = expectAncestry;
function xorNodeTokenRange(nodeIdMapCollection, xorNode) {
    switch (xorNode.kind) {
        case "Ast" /* Ast */: {
            const tokenRange = xorNode.node.tokenRange;
            return {
                tokenIndexStart: tokenRange.tokenIndexStart,
                tokenIndexEnd: tokenRange.tokenIndexEnd,
            };
        }
        case "Context" /* Context */: {
            const contextNode = xorNode.node;
            let tokenIndexEnd;
            const maybeRightMostChild = maybeRightMostLeaf(nodeIdMapCollection, xorNode.node.id);
            if (maybeRightMostChild === undefined) {
                tokenIndexEnd = contextNode.tokenIndexStart;
            }
            else {
                const rightMostChild = maybeRightMostChild;
                tokenIndexEnd = rightMostChild.tokenRange.tokenIndexEnd;
            }
            return {
                tokenIndexStart: contextNode.tokenIndexStart,
                tokenIndexEnd,
            };
        }
        default:
            throw common_1.isNever(xorNode);
    }
}
exports.xorNodeTokenRange = xorNodeTokenRange;
function expectInMap(map, nodeId, mapName) {
    const maybeValue = map.get(nodeId);
    if (maybeValue === undefined) {
        const details = { nodeId };
        throw new common_1.CommonError.InvariantError(`nodeId wasn't in ${mapName}`, details);
    }
    return maybeValue;
}
//# sourceMappingURL=nodeIdMapUtils.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/xorNode.js":
/*!***************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/xorNode.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=xorNode.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/combinatorialParser.js":
/*!*************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/combinatorialParser.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/index.js");
const __1 = __webpack_require__(/*! .. */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const IParserState_1 = __webpack_require__(/*! ../IParserState */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js");
const common_2 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/common.js");
// If the Naive parser were to parse the expression '1' it would need to recurse down a dozen or so constructs,
// which at each step would create a new context node, parse LiteralExpression, then traverse back up while
// cleaning the no-op context nodes along the way. Two key optimizations are used to prevent that.
//
// 1)
// The reading of binary expressions (expressions linked by TBinOpExpressionOperator) has been flattened.
// A TUnaryExpression read first, then while a TBinOpExpressionOperator is next it will read the operator
// constant and then the right hand of the TBinOpExpression. All expressions erad will be placed in a flat list.
// Once no more expressions can be read the flat list will be shaped into a proper Ast.
// This eliminates several no-op functions calls on the call stack when reading a bare TUnaryExpression (eg. `1`).
//
// 2)
// readUnaryExpression uses limited look ahead to eliminate several function calls on the call stack.
exports.CombinatorialParser = {
    // 12.1.6 Identifiers
    readIdentifier: _1.Naive.readIdentifier,
    readGeneralizedIdentifier: _1.Naive.readGeneralizedIdentifier,
    readKeyword: _1.Naive.readKeyword,
    // 12.2.1 Documents
    readDocument: _1.Naive.readDocument,
    // 12.2.2 Section Documents
    readSectionDocument: _1.Naive.readSectionDocument,
    readSectionMembers: _1.Naive.readSectionMembers,
    readSectionMember: _1.Naive.readSectionMember,
    // 12.2.3.1 Expressions
    readExpression: _1.Naive.readExpression,
    // 12.2.3.2 Logical expressions
    readLogicalExpression,
    // 12.2.3.3 Is expression
    readIsExpression,
    readNullablePrimitiveType: _1.Naive.readNullablePrimitiveType,
    // 12.2.3.4 As expression
    readAsExpression,
    // 12.2.3.5 Equality expression
    readEqualityExpression,
    // 12.2.3.6 Relational expression
    readRelationalExpression,
    // 12.2.3.7 Arithmetic expressions
    readArithmeticExpression,
    // 12.2.3.8 Metadata expression
    readMetadataExpression,
    // 12.2.3.9 Unary expression
    readUnaryExpression,
    // 12.2.3.10 Primary expression
    readPrimaryExpression: _1.Naive.readPrimaryExpression,
    readRecursivePrimaryExpression: _1.Naive.readRecursivePrimaryExpression,
    // 12.2.3.11 Literal expression
    readLiteralExpression: _1.Naive.readLiteralExpression,
    // 12.2.3.12 Identifier expression
    readIdentifierExpression: _1.Naive.readIdentifierExpression,
    // 12.2.3.14 Parenthesized expression
    readParenthesizedExpression: _1.Naive.readParenthesizedExpression,
    // 12.2.3.15 Not-implemented expression
    readNotImplementedExpression: _1.Naive.readNotImplementedExpression,
    // 12.2.3.16 Invoke expression
    readInvokeExpression: _1.Naive.readInvokeExpression,
    // 12.2.3.17 List expression
    readListExpression: _1.Naive.readListExpression,
    readListItem: _1.Naive.readListItem,
    // 12.2.3.18 Record expression
    readRecordExpression: _1.Naive.readRecordExpression,
    // 12.2.3.19 Item access expression
    readItemAccessExpression: _1.Naive.readItemAccessExpression,
    // 12.2.3.20 Field access expression
    readFieldSelection: _1.Naive.readFieldSelection,
    readFieldProjection: _1.Naive.readFieldProjection,
    readFieldSelector: _1.Naive.readFieldSelector,
    // 12.2.3.21 Function expression
    readFunctionExpression: _1.Naive.readFunctionExpression,
    readParameterList: _1.Naive.readParameterList,
    readAsType: _1.Naive.readAsType,
    // 12.2.3.22 Each expression
    readEachExpression: _1.Naive.readEachExpression,
    // 12.2.3.23 Let expression
    readLetExpression: _1.Naive.readLetExpression,
    // 12.2.3.24 If expression
    readIfExpression: _1.Naive.readIfExpression,
    // 12.2.3.25 Type expression
    readTypeExpression: _1.Naive.readTypeExpression,
    readType: _1.Naive.readType,
    readPrimaryType: _1.Naive.readPrimaryType,
    readRecordType: _1.Naive.readRecordType,
    readTableType: _1.Naive.readTableType,
    readFieldSpecificationList: _1.Naive.readFieldSpecificationList,
    readListType: _1.Naive.readListType,
    readFunctionType: _1.Naive.readFunctionType,
    readParameterSpecificationList: _1.Naive.readParameterSpecificationList,
    readNullableType: _1.Naive.readNullableType,
    // 12.2.3.26 Error raising expression
    readErrorRaisingExpression: _1.Naive.readErrorRaisingExpression,
    // 12.2.3.27 Error handling expression
    readErrorHandlingExpression: _1.Naive.readErrorHandlingExpression,
    // 12.2.4 Literal Attributes
    readRecordLiteral: _1.Naive.readRecordLiteral,
    readFieldNamePairedAnyLiterals: _1.Naive.readFieldNamePairedAnyLiterals,
    readListLiteral: _1.Naive.readListLiteral,
    readAnyLiteral: _1.Naive.readAnyLiteral,
    readPrimitiveType: _1.Naive.readPrimitiveType,
    // Disambiguation
    disambiguateBracket: _1.Naive.disambiguateBracket,
    disambiguateParenthesis: _1.Naive.disambiguateParenthesis,
    // key-value pairs
    readIdentifierPairedExpressions: _1.Naive.readIdentifierPairedExpressions,
    readIdentifierPairedExpression: _1.Naive.readIdentifierPairedExpression,
    readGeneralizedIdentifierPairedExpressions: _1.Naive.readGeneralizedIdentifierPairedExpressions,
    readGeneralizedIdentifierPairedExpression: _1.Naive.readGeneralizedIdentifierPairedExpression,
};
function readLogicalExpression(state, parser) {
    return readBinOpExpression(state, parser, "LogicalExpression" /* LogicalExpression */);
}
function readIsExpression(state, parser) {
    return readBinOpExpression(state, parser, "IsExpression" /* IsExpression */);
}
function readAsExpression(state, parser) {
    return readBinOpExpression(state, parser, "AsExpression" /* AsExpression */);
}
function readEqualityExpression(state, parser) {
    return readBinOpExpression(state, parser, "EqualityExpression" /* EqualityExpression */);
}
function readRelationalExpression(state, parser) {
    return readBinOpExpression(state, parser, "RelationalExpression" /* RelationalExpression */);
}
function readArithmeticExpression(state, parser) {
    return readBinOpExpression(state, parser, "ArithmeticExpression" /* ArithmeticExpression */);
}
function readMetadataExpression(state, parser) {
    return readBinOpExpression(state, parser, "MetadataExpression" /* MetadataExpression */);
}
function readBinOpExpression(state, parser, nodeKind) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const placeholderContextId = state.maybeCurrentContextNode.id;
    // operators/operatorConstants are of length N
    // expressions are of length N + 1
    let operators = [];
    let operatorConstants = [];
    let expressions = [
        parser.readUnaryExpression(state, parser),
    ];
    let maybeOperator = __1.AstUtils.maybeBinOpExpressionOperatorKindFrom(state.maybeCurrentTokenKind);
    while (maybeOperator !== undefined) {
        const operator = maybeOperator;
        operators.push(operator);
        operatorConstants.push(common_2.readTokenKindAsConstant(state, state.maybeCurrentTokenKind, maybeOperator));
        switch (operator) {
            case "as" /* As */:
            case "is" /* Is */:
                expressions.push(parser.readNullablePrimitiveType(state, parser));
                break;
            default:
                expressions.push(parser.readUnaryExpression(state, parser));
                break;
        }
        maybeOperator = __1.AstUtils.maybeBinOpExpressionOperatorKindFrom(state.maybeCurrentTokenKind);
    }
    // There was a single TUnaryExpression, not a TBinOpExpression.
    if (expressions.length === 1) {
        IParserState_1.IParserStateUtils.deleteContext(state, placeholderContextId);
        return expressions[0];
    }
    // Build up the Ast by using the lowest precedence operator and the two adjacent expressions,
    // which might be previously built TBinOpExpression nodes.
    const nodeIdMapCollection = state.contextState.nodeIdMapCollection;
    const newNodeThreshold = state.contextState.idCounter;
    let placeholderContextChildren = nodeIdMapCollection.childIdsById.get(placeholderContextId);
    while (operators.length) {
        let minPrecedenceIndex = -1;
        let minPrecedence = Number.MAX_SAFE_INTEGER;
        for (let index = 0; index < operators.length; index += 1) {
            const currentPrecedence = __1.AstUtils.binOpExpressionOperatorPrecedence(operators[index]);
            if (minPrecedence > currentPrecedence) {
                minPrecedence = currentPrecedence;
                minPrecedenceIndex = index;
            }
        }
        const newBinOpExpressionId = __1.ParseContextUtils.nextId(state.contextState);
        const left = expressions[minPrecedenceIndex];
        const operator = operators[minPrecedenceIndex];
        const operatorConstant = operatorConstants[minPrecedenceIndex];
        const right = expressions[minPrecedenceIndex + 1];
        left.maybeAttributeIndex = 0;
        operatorConstant.maybeAttributeIndex = 1;
        right.maybeAttributeIndex = 2;
        const leftTokenRange = left.tokenRange;
        const rightTokenRange = right.tokenRange;
        const newBinOpExpression = {
            kind: binOpExpressionNodeKindFrom(operator),
            id: newBinOpExpressionId,
            // maybeAttributeIndex is fixed after all TBinOpExpressions have been created.
            maybeAttributeIndex: 0,
            tokenRange: {
                tokenIndexStart: leftTokenRange.tokenIndexStart,
                tokenIndexEnd: rightTokenRange.tokenIndexEnd,
                positionStart: leftTokenRange.positionStart,
                positionEnd: rightTokenRange.positionEnd,
            },
            isLeaf: false,
            left: left,
            operator,
            operatorConstant,
            right,
        };
        operators = common_1.ArrayUtils.removeAtIndex(operators, minPrecedenceIndex);
        operatorConstants = common_1.ArrayUtils.removeAtIndex(operatorConstants, minPrecedenceIndex);
        expressions = expressions = [
            ...expressions.slice(0, minPrecedenceIndex),
            newBinOpExpression,
            ...expressions.slice(minPrecedenceIndex + 2),
        ];
        // Correct the parentIds for the nodes combined into newBinOpExpression.
        nodeIdMapCollection.parentIdById.set(left.id, newBinOpExpressionId);
        nodeIdMapCollection.parentIdById.set(operatorConstant.id, newBinOpExpressionId);
        nodeIdMapCollection.parentIdById.set(right.id, newBinOpExpressionId);
        // Assign the nodeIdMap values for newBinOpExpression.
        nodeIdMapCollection.childIdsById.set(newBinOpExpressionId, [left.id, operatorConstant.id, right.id]);
        nodeIdMapCollection.astNodeById.set(newBinOpExpressionId, newBinOpExpression);
        // All TUnaryExpression and operatorConstants start by being placed under the context node.
        // They need to be removed for deleteContext(placeholderContextId) to succeed.
        placeholderContextChildren = common_1.ArrayUtils.removeFirstInstance(placeholderContextChildren, operatorConstant.id);
        if (left.id <= newNodeThreshold) {
            placeholderContextChildren = common_1.ArrayUtils.removeFirstInstance(placeholderContextChildren, left.id);
        }
        if (right.id <= newNodeThreshold) {
            placeholderContextChildren = common_1.ArrayUtils.removeFirstInstance(placeholderContextChildren, right.id);
        }
        nodeIdMapCollection.childIdsById.set(placeholderContextId, placeholderContextChildren);
    }
    const lastExpression = expressions[0];
    if (!__1.AstUtils.isTBinOpExpression(lastExpression)) {
        const details = {
            lastExpressionId: lastExpression.id,
            lastExpressionKind: lastExpression.kind,
        };
        throw new common_1.CommonError.InvariantError(`lastExpression should be a TBinOpExpression`, details);
    }
    nodeIdMapCollection.childIdsById.set(placeholderContextId, [lastExpression.id]);
    nodeIdMapCollection.parentIdById.set(lastExpression.id, placeholderContextId);
    IParserState_1.IParserStateUtils.deleteContext(state, placeholderContextId);
    return lastExpression;
}
function binOpExpressionNodeKindFrom(operator) {
    switch (operator) {
        case "meta" /* Meta */:
            return "MetadataExpression" /* MetadataExpression */;
        case "*" /* Multiplication */:
        case "/" /* Division */:
        case "+" /* Addition */:
        case "-" /* Subtraction */:
        case "&" /* And */:
            return "ArithmeticExpression" /* ArithmeticExpression */;
        case ">" /* GreaterThan */:
        case ">=" /* GreaterThanEqualTo */:
        case "<" /* LessThan */:
        case "<=" /* LessThanEqualTo */:
            return "RelationalExpression" /* RelationalExpression */;
        case "=" /* EqualTo */:
        case "<>" /* NotEqualTo */:
            return "EqualityExpression" /* EqualityExpression */;
        case "as" /* As */:
            return "AsExpression" /* AsExpression */;
        case "is" /* Is */:
            return "IsExpression" /* IsExpression */;
        case "and" /* And */:
        case "or" /* Or */:
            return "LogicalExpression" /* LogicalExpression */;
        default:
            throw common_1.isNever(operator);
    }
}
function readUnaryExpression(state, parser) {
    let maybePrimaryExpression;
    // LL(1)
    switch (state.maybeCurrentTokenKind) {
        // PrimaryExpression
        case "AtSign" /* AtSign */:
        case "Identifier" /* Identifier */:
            maybePrimaryExpression = _1.Naive.readIdentifierExpression(state, parser);
            break;
        case "LeftParenthesis" /* LeftParenthesis */:
            maybePrimaryExpression = _1.Naive.readParenthesizedExpression(state, parser);
            break;
        case "LeftBracket" /* LeftBracket */:
            maybePrimaryExpression = common_2.readBracketDisambiguation(state, parser, [
                "FieldProjection" /* FieldProjection */,
                "FieldSelection" /* FieldSelection */,
                "Record" /* Record */,
            ]);
            break;
        case "LeftBrace" /* LeftBrace */:
            maybePrimaryExpression = _1.Naive.readListExpression(state, parser);
            break;
        case "Ellipsis" /* Ellipsis */:
            maybePrimaryExpression = _1.Naive.readNotImplementedExpression(state, parser);
            break;
        // LiteralExpression
        case "HexLiteral" /* HexLiteral */:
        case "KeywordFalse" /* KeywordFalse */:
        case "KeywordTrue" /* KeywordTrue */:
        case "NumericLiteral" /* NumericLiteral */:
        case "NullLiteral" /* NullLiteral */:
        case "StringLiteral" /* StringLiteral */:
            return _1.Naive.readLiteralExpression(state, parser);
        // TypeExpression
        case "KeywordType" /* KeywordType */:
            return _1.Naive.readTypeExpression(state, parser);
        case "KeywordHashSections" /* KeywordHashSections */:
        case "KeywordHashShared" /* KeywordHashShared */:
        case "KeywordHashBinary" /* KeywordHashBinary */:
        case "KeywordHashDate" /* KeywordHashDate */:
        case "KeywordHashDateTime" /* KeywordHashDateTime */:
        case "KeywordHashDateTimeZone" /* KeywordHashDateTimeZone */:
        case "KeywordHashDuration" /* KeywordHashDuration */:
        case "KeywordHashTable" /* KeywordHashTable */:
        case "KeywordHashTime" /* KeywordHashTime */:
            maybePrimaryExpression = parser.readKeyword(state, parser);
            break;
        // Let Naive throw an error.
        default:
            return _1.Naive.readUnaryExpression(state, parser);
    }
    // We should only reach this code block if a primary expression was read.
    const primaryExpression = maybePrimaryExpression;
    if (IParserState_1.IParserStateUtils.isRecursivePrimaryExpressionNext(state, state.tokenIndex)) {
        return parser.readRecursivePrimaryExpression(state, parser, primaryExpression);
    }
    else {
        return primaryExpression;
    }
}
//# sourceMappingURL=combinatorialParser.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/common.js":
/*!************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/common.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const IParserState_1 = __webpack_require__(/*! ../IParserState */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js");
function readToken(state) {
    const tokens = state.lexerSnapshot.tokens;
    if (state.tokenIndex >= tokens.length) {
        const details = {
            tokenIndex: state.tokenIndex,
            "tokens.length": tokens.length,
        };
        throw new common_1.CommonError.InvariantError("index beyond tokens.length", details);
    }
    const data = tokens[state.tokenIndex].data;
    state.tokenIndex += 1;
    if (state.tokenIndex === tokens.length) {
        state.maybeCurrentTokenKind = undefined;
    }
    else {
        state.maybeCurrentToken = tokens[state.tokenIndex];
        state.maybeCurrentTokenKind = state.maybeCurrentToken.kind;
    }
    return data;
}
exports.readToken = readToken;
function readTokenKindAsConstant(state, tokenKind, constantKind) {
    IParserState_1.IParserStateUtils.startContext(state, "Constant" /* Constant */);
    const maybeErr = IParserState_1.IParserStateUtils.testIsOnTokenKind(state, tokenKind);
    if (maybeErr !== undefined) {
        throw maybeErr;
    }
    const tokenData = readToken(state);
    if (tokenData !== constantKind) {
        const details = {
            tokenData,
            constantKind,
        };
        throw new common_1.CommonError.InvariantError("expected tokenData to be equal to constantKind", details);
    }
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: "Constant" /* Constant */, isLeaf: true, constantKind });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readTokenKindAsConstant = readTokenKindAsConstant;
function maybeReadTokenKindAsConstant(state, tokenKind, constantKind) {
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, tokenKind)) {
        const nodeKind = "Constant" /* Constant */;
        IParserState_1.IParserStateUtils.startContext(state, nodeKind);
        const tokenData = readToken(state);
        if (tokenData !== constantKind) {
            const details = {
                tokenData,
                constantKind,
            };
            throw new common_1.CommonError.InvariantError("expected tokenData to be equal to constantKind", details);
        }
        const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: true, constantKind });
        IParserState_1.IParserStateUtils.endContext(state, astNode);
        return astNode;
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
        return undefined;
    }
}
exports.maybeReadTokenKindAsConstant = maybeReadTokenKindAsConstant;
function readBracketDisambiguation(state, parser, allowedVariants) {
    const triedDisambiguation = parser.disambiguateBracket(state, parser);
    if (common_1.ResultUtils.isErr(triedDisambiguation)) {
        throw triedDisambiguation.error;
    }
    const disambiguation = triedDisambiguation.value;
    if (allowedVariants.indexOf(disambiguation) === -1) {
        throw new common_1.CommonError.InvariantError(`grammar doesn't allow remaining BracketDisambiguation: ${disambiguation}`);
    }
    switch (disambiguation) {
        case "FieldProjection" /* FieldProjection */:
            return parser.readFieldProjection(state, parser);
        case "FieldSelection" /* FieldSelection */:
            return parser.readFieldSelection(state, parser);
        case "Record" /* Record */:
            return parser.readRecordExpression(state, parser);
        default:
            throw common_1.isNever(disambiguation);
    }
}
exports.readBracketDisambiguation = readBracketDisambiguation;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/index.js":
/*!***********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const Naive = __webpack_require__(/*! ./naive */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/naive.js");
exports.Naive = Naive;
var combinatorialParser_1 = __webpack_require__(/*! ./combinatorialParser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/combinatorialParser.js");
exports.CombinatorialParser = combinatorialParser_1.CombinatorialParser;
var recursiveDescentParser_1 = __webpack_require__(/*! ./recursiveDescentParser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/recursiveDescentParser.js");
exports.RecursiveDescentParser = recursiveDescentParser_1.RecursiveDescentParser;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/naive.js":
/*!***********************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/naive.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = __webpack_require__(/*! .. */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const IParserState_1 = __webpack_require__(/*! ../IParserState */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/IParserState/index.js");
const nodeIdMap_1 = __webpack_require__(/*! ../nodeIdMap */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/nodeIdMap/index.js");
const common_2 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/common.js");
const GeneralizedIdentifierTerminatorTokenKinds = [
    "Comma" /* Comma */,
    "Equal" /* Equal */,
    "RightBracket" /* RightBracket */,
];
// -------------------------------------------
// ---------- // 12.1.6 Identifiers ----------
// -------------------------------------------
function readIdentifier(state, _parser) {
    const nodeKind = "Identifier" /* Identifier */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const literal = readTokenKind(state, "Identifier" /* Identifier */);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: true, literal });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readIdentifier = readIdentifier;
// This behavior matches the C# parser and not the language specification.
function readGeneralizedIdentifier(state, _parser) {
    const nodeKind = "GeneralizedIdentifier" /* GeneralizedIdentifier */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    let literal;
    let astNode;
    const tokenRangeStartIndex = state.tokenIndex;
    let tokenRangeEndIndex = tokenRangeStartIndex;
    while (state.maybeCurrentTokenKind &&
        GeneralizedIdentifierTerminatorTokenKinds.indexOf(state.maybeCurrentTokenKind) === -1) {
        common_2.readToken(state);
        tokenRangeEndIndex = state.tokenIndex;
    }
    if (tokenRangeStartIndex === tokenRangeEndIndex) {
        throw new __1.ParseError.ExpectedGeneralizedIdentifierError(state.localizationTemplates, IParserState_1.IParserStateUtils.maybeTokenWithColumnNumber(state, state.tokenIndex + 1));
    }
    const lexerSnapshot = state.lexerSnapshot;
    const tokens = lexerSnapshot.tokens;
    const contiguousIdentifierStartIndex = tokens[tokenRangeStartIndex].positionStart.codeUnit;
    const contiguousIdentifierEndIndex = tokens[tokenRangeEndIndex - 1].positionEnd.codeUnit;
    literal = lexerSnapshot.text.slice(contiguousIdentifierStartIndex, contiguousIdentifierEndIndex);
    astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: true, literal });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readGeneralizedIdentifier = readGeneralizedIdentifier;
function readKeyword(state, _parser) {
    const identifierExpressionNodeKind = "IdentifierExpression" /* IdentifierExpression */;
    IParserState_1.IParserStateUtils.startContext(state, identifierExpressionNodeKind);
    // Keywords can't have a "@" prefix constant
    IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
    const identifierNodeKind = "Identifier" /* Identifier */;
    IParserState_1.IParserStateUtils.startContext(state, identifierNodeKind);
    const literal = common_2.readToken(state);
    const identifier = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: identifierNodeKind, isLeaf: true, literal });
    IParserState_1.IParserStateUtils.endContext(state, identifier);
    const identifierExpression = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: identifierExpressionNodeKind, isLeaf: false, maybeInclusiveConstant: undefined, identifier });
    IParserState_1.IParserStateUtils.endContext(state, identifierExpression);
    return identifierExpression;
}
exports.readKeyword = readKeyword;
// --------------------------------------
// ---------- 12.2.1 Documents ----------
// --------------------------------------
function readDocument(state, parser) {
    let triedReadDocument;
    // Try parsing as an Expression document first.
    // If Expression document fails (including UnusedTokensRemainError) then try parsing a SectionDocument.
    // If both fail then return the error which parsed more tokens.
    try {
        triedReadDocument = common_1.ResultUtils.okFactory(parser.readExpression(state, parser));
        const maybeErr = IParserState_1.IParserStateUtils.testNoMoreTokens(state);
        if (maybeErr) {
            throw maybeErr;
        }
    }
    catch (expressionError) {
        // Fast backup deletes context state, but we want to preserve it for the case
        // where both parsing an expression and section document error out.
        const expressionErrorStateBackup = IParserState_1.IParserStateUtils.fastStateBackup(state);
        const expressionErrorContextState = state.contextState;
        // Reset the parser's state.
        state.tokenIndex = 0;
        state.contextState = __1.ParseContextUtils.newState();
        state.maybeCurrentContextNode = undefined;
        if (state.lexerSnapshot.tokens.length) {
            state.maybeCurrentToken = state.lexerSnapshot.tokens[0];
            state.maybeCurrentTokenKind = state.maybeCurrentToken.kind;
        }
        try {
            triedReadDocument = common_1.ResultUtils.okFactory(readSectionDocument(state, parser));
            const maybeErr = IParserState_1.IParserStateUtils.testNoMoreTokens(state);
            if (maybeErr) {
                throw maybeErr;
            }
        }
        catch (sectionError) {
            let triedError;
            if (expressionErrorStateBackup.tokenIndex > /* sectionErrorState */ state.tokenIndex) {
                triedError = expressionError;
                IParserState_1.IParserStateUtils.applyFastStateBackup(state, expressionError);
                state.contextState = expressionErrorContextState;
            }
            else {
                triedError = sectionError;
            }
            triedReadDocument = common_1.ResultUtils.errFactory(triedError);
        }
    }
    if (common_1.ResultUtils.isErr(triedReadDocument)) {
        const currentError = triedReadDocument.error;
        let convertedError;
        if (__1.ParseError.isTInnerParseError(currentError)) {
            convertedError = new __1.ParseError.ParseError(currentError, state);
        }
        else {
            convertedError = common_1.CommonError.ensureCommonError(state.localizationTemplates, currentError);
        }
        return common_1.ResultUtils.errFactory(convertedError);
    }
    const document = triedReadDocument.value;
    if (state.maybeCurrentContextNode !== undefined) {
        const details = { maybeContextNode: state.maybeCurrentContextNode };
        throw new common_1.CommonError.InvariantError("maybeContextNode should be falsey, there shouldn't be an open context", details);
    }
    const contextState = state.contextState;
    return common_1.ResultUtils.okFactory({
        ast: document,
        nodeIdMapCollection: contextState.nodeIdMapCollection,
        leafNodeIds: contextState.leafNodeIds,
        state,
    });
}
exports.readDocument = readDocument;
// ----------------------------------------------
// ---------- 12.2.2 Section Documents ----------
// ----------------------------------------------
function readSectionDocument(state, parser) {
    const nodeKind = "Section" /* Section */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const maybeLiteralAttributes = maybeReadLiteralAttributes(state, parser);
    const sectionConstant = common_2.readTokenKindAsConstant(state, "KeywordSection" /* KeywordSection */, "section" /* Section */);
    let maybeName;
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "Identifier" /* Identifier */)) {
        maybeName = parser.readIdentifier(state, parser);
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
    }
    const semicolonConstant = common_2.readTokenKindAsConstant(state, "Semicolon" /* Semicolon */, ";" /* Semicolon */);
    const sectionMembers = parser.readSectionMembers(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, maybeLiteralAttributes,
        sectionConstant,
        maybeName,
        semicolonConstant,
        sectionMembers });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readSectionDocument = readSectionDocument;
function readSectionMembers(state, parser) {
    const nodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const totalTokens = state.lexerSnapshot.tokens.length;
    const sectionMembers = [];
    while (state.tokenIndex < totalTokens) {
        sectionMembers.push(parser.readSectionMember(state, parser));
    }
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, elements: sectionMembers });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readSectionMembers = readSectionMembers;
function readSectionMember(state, parser) {
    const nodeKind = "SectionMember" /* SectionMember */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const maybeLiteralAttributes = maybeReadLiteralAttributes(state, parser);
    const maybeSharedConstant = common_2.maybeReadTokenKindAsConstant(state, "KeywordShared" /* KeywordShared */, "shared" /* Shared */);
    const namePairedExpression = parser.readIdentifierPairedExpression(state, parser);
    const semicolonConstant = common_2.readTokenKindAsConstant(state, "Semicolon" /* Semicolon */, ";" /* Semicolon */);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, maybeLiteralAttributes,
        maybeSharedConstant,
        namePairedExpression,
        semicolonConstant });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readSectionMember = readSectionMember;
// ------------------------------------------
// ---------- 12.2.3.1 Expressions ----------
// ------------------------------------------
function readExpression(state, parser) {
    switch (state.maybeCurrentTokenKind) {
        case "KeywordEach" /* KeywordEach */:
            return parser.readEachExpression(state, parser);
        case "KeywordLet" /* KeywordLet */:
            return parser.readLetExpression(state, parser);
        case "KeywordIf" /* KeywordIf */:
            return parser.readIfExpression(state, parser);
        case "KeywordError" /* KeywordError */:
            return parser.readErrorRaisingExpression(state, parser);
        case "KeywordTry" /* KeywordTry */:
            return parser.readErrorHandlingExpression(state, parser);
        case "LeftParenthesis" /* LeftParenthesis */:
            const triedDisambiguation = parser.disambiguateParenthesis(state, parser);
            if (common_1.ResultUtils.isErr(triedDisambiguation)) {
                throw triedDisambiguation.error;
            }
            const disambiguation = triedDisambiguation.value;
            switch (disambiguation) {
                case "FunctionExpression" /* FunctionExpression */:
                    return parser.readFunctionExpression(state, parser);
                case "ParenthesizedExpression" /* ParenthesizedExpression */:
                    return parser.readLogicalExpression(state, parser);
                default:
                    throw common_1.isNever(disambiguation);
            }
        default:
            return parser.readLogicalExpression(state, parser);
    }
}
exports.readExpression = readExpression;
// --------------------------------------------------
// ---------- 12.2.3.2 Logical expressions ----------
// --------------------------------------------------
function readLogicalExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "LogicalExpression" /* LogicalExpression */, () => parser.readIsExpression(state, parser), maybeCurrentTokenKind => __1.AstUtils.maybeLogicalOperatorKindFrom(maybeCurrentTokenKind), () => parser.readIsExpression(state, parser));
}
exports.readLogicalExpression = readLogicalExpression;
// --------------------------------------------
// ---------- 12.2.3.3 Is expression ----------
// --------------------------------------------
function readIsExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "IsExpression" /* IsExpression */, () => parser.readAsExpression(state, parser), maybeCurrentTokenKind => maybeCurrentTokenKind === "KeywordIs" /* KeywordIs */ ? "is" /* Is */ : undefined, () => parser.readNullablePrimitiveType(state, parser));
}
exports.readIsExpression = readIsExpression;
// sub-item of 12.2.3.3 Is expression
function readNullablePrimitiveType(state, parser) {
    if (IParserState_1.IParserStateUtils.isOnConstantKind(state, "nullable" /* Nullable */)) {
        return readPairedConstant(state, "NullablePrimitiveType" /* NullablePrimitiveType */, () => readConstantKind(state, "nullable" /* Nullable */), () => parser.readPrimitiveType(state, parser));
    }
    else {
        return parser.readPrimitiveType(state, parser);
    }
}
exports.readNullablePrimitiveType = readNullablePrimitiveType;
// --------------------------------------------
// ---------- 12.2.3.4 As expression ----------
// --------------------------------------------
function readAsExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "AsExpression" /* AsExpression */, () => parser.readEqualityExpression(state, parser), maybeCurrentTokenKind => maybeCurrentTokenKind === "KeywordAs" /* KeywordAs */ ? "as" /* As */ : undefined, () => parser.readNullablePrimitiveType(state, parser));
}
exports.readAsExpression = readAsExpression;
// --------------------------------------------------
// ---------- 12.2.3.5 Equality expression ----------
// --------------------------------------------------
function readEqualityExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "EqualityExpression" /* EqualityExpression */, () => parser.readRelationalExpression(state, parser), maybeCurrentTokenKind => __1.AstUtils.maybeEqualityOperatorKindFrom(maybeCurrentTokenKind), () => parser.readRelationalExpression(state, parser));
}
exports.readEqualityExpression = readEqualityExpression;
// ----------------------------------------------------
// ---------- 12.2.3.6 Relational expression ----------
// ----------------------------------------------------
function readRelationalExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "RelationalExpression" /* RelationalExpression */, () => parser.readArithmeticExpression(state, parser), maybeCurrentTokenKind => __1.AstUtils.maybeRelationalOperatorKindFrom(maybeCurrentTokenKind), () => parser.readArithmeticExpression(state, parser));
}
exports.readRelationalExpression = readRelationalExpression;
// -----------------------------------------------------
// ---------- 12.2.3.7 Arithmetic expressions ----------
// -----------------------------------------------------
function readArithmeticExpression(state, parser) {
    return recursiveReadBinOpExpression(state, "ArithmeticExpression" /* ArithmeticExpression */, () => parser.readMetadataExpression(state, parser), maybeCurrentTokenKind => __1.AstUtils.maybeArithmeticOperatorKindFrom(maybeCurrentTokenKind), () => parser.readMetadataExpression(state, parser));
}
exports.readArithmeticExpression = readArithmeticExpression;
// --------------------------------------------------
// ---------- 12.2.3.8 Metadata expression ----------
// --------------------------------------------------
function readMetadataExpression(state, parser) {
    const nodeKind = "MetadataExpression" /* MetadataExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const left = parser.readUnaryExpression(state, parser);
    const maybeMetaConstant = common_2.maybeReadTokenKindAsConstant(state, "KeywordMeta" /* KeywordMeta */, "meta" /* Meta */);
    if (maybeMetaConstant !== undefined) {
        const operatorConstant = maybeMetaConstant;
        const right = parser.readUnaryExpression(state, parser);
        const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, left,
            operatorConstant,
            right });
        IParserState_1.IParserStateUtils.endContext(state, astNode);
        return astNode;
    }
    else {
        IParserState_1.IParserStateUtils.deleteContext(state, undefined);
        return left;
    }
}
exports.readMetadataExpression = readMetadataExpression;
// -----------------------------------------------
// ---------- 12.2.3.9 Unary expression ----------
// -----------------------------------------------
function readUnaryExpression(state, parser) {
    let maybeOperator = __1.AstUtils.maybeUnaryOperatorKindFrom(state.maybeCurrentTokenKind);
    if (maybeOperator === undefined) {
        return parser.readTypeExpression(state, parser);
    }
    const unaryNodeKind = "UnaryExpression" /* UnaryExpression */;
    IParserState_1.IParserStateUtils.startContext(state, unaryNodeKind);
    const arrayNodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, arrayNodeKind);
    const operatorConstants = [];
    while (maybeOperator) {
        operatorConstants.push(common_2.readTokenKindAsConstant(state, state.maybeCurrentTokenKind, maybeOperator));
        maybeOperator = __1.AstUtils.maybeUnaryOperatorKindFrom(state.maybeCurrentTokenKind);
    }
    const operators = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: arrayNodeKind, isLeaf: false, elements: operatorConstants });
    IParserState_1.IParserStateUtils.endContext(state, operators);
    const typeExpression = parser.readTypeExpression(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: unaryNodeKind, isLeaf: false, operators,
        typeExpression });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readUnaryExpression = readUnaryExpression;
// --------------------------------------------------
// ---------- 12.2.3.10 Primary expression ----------
// --------------------------------------------------
function readPrimaryExpression(state, parser) {
    let primaryExpression;
    const maybeCurrentTokenKind = state.maybeCurrentTokenKind;
    const isIdentifierExpressionNext = maybeCurrentTokenKind === "AtSign" /* AtSign */ || maybeCurrentTokenKind === "Identifier" /* Identifier */;
    if (isIdentifierExpressionNext) {
        primaryExpression = parser.readIdentifierExpression(state, parser);
    }
    else {
        switch (maybeCurrentTokenKind) {
            case "LeftParenthesis" /* LeftParenthesis */:
                primaryExpression = parser.readParenthesizedExpression(state, parser);
                break;
            case "LeftBracket" /* LeftBracket */:
                primaryExpression = common_2.readBracketDisambiguation(state, parser, [
                    "FieldProjection" /* FieldProjection */,
                    "FieldSelection" /* FieldSelection */,
                    "Record" /* Record */,
                ]);
                break;
            case "LeftBrace" /* LeftBrace */:
                primaryExpression = parser.readListExpression(state, parser);
                break;
            case "Ellipsis" /* Ellipsis */:
                primaryExpression = parser.readNotImplementedExpression(state, parser);
                break;
            case "KeywordHashSections" /* KeywordHashSections */:
            case "KeywordHashShared" /* KeywordHashShared */:
            case "KeywordHashBinary" /* KeywordHashBinary */:
            case "KeywordHashDate" /* KeywordHashDate */:
            case "KeywordHashDateTime" /* KeywordHashDateTime */:
            case "KeywordHashDateTimeZone" /* KeywordHashDateTimeZone */:
            case "KeywordHashDuration" /* KeywordHashDuration */:
            case "KeywordHashTable" /* KeywordHashTable */:
            case "KeywordHashTime" /* KeywordHashTime */:
                primaryExpression = parser.readKeyword(state, parser);
                break;
            default:
                primaryExpression = parser.readLiteralExpression(state, parser);
        }
    }
    if (IParserState_1.IParserStateUtils.isRecursivePrimaryExpressionNext(state)) {
        return parser.readRecursivePrimaryExpression(state, parser, primaryExpression);
    }
    else {
        return primaryExpression;
    }
}
exports.readPrimaryExpression = readPrimaryExpression;
function readRecursivePrimaryExpression(state, parser, head) {
    const nodeKind = "RecursivePrimaryExpression" /* RecursivePrimaryExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    // The head of the recursive primary expression is created before the recursive primary expression,
    // meaning the parent/child mapping for contexts are in reverse order.
    // The clean up for that happens here.
    const nodeIdMapCollection = state.contextState.nodeIdMapCollection;
    if (state.maybeCurrentContextNode === undefined) {
        throw new common_1.CommonError.InvariantError(`maybeCurrentContextNode should be truthy`);
    }
    const currentContextNode = state.maybeCurrentContextNode;
    const maybeHeadParentId = nodeIdMapCollection.parentIdById.get(head.id);
    if (maybeHeadParentId !== undefined) {
        const headParentId = maybeHeadParentId;
        // Remove head as a child of its current parent.
        const parentChildIds = nodeIdMap_1.NodeIdMapUtils.expectChildIds(nodeIdMapCollection.childIdsById, headParentId);
        const replacementIndex = parentChildIds.indexOf(head.id);
        if (replacementIndex === -1) {
            const details = {
                parentNodeId: headParentId,
                childNodeId: head.id,
            };
            throw new common_1.CommonError.InvariantError(`node isn't a child of parentNode`, details);
        }
        nodeIdMapCollection.childIdsById.set(headParentId, [
            ...parentChildIds.slice(0, replacementIndex),
            ...parentChildIds.slice(replacementIndex + 1),
        ]);
    }
    // Update mappings for head.
    nodeIdMapCollection.astNodeById.set(head.id, head);
    nodeIdMapCollection.parentIdById.set(head.id, currentContextNode.id);
    // Mark head as a child of the recursive primary expression context (currentContextNode).
    nodeIdMapCollection.childIdsById.set(currentContextNode.id, [head.id]);
    // Update start positions for recursive primary expression context
    const recursiveTokenIndexStart = head.tokenRange.tokenIndexStart;
    const mutableContext = currentContextNode;
    // UNSAFE MARKER
    //
    // Purpose of code block:
    //      Shift the start of ParserContext from the default location (which doesn't include head),
    //      to the left so that head is also included.
    //
    // Why are you trying to avoid a safer approach?
    //      There isn't one? At least not without refactoring in ways which will make things messier.
    //
    // Why is it safe?
    //      I'm only mutating start location in the recursive expression to one already parsed, the head.
    mutableContext.maybeTokenStart = state.lexerSnapshot.tokens[recursiveTokenIndexStart];
    mutableContext.tokenIndexStart = recursiveTokenIndexStart;
    // Update attribute index for the head Ast.TNode
    const mutableHead = head;
    // UNSAFE MARKER
    //
    // Purpose of code block:
    //      The head might not have `maybeAttributeIndex === 0` set.
    //
    // Why are you trying to avoid a safer approach?
    //      Prevent the cost of a shallow copy.
    //
    // Why is it safe?
    //      It's a shallow copy, plus one attribute change.
    mutableHead.maybeAttributeIndex = 0;
    // Begin normal parsing behavior.
    const recursiveArrayNodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, recursiveArrayNodeKind);
    const recursiveExpressions = [];
    let continueReadingValues = true;
    while (continueReadingValues) {
        const maybeCurrentTokenKind = state.maybeCurrentTokenKind;
        if (maybeCurrentTokenKind === "LeftParenthesis" /* LeftParenthesis */) {
            recursiveExpressions.push(parser.readInvokeExpression(state, parser));
        }
        else if (maybeCurrentTokenKind === "LeftBrace" /* LeftBrace */) {
            recursiveExpressions.push(parser.readItemAccessExpression(state, parser));
        }
        else if (maybeCurrentTokenKind === "LeftBracket" /* LeftBracket */) {
            const bracketExpression = common_2.readBracketDisambiguation(state, parser, [
                "FieldProjection" /* FieldProjection */,
                "FieldSelection" /* FieldSelection */,
            ]);
            recursiveExpressions.push(bracketExpression);
        }
        else {
            continueReadingValues = false;
        }
    }
    const recursiveArray = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: recursiveArrayNodeKind, isLeaf: false, elements: recursiveExpressions });
    IParserState_1.IParserStateUtils.endContext(state, recursiveArray);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, head, recursiveExpressions: recursiveArray });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readRecursivePrimaryExpression = readRecursivePrimaryExpression;
// --------------------------------------------------
// ---------- 12.2.3.11 Literal expression ----------
// --------------------------------------------------
function readLiteralExpression(state, _parser) {
    const nodeKind = "LiteralExpression" /* LiteralExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const expectedTokenKinds = [
        "HexLiteral" /* HexLiteral */,
        "KeywordFalse" /* KeywordFalse */,
        "KeywordHashInfinity" /* KeywordHashInfinity */,
        "KeywordHashNan" /* KeywordHashNan */,
        "KeywordTrue" /* KeywordTrue */,
        "NumericLiteral" /* NumericLiteral */,
        "NullLiteral" /* NullLiteral */,
        "StringLiteral" /* StringLiteral */,
    ];
    const maybeErr = IParserState_1.IParserStateUtils.testIsOnAnyTokenKind(state, expectedTokenKinds);
    if (maybeErr) {
        throw maybeErr;
    }
    const maybeLiteralKind = __1.AstUtils.maybeLiteralKindFrom(state.maybeCurrentTokenKind);
    if (maybeLiteralKind === undefined) {
        throw new common_1.CommonError.InvariantError(`couldn't convert TokenKind=${state.maybeCurrentTokenKind} into LiteralKind`);
    }
    const literal = common_2.readToken(state);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: true, literal: literal, literalKind: maybeLiteralKind });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readLiteralExpression = readLiteralExpression;
// ---------------------------------------------------------------
// ---------- 12.2.3.16 12.2.3.12 Identifier expression ----------
// ---------------------------------------------------------------
function readIdentifierExpression(state, parser) {
    const nodeKind = "IdentifierExpression" /* IdentifierExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const maybeInclusiveConstant = common_2.maybeReadTokenKindAsConstant(state, "AtSign" /* AtSign */, "@" /* AtSign */);
    const identifier = parser.readIdentifier(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, maybeInclusiveConstant,
        identifier });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readIdentifierExpression = readIdentifierExpression;
// --------------------------------------------------------
// ---------- 12.2.3.14 Parenthesized expression ----------
// --------------------------------------------------------
function readParenthesizedExpression(state, parser) {
    return readWrapped(state, "ParenthesizedExpression" /* ParenthesizedExpression */, () => common_2.readTokenKindAsConstant(state, "LeftParenthesis" /* LeftParenthesis */, "(" /* LeftParenthesis */), () => parser.readExpression(state, parser), () => common_2.readTokenKindAsConstant(state, "RightParenthesis" /* RightParenthesis */, ")" /* RightParenthesis */), false);
}
exports.readParenthesizedExpression = readParenthesizedExpression;
// ----------------------------------------------------------
// ---------- 12.2.3.15 Not-implemented expression ----------
// ----------------------------------------------------------
function readNotImplementedExpression(state, _parser) {
    const nodeKind = "NotImplementedExpression" /* NotImplementedExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const ellipsisConstant = common_2.readTokenKindAsConstant(state, "Ellipsis" /* Ellipsis */, "..." /* Ellipsis */);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, ellipsisConstant });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readNotImplementedExpression = readNotImplementedExpression;
// -------------------------------------------------
// ---------- 12.2.3.16 Invoke expression ----------
// -------------------------------------------------
function readInvokeExpression(state, parser) {
    const continueReadingValues = !IParserState_1.IParserStateUtils.isNextTokenKind(state, "RightParenthesis" /* RightParenthesis */);
    return readWrapped(state, "InvokeExpression" /* InvokeExpression */, () => common_2.readTokenKindAsConstant(state, "LeftParenthesis" /* LeftParenthesis */, "(" /* LeftParenthesis */), () => 
    // The type inference in VSCode considers the lambda below a type error, but it compiles just fine.
    // I'm adding an explicit type to stop it from (incorrectly) saying it's an error.
    readCsvArray(state, () => parser.readExpression(state, parser), continueReadingValues, testCsvContinuationDanglingCommaForParenthesis), () => common_2.readTokenKindAsConstant(state, "RightParenthesis" /* RightParenthesis */, ")" /* RightParenthesis */), false);
}
exports.readInvokeExpression = readInvokeExpression;
// -----------------------------------------------
// ---------- 12.2.3.17 List expression ----------
// -----------------------------------------------
function readListExpression(state, parser) {
    const continueReadingValues = !IParserState_1.IParserStateUtils.isNextTokenKind(state, "RightBrace" /* RightBrace */);
    return readWrapped(state, "ListExpression" /* ListExpression */, () => common_2.readTokenKindAsConstant(state, "LeftBrace" /* LeftBrace */, "{" /* LeftBrace */), () => readCsvArray(state, () => parser.readListItem(state, parser), continueReadingValues, testCsvContinuationDanglingCommaForBrace), () => common_2.readTokenKindAsConstant(state, "RightBrace" /* RightBrace */, "}" /* RightBrace */), false);
}
exports.readListExpression = readListExpression;
function readListItem(state, parser) {
    const nodeKind = "RangeExpression" /* RangeExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const left = parser.readExpression(state, parser);
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "DotDot" /* DotDot */)) {
        const rangeConstant = common_2.readTokenKindAsConstant(state, "DotDot" /* DotDot */, ".." /* DotDot */);
        const right = parser.readExpression(state, parser);
        const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, left,
            rangeConstant,
            right });
        IParserState_1.IParserStateUtils.endContext(state, astNode);
        return astNode;
    }
    else {
        IParserState_1.IParserStateUtils.deleteContext(state, undefined);
        return left;
    }
}
exports.readListItem = readListItem;
// -------------------------------------------------
// ---------- 12.2.3.18 Record expression ----------
// -------------------------------------------------
function readRecordExpression(state, parser) {
    const continueReadingValues = !IParserState_1.IParserStateUtils.isNextTokenKind(state, "RightBracket" /* RightBracket */);
    return readWrapped(state, "RecordExpression" /* RecordExpression */, () => common_2.readTokenKindAsConstant(state, "LeftBracket" /* LeftBracket */, "[" /* LeftBracket */), () => parser.readGeneralizedIdentifierPairedExpressions(state, parser, continueReadingValues, testCsvContinuationDanglingCommaForBracket), () => common_2.readTokenKindAsConstant(state, "RightBracket" /* RightBracket */, "]" /* RightBracket */), false);
}
exports.readRecordExpression = readRecordExpression;
// ------------------------------------------------------
// ---------- 12.2.3.19 Item access expression ----------
// ------------------------------------------------------
function readItemAccessExpression(state, parser) {
    return readWrapped(state, "ItemAccessExpression" /* ItemAccessExpression */, () => common_2.readTokenKindAsConstant(state, "LeftBrace" /* LeftBrace */, "{" /* LeftBrace */), () => parser.readExpression(state, parser), () => common_2.readTokenKindAsConstant(state, "RightBrace" /* RightBrace */, "}" /* RightBrace */), true);
}
exports.readItemAccessExpression = readItemAccessExpression;
// -------------------------------------------------------
// ---------- 12.2.3.20 Field access expression ----------
// -------------------------------------------------------
function readFieldSelection(state, parser) {
    return readFieldSelector(state, parser, true);
}
exports.readFieldSelection = readFieldSelection;
function readFieldProjection(state, parser) {
    return readWrapped(state, "FieldProjection" /* FieldProjection */, () => common_2.readTokenKindAsConstant(state, "LeftBracket" /* LeftBracket */, "[" /* LeftBracket */), () => readCsvArray(state, () => parser.readFieldSelector(state, parser, false), true, testCsvContinuationDanglingCommaForBracket), () => common_2.readTokenKindAsConstant(state, "RightBracket" /* RightBracket */, "]" /* RightBracket */), true);
}
exports.readFieldProjection = readFieldProjection;
function readFieldSelector(state, parser, allowOptional) {
    return readWrapped(state, "FieldSelector" /* FieldSelector */, () => common_2.readTokenKindAsConstant(state, "LeftBracket" /* LeftBracket */, "[" /* LeftBracket */), () => parser.readGeneralizedIdentifier(state, parser), () => common_2.readTokenKindAsConstant(state, "RightBracket" /* RightBracket */, "]" /* RightBracket */), allowOptional);
}
exports.readFieldSelector = readFieldSelector;
// ---------------------------------------------------
// ---------- 12.2.3.21 Function expression ----------
// ---------------------------------------------------
function readFunctionExpression(state, parser) {
    const nodeKind = "FunctionExpression" /* FunctionExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const parameters = parser.readParameterList(state, parser);
    const maybeFunctionReturnType = maybeReadAsNullablePrimitiveType(state, parser);
    const fatArrowConstant = common_2.readTokenKindAsConstant(state, "FatArrow" /* FatArrow */, "=>" /* FatArrow */);
    const expression = parser.readExpression(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, parameters,
        maybeFunctionReturnType,
        fatArrowConstant,
        expression });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readFunctionExpression = readFunctionExpression;
function readParameterList(state, parser) {
    return genericReadParameterList(state, parser, () => maybeReadAsNullablePrimitiveType(state, parser));
}
exports.readParameterList = readParameterList;
function maybeReadAsNullablePrimitiveType(state, parser) {
    return maybeReadPairedConstant(state, "AsNullablePrimitiveType" /* AsNullablePrimitiveType */, () => IParserState_1.IParserStateUtils.isOnTokenKind(state, "KeywordAs" /* KeywordAs */), () => common_2.readTokenKindAsConstant(state, "KeywordAs" /* KeywordAs */, "as" /* As */), () => parser.readNullablePrimitiveType(state, parser));
}
function readAsType(state, parser) {
    return readPairedConstant(state, "AsType" /* AsType */, () => common_2.readTokenKindAsConstant(state, "KeywordAs" /* KeywordAs */, "as" /* As */), () => parser.readType(state, parser));
}
exports.readAsType = readAsType;
// -----------------------------------------------
// ---------- 12.2.3.22 Each expression ----------
// -----------------------------------------------
function readEachExpression(state, parser) {
    return readPairedConstant(state, "EachExpression" /* EachExpression */, () => common_2.readTokenKindAsConstant(state, "KeywordEach" /* KeywordEach */, "each" /* Each */), () => parser.readExpression(state, parser));
}
exports.readEachExpression = readEachExpression;
// ----------------------------------------------
// ---------- 12.2.3.23 Let expression ----------
// ----------------------------------------------
function readLetExpression(state, parser) {
    const nodeKind = "LetExpression" /* LetExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const letConstant = common_2.readTokenKindAsConstant(state, "KeywordLet" /* KeywordLet */, "let" /* Let */);
    const identifierExpressionPairedExpressions = parser.readIdentifierPairedExpressions(state, parser, !IParserState_1.IParserStateUtils.isNextTokenKind(state, "KeywordIn" /* KeywordIn */), IParserState_1.IParserStateUtils.testCsvContinuationLetExpression);
    const inConstant = common_2.readTokenKindAsConstant(state, "KeywordIn" /* KeywordIn */, "in" /* In */);
    const expression = parser.readExpression(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: "LetExpression" /* LetExpression */, isLeaf: false, letConstant, variableList: identifierExpressionPairedExpressions, inConstant,
        expression });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readLetExpression = readLetExpression;
// ---------------------------------------------
// ---------- 12.2.3.24 If expression ----------
// ---------------------------------------------
function readIfExpression(state, parser) {
    const nodeKind = "IfExpression" /* IfExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const ifConstant = common_2.readTokenKindAsConstant(state, "KeywordIf" /* KeywordIf */, "if" /* If */);
    const condition = parser.readExpression(state, parser);
    const thenConstant = common_2.readTokenKindAsConstant(state, "KeywordThen" /* KeywordThen */, "then" /* Then */);
    const trueExpression = parser.readExpression(state, parser);
    const elseConstant = common_2.readTokenKindAsConstant(state, "KeywordElse" /* KeywordElse */, "else" /* Else */);
    const falseExpression = parser.readExpression(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, ifConstant,
        condition,
        thenConstant,
        trueExpression,
        elseConstant,
        falseExpression });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readIfExpression = readIfExpression;
// -----------------------------------------------
// ---------- 12.2.3.25 Type expression ----------
// -----------------------------------------------
function readTypeExpression(state, parser) {
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "KeywordType" /* KeywordType */)) {
        return readPairedConstant(state, "TypePrimaryType" /* TypePrimaryType */, () => common_2.readTokenKindAsConstant(state, "KeywordType" /* KeywordType */, "type" /* Type */), () => parser.readPrimaryType(state, parser));
    }
    else {
        return parser.readPrimaryExpression(state, parser);
    }
}
exports.readTypeExpression = readTypeExpression;
function readType(state, parser) {
    const triedReadPrimaryType = tryReadPrimaryType(state, parser);
    if (common_1.ResultUtils.isOk(triedReadPrimaryType)) {
        return triedReadPrimaryType.value;
    }
    else {
        return parser.readPrimaryExpression(state, parser);
    }
}
exports.readType = readType;
function readPrimaryType(state, parser) {
    const triedReadPrimaryType = tryReadPrimaryType(state, parser);
    if (common_1.ResultUtils.isOk(triedReadPrimaryType)) {
        return triedReadPrimaryType.value;
    }
    else {
        throw triedReadPrimaryType.error;
    }
}
exports.readPrimaryType = readPrimaryType;
function readRecordType(state, parser) {
    const nodeKind = "RecordType" /* RecordType */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const fields = parser.readFieldSpecificationList(state, parser, true, testCsvContinuationDanglingCommaForBracket);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, fields });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readRecordType = readRecordType;
function readTableType(state, parser) {
    const nodeKind = "TableType" /* TableType */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const tableConstant = readConstantKind(state, "table" /* Table */);
    const maybeCurrentTokenKind = state.maybeCurrentTokenKind;
    const isPrimaryExpressionExpected = maybeCurrentTokenKind === "AtSign" /* AtSign */ ||
        maybeCurrentTokenKind === "Identifier" /* Identifier */ ||
        maybeCurrentTokenKind === "LeftParenthesis" /* LeftParenthesis */;
    let rowType;
    if (isPrimaryExpressionExpected) {
        rowType = parser.readPrimaryExpression(state, parser);
    }
    else {
        rowType = parser.readFieldSpecificationList(state, parser, false, testCsvContinuationDanglingCommaForBracket);
    }
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, tableConstant,
        rowType });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readTableType = readTableType;
function readFieldSpecificationList(state, parser, allowOpenMarker, testPostCommaError) {
    const nodeKind = "FieldSpecificationList" /* FieldSpecificationList */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const leftBracketConstant = common_2.readTokenKindAsConstant(state, "LeftBracket" /* LeftBracket */, "[" /* LeftBracket */);
    const fields = [];
    let continueReadingValues = true;
    let maybeOpenRecordMarkerConstant = undefined;
    const fieldArrayNodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, fieldArrayNodeKind);
    while (continueReadingValues) {
        const maybeErr = testPostCommaError(state);
        if (maybeErr) {
            throw maybeErr;
        }
        if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "Ellipsis" /* Ellipsis */)) {
            if (allowOpenMarker) {
                if (maybeOpenRecordMarkerConstant) {
                    throw fieldSpecificationListReadError(state, false);
                }
                else {
                    maybeOpenRecordMarkerConstant = common_2.readTokenKindAsConstant(state, "Ellipsis" /* Ellipsis */, "..." /* Ellipsis */);
                    continueReadingValues = false;
                }
            }
            else {
                throw fieldSpecificationListReadError(state, allowOpenMarker);
            }
        }
        else if (IParserState_1.IParserStateUtils.isOnGeneralizedIdentifierStart(state)) {
            const csvNodeKind = "Csv" /* Csv */;
            IParserState_1.IParserStateUtils.startContext(state, csvNodeKind);
            const fieldSpecificationNodeKind = "FieldSpecification" /* FieldSpecification */;
            IParserState_1.IParserStateUtils.startContext(state, fieldSpecificationNodeKind);
            const maybeOptionalConstant = maybeReadConstantKind(state, "optional" /* Optional */);
            const name = parser.readGeneralizedIdentifier(state, parser);
            const maybeFieldTypeSpecification = maybeReadFieldTypeSpecification(state, parser);
            const maybeCommaConstant = common_2.maybeReadTokenKindAsConstant(state, "Comma" /* Comma */, "," /* Comma */);
            continueReadingValues = maybeCommaConstant !== undefined;
            const field = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: fieldSpecificationNodeKind, isLeaf: false, maybeOptionalConstant,
                name,
                maybeFieldTypeSpecification });
            IParserState_1.IParserStateUtils.endContext(state, field);
            const csv = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: csvNodeKind, isLeaf: false, node: field, maybeCommaConstant });
            IParserState_1.IParserStateUtils.endContext(state, csv);
            fields.push(csv);
        }
        else {
            throw fieldSpecificationListReadError(state, allowOpenMarker);
        }
    }
    const fieldArray = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: fieldArrayNodeKind, elements: fields, isLeaf: false });
    IParserState_1.IParserStateUtils.endContext(state, fieldArray);
    const rightBracketConstant = common_2.readTokenKindAsConstant(state, "RightBracket" /* RightBracket */, "]" /* RightBracket */);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, openWrapperConstant: leftBracketConstant, content: fieldArray, maybeOpenRecordMarkerConstant, closeWrapperConstant: rightBracketConstant });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readFieldSpecificationList = readFieldSpecificationList;
function maybeReadFieldTypeSpecification(state, parser) {
    const nodeKind = "FieldTypeSpecification" /* FieldTypeSpecification */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const maybeEqualConstant = common_2.maybeReadTokenKindAsConstant(state, "Equal" /* Equal */, "=" /* Equal */);
    if (maybeEqualConstant) {
        const fieldType = parser.readType(state, parser);
        const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: "FieldTypeSpecification" /* FieldTypeSpecification */, isLeaf: false, equalConstant: maybeEqualConstant, fieldType });
        IParserState_1.IParserStateUtils.endContext(state, astNode);
        return astNode;
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
        IParserState_1.IParserStateUtils.deleteContext(state, undefined);
        return undefined;
    }
}
function fieldSpecificationListReadError(state, allowOpenMarker) {
    if (allowOpenMarker) {
        const expectedTokenKinds = ["Identifier" /* Identifier */, "Ellipsis" /* Ellipsis */];
        return IParserState_1.IParserStateUtils.testIsOnAnyTokenKind(state, expectedTokenKinds);
    }
    else {
        return IParserState_1.IParserStateUtils.testIsOnTokenKind(state, "Identifier" /* Identifier */);
    }
}
function readListType(state, parser) {
    return readWrapped(state, "ListType" /* ListType */, () => common_2.readTokenKindAsConstant(state, "LeftBrace" /* LeftBrace */, "{" /* LeftBrace */), () => parser.readType(state, parser), () => common_2.readTokenKindAsConstant(state, "RightBrace" /* RightBrace */, "}" /* RightBrace */), false);
}
exports.readListType = readListType;
function readFunctionType(state, parser) {
    const nodeKind = "FunctionType" /* FunctionType */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const functionConstant = readConstantKind(state, "function" /* Function */);
    const parameters = parser.readParameterSpecificationList(state, parser);
    const functionReturnType = parser.readAsType(state, parser);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, functionConstant,
        parameters,
        functionReturnType });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readFunctionType = readFunctionType;
function tryReadPrimaryType(state, parser) {
    const isTableTypeNext = IParserState_1.IParserStateUtils.isOnConstantKind(state, "table" /* Table */) &&
        (IParserState_1.IParserStateUtils.isNextTokenKind(state, "LeftBracket" /* LeftBracket */) ||
            IParserState_1.IParserStateUtils.isNextTokenKind(state, "LeftParenthesis" /* LeftParenthesis */) ||
            IParserState_1.IParserStateUtils.isNextTokenKind(state, "AtSign" /* AtSign */) ||
            IParserState_1.IParserStateUtils.isNextTokenKind(state, "Identifier" /* Identifier */));
    const isFunctionTypeNext = IParserState_1.IParserStateUtils.isOnConstantKind(state, "function" /* Function */) &&
        IParserState_1.IParserStateUtils.isNextTokenKind(state, "LeftParenthesis" /* LeftParenthesis */);
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "LeftBracket" /* LeftBracket */)) {
        return common_1.ResultUtils.okFactory(parser.readRecordType(state, parser));
    }
    else if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "LeftBrace" /* LeftBrace */)) {
        return common_1.ResultUtils.okFactory(parser.readListType(state, parser));
    }
    else if (isTableTypeNext) {
        return common_1.ResultUtils.okFactory(parser.readTableType(state, parser));
    }
    else if (isFunctionTypeNext) {
        return common_1.ResultUtils.okFactory(parser.readFunctionType(state, parser));
    }
    else if (IParserState_1.IParserStateUtils.isOnConstantKind(state, "nullable" /* Nullable */)) {
        return common_1.ResultUtils.okFactory(parser.readNullableType(state, parser));
    }
    else {
        const stateBackup = IParserState_1.IParserStateUtils.fastStateBackup(state);
        const triedReadPrimitiveType = tryReadPrimitiveType(state, parser);
        if (common_1.ResultUtils.isErr(triedReadPrimitiveType)) {
            IParserState_1.IParserStateUtils.applyFastStateBackup(state, stateBackup);
        }
        return triedReadPrimitiveType;
    }
}
function readParameterSpecificationList(state, parser) {
    return genericReadParameterList(state, parser, () => parser.readAsType(state, parser));
}
exports.readParameterSpecificationList = readParameterSpecificationList;
function readNullableType(state, parser) {
    return readPairedConstant(state, "NullableType" /* NullableType */, () => readConstantKind(state, "nullable" /* Nullable */), () => parser.readType(state, parser));
}
exports.readNullableType = readNullableType;
// --------------------------------------------------------
// ---------- 12.2.3.26 Error raising expression ----------
// --------------------------------------------------------
function readErrorRaisingExpression(state, parser) {
    return readPairedConstant(state, "ErrorRaisingExpression" /* ErrorRaisingExpression */, () => common_2.readTokenKindAsConstant(state, "KeywordError" /* KeywordError */, "error" /* Error */), () => parser.readExpression(state, parser));
}
exports.readErrorRaisingExpression = readErrorRaisingExpression;
// ---------------------------------------------------------
// ---------- 12.2.3.27 Error handling expression ----------
// ---------------------------------------------------------
function readErrorHandlingExpression(state, parser) {
    const nodeKind = "ErrorHandlingExpression" /* ErrorHandlingExpression */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const tryConstant = common_2.readTokenKindAsConstant(state, "KeywordTry" /* KeywordTry */, "try" /* Try */);
    const protectedExpression = parser.readExpression(state, parser);
    const otherwiseExpressionNodeKind = "OtherwiseExpression" /* OtherwiseExpression */;
    const maybeOtherwiseExpression = maybeReadPairedConstant(state, otherwiseExpressionNodeKind, () => IParserState_1.IParserStateUtils.isOnTokenKind(state, "KeywordOtherwise" /* KeywordOtherwise */), () => common_2.readTokenKindAsConstant(state, "KeywordOtherwise" /* KeywordOtherwise */, "otherwise" /* Otherwise */), () => parser.readExpression(state, parser));
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, tryConstant,
        protectedExpression,
        maybeOtherwiseExpression });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
exports.readErrorHandlingExpression = readErrorHandlingExpression;
// -----------------------------------------------
// ---------- 12.2.4 Literal Attributes ----------
// -----------------------------------------------
function readRecordLiteral(state, parser) {
    const continueReadingValues = !IParserState_1.IParserStateUtils.isNextTokenKind(state, "RightBracket" /* RightBracket */);
    const wrappedRead = readWrapped(state, "RecordLiteral" /* RecordLiteral */, () => common_2.readTokenKindAsConstant(state, "LeftBracket" /* LeftBracket */, "[" /* LeftBracket */), () => parser.readFieldNamePairedAnyLiterals(state, parser, continueReadingValues, testCsvContinuationDanglingCommaForBracket), () => common_2.readTokenKindAsConstant(state, "RightBracket" /* RightBracket */, "]" /* RightBracket */), false);
    return Object.assign({ literalKind: "Record" /* Record */ }, wrappedRead);
}
exports.readRecordLiteral = readRecordLiteral;
function readFieldNamePairedAnyLiterals(state, parser, continueReadingValues, testPostCommaError) {
    return readCsvArray(state, () => readKeyValuePair(state, "GeneralizedIdentifierPairedAnyLiteral" /* GeneralizedIdentifierPairedAnyLiteral */, () => parser.readGeneralizedIdentifier(state, parser), () => parser.readAnyLiteral(state, parser)), continueReadingValues, testPostCommaError);
}
exports.readFieldNamePairedAnyLiterals = readFieldNamePairedAnyLiterals;
function readListLiteral(state, parser) {
    const continueReadingValues = !IParserState_1.IParserStateUtils.isNextTokenKind(state, "RightBrace" /* RightBrace */);
    const wrappedRead = readWrapped(state, "ListLiteral" /* ListLiteral */, () => common_2.readTokenKindAsConstant(state, "LeftBrace" /* LeftBrace */, "{" /* LeftBrace */), () => readCsvArray(state, () => parser.readAnyLiteral(state, parser), continueReadingValues, testCsvContinuationDanglingCommaForBrace), () => common_2.readTokenKindAsConstant(state, "RightBrace" /* RightBrace */, "}" /* RightBrace */), false);
    return Object.assign({ literalKind: "List" /* List */ }, wrappedRead);
}
exports.readListLiteral = readListLiteral;
function readAnyLiteral(state, parser) {
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "LeftBracket" /* LeftBracket */)) {
        return parser.readRecordLiteral(state, parser);
    }
    else if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "LeftBrace" /* LeftBrace */)) {
        return parser.readListLiteral(state, parser);
    }
    else {
        return parser.readLiteralExpression(state, parser);
    }
}
exports.readAnyLiteral = readAnyLiteral;
function readPrimitiveType(state, parser) {
    const triedReadPrimitiveType = tryReadPrimitiveType(state, parser);
    if (common_1.ResultUtils.isOk(triedReadPrimitiveType)) {
        return triedReadPrimitiveType.value;
    }
    else {
        throw triedReadPrimitiveType.error;
    }
}
exports.readPrimitiveType = readPrimitiveType;
function tryReadPrimitiveType(state, _parser) {
    const nodeKind = "PrimitiveType" /* PrimitiveType */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const stateBackup = IParserState_1.IParserStateUtils.fastStateBackup(state);
    const expectedTokenKinds = [
        "Identifier" /* Identifier */,
        "KeywordType" /* KeywordType */,
        "NullLiteral" /* NullLiteral */,
    ];
    const maybeErr = IParserState_1.IParserStateUtils.testIsOnAnyTokenKind(state, expectedTokenKinds);
    if (maybeErr) {
        const error = maybeErr;
        return common_1.ResultUtils.errFactory(error);
    }
    let primitiveType;
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "Identifier" /* Identifier */)) {
        const currentTokenData = state.lexerSnapshot.tokens[state.tokenIndex].data;
        switch (currentTokenData) {
            case "action" /* Action */:
            case "any" /* Any */:
            case "anynonnull" /* AnyNonNull */:
            case "binary" /* Binary */:
            case "date" /* Date */:
            case "datetime" /* DateTime */:
            case "datetimezone" /* DateTimeZone */:
            case "duration" /* Duration */:
            case "function" /* Function */:
            case "list" /* List */:
            case "logical" /* Logical */:
            case "none" /* None */:
            case "number" /* Number */:
            case "record" /* Record */:
            case "table" /* Table */:
            case "text" /* Text */:
            case "time" /* Time */:
                primitiveType = readConstantKind(state, currentTokenData);
                break;
            default:
                const token = IParserState_1.IParserStateUtils.expectTokenAt(state, state.tokenIndex);
                IParserState_1.IParserStateUtils.applyFastStateBackup(state, stateBackup);
                return common_1.ResultUtils.errFactory(new __1.ParseError.InvalidPrimitiveTypeError(state.localizationTemplates, token, state.lexerSnapshot.graphemePositionStartFrom(token)));
        }
    }
    else if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "KeywordType" /* KeywordType */)) {
        primitiveType = common_2.readTokenKindAsConstant(state, "KeywordType" /* KeywordType */, "type" /* Type */);
    }
    else if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "NullLiteral" /* NullLiteral */)) {
        primitiveType = common_2.readTokenKindAsConstant(state, "NullLiteral" /* NullLiteral */, "null" /* Null */);
    }
    else {
        const details = { tokenKind: state.maybeCurrentTokenKind };
        IParserState_1.IParserStateUtils.applyFastStateBackup(state, stateBackup);
        return common_1.ResultUtils.errFactory(new common_1.CommonError.InvariantError(`unknown currentTokenKind, not found in [${expectedTokenKinds}]`, details));
    }
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, primitiveType });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return common_1.ResultUtils.okFactory(astNode);
}
// ------------------------------------
// ---------- Disambiguation ----------
// ------------------------------------
function disambiguateParenthesis(state, parser) {
    const initialTokenIndex = state.tokenIndex;
    const tokens = state.lexerSnapshot.tokens;
    const totalTokens = tokens.length;
    let nestedDepth = 1;
    let offsetTokenIndex = initialTokenIndex + 1;
    while (offsetTokenIndex < totalTokens) {
        const offsetTokenKind = tokens[offsetTokenIndex].kind;
        if (offsetTokenKind === "LeftParenthesis" /* LeftParenthesis */) {
            nestedDepth += 1;
        }
        else if (offsetTokenKind === "RightParenthesis" /* RightParenthesis */) {
            nestedDepth -= 1;
        }
        if (nestedDepth === 0) {
            // '(x as number) as number' could either be either case,
            // so we need to consume test if the trailing 'as number' is followed by a FatArrow.
            if (IParserState_1.IParserStateUtils.isTokenKind(state, "KeywordAs" /* KeywordAs */, offsetTokenIndex + 1)) {
                const stateBackup = IParserState_1.IParserStateUtils.fastStateBackup(state);
                unsafeMoveTo(state, offsetTokenIndex + 2);
                try {
                    parser.readNullablePrimitiveType(state, parser);
                }
                catch (_a) {
                    IParserState_1.IParserStateUtils.applyFastStateBackup(state, stateBackup);
                    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "FatArrow" /* FatArrow */)) {
                        return common_1.ResultUtils.okFactory("FunctionExpression" /* FunctionExpression */);
                    }
                    else {
                        return common_1.ResultUtils.okFactory("ParenthesizedExpression" /* ParenthesizedExpression */);
                    }
                }
                let disambiguation;
                if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "FatArrow" /* FatArrow */)) {
                    disambiguation = "FunctionExpression" /* FunctionExpression */;
                }
                else {
                    disambiguation = "ParenthesizedExpression" /* ParenthesizedExpression */;
                }
                IParserState_1.IParserStateUtils.applyFastStateBackup(state, stateBackup);
                return common_1.ResultUtils.okFactory(disambiguation);
            }
            else {
                if (IParserState_1.IParserStateUtils.isTokenKind(state, "FatArrow" /* FatArrow */, offsetTokenIndex + 1)) {
                    return common_1.ResultUtils.okFactory("FunctionExpression" /* FunctionExpression */);
                }
                else {
                    return common_1.ResultUtils.okFactory("ParenthesizedExpression" /* ParenthesizedExpression */);
                }
            }
        }
        offsetTokenIndex += 1;
    }
    return common_1.ResultUtils.errFactory(IParserState_1.IParserStateUtils.unterminatedParenthesesError(state));
}
exports.disambiguateParenthesis = disambiguateParenthesis;
// WARNING: Only updates tokenIndex and currentTokenKind,
//          Manual management of TokenRangeStack is assumed.
//          Best used in conjunction with backup/restore using ParserState.
function unsafeMoveTo(state, tokenIndex) {
    const tokens = state.lexerSnapshot.tokens;
    state.tokenIndex = tokenIndex;
    if (tokenIndex < tokens.length) {
        state.maybeCurrentToken = tokens[tokenIndex];
        state.maybeCurrentTokenKind = state.maybeCurrentToken.kind;
    }
    else {
        state.maybeCurrentToken = undefined;
        state.maybeCurrentTokenKind = undefined;
    }
}
function disambiguateBracket(state, _parser) {
    const tokens = state.lexerSnapshot.tokens;
    let offsetTokenIndex = state.tokenIndex + 1;
    const offsetToken = tokens[offsetTokenIndex];
    if (!offsetToken) {
        return common_1.ResultUtils.errFactory(IParserState_1.IParserStateUtils.unterminatedBracketError(state));
    }
    let offsetTokenKind = offsetToken.kind;
    if (offsetTokenKind === "LeftBracket" /* LeftBracket */) {
        return common_1.ResultUtils.okFactory("FieldProjection" /* FieldProjection */);
    }
    else if (offsetTokenKind === "RightBracket" /* RightBracket */) {
        return common_1.ResultUtils.okFactory("Record" /* Record */);
    }
    else {
        const totalTokens = tokens.length;
        offsetTokenIndex += 1;
        while (offsetTokenIndex < totalTokens) {
            offsetTokenKind = tokens[offsetTokenIndex].kind;
            if (offsetTokenKind === "Equal" /* Equal */) {
                return common_1.ResultUtils.okFactory("Record" /* Record */);
            }
            else if (offsetTokenKind === "RightBracket" /* RightBracket */) {
                return common_1.ResultUtils.okFactory("FieldSelection" /* FieldSelection */);
            }
            offsetTokenIndex += 1;
        }
        return common_1.ResultUtils.errFactory(IParserState_1.IParserStateUtils.unterminatedBracketError(state));
    }
}
exports.disambiguateBracket = disambiguateBracket;
// -------------------------------------
// ---------- key-value pairs ----------
// -------------------------------------
function readIdentifierPairedExpressions(state, parser, continueReadingValues, testPostCommaError) {
    return readCsvArray(state, () => parser.readIdentifierPairedExpression(state, parser), continueReadingValues, testPostCommaError);
}
exports.readIdentifierPairedExpressions = readIdentifierPairedExpressions;
function readGeneralizedIdentifierPairedExpressions(state, parser, continueReadingValues, testPostCommaError) {
    return readCsvArray(state, () => parser.readGeneralizedIdentifierPairedExpression(state, parser), continueReadingValues, testPostCommaError);
}
exports.readGeneralizedIdentifierPairedExpressions = readGeneralizedIdentifierPairedExpressions;
function readGeneralizedIdentifierPairedExpression(state, parser) {
    return readKeyValuePair(state, "GeneralizedIdentifierPairedExpression" /* GeneralizedIdentifierPairedExpression */, () => parser.readGeneralizedIdentifier(state, parser), () => parser.readExpression(state, parser));
}
exports.readGeneralizedIdentifierPairedExpression = readGeneralizedIdentifierPairedExpression;
function readIdentifierPairedExpression(state, parser) {
    return readKeyValuePair(state, "IdentifierPairedExpression" /* IdentifierPairedExpression */, () => parser.readIdentifier(state, parser), () => parser.readExpression(state, parser));
}
exports.readIdentifierPairedExpression = readIdentifierPairedExpression;
// ---------------------------------------------------------------
// ---------- Helper functions (generic read functions) ----------
// ---------------------------------------------------------------
// Given the string `1 + 2 + 3` the function will parse the `1 +`,
// then pass the remainder of the string `2 + 3` into recursiveReadBinOpExpressionHelper.
// The helper function is nearly a copy except it replaces Left and leftReader with Right and rightReader.
//
// The reason the code is duplicated across two functions is because I can't think of a cleaner way to do it.
function recursiveReadBinOpExpression(state, nodeKind, leftReader, maybeOperatorFrom, rightReader) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const left = leftReader();
    // If no operator, return Left
    const maybeOperator = maybeOperatorFrom(state.maybeCurrentTokenKind);
    if (maybeOperator === undefined) {
        IParserState_1.IParserStateUtils.deleteContext(state, undefined);
        return left;
    }
    const operatorConstant = common_2.readTokenKindAsConstant(state, state.maybeCurrentTokenKind, maybeOperator);
    const right = recursiveReadBinOpExpressionHelper(state, nodeKind, maybeOperatorFrom, rightReader);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, left,
        operatorConstant,
        right });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
// Given the string `1 + 2 + 3` the function will recursively parse 2 Ast nodes,
// where their TokenRange's are represented by brackets:
// 1 + [2 + [3]]
function recursiveReadBinOpExpressionHelper(state, nodeKind, maybeOperatorFrom, rightReader) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const rightAsLeft = rightReader();
    const maybeOperator = maybeOperatorFrom(state.maybeCurrentTokenKind);
    if (maybeOperator === undefined) {
        IParserState_1.IParserStateUtils.deleteContext(state, undefined);
        return rightAsLeft;
    }
    const operatorConstant = common_2.readTokenKindAsConstant(state, state.maybeCurrentTokenKind, maybeOperator);
    const right = recursiveReadBinOpExpressionHelper(state, nodeKind, maybeOperatorFrom, rightReader);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, left: rightAsLeft, operatorConstant,
        right });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
function readCsvArray(state, valueReader, continueReadingValues, testPostCommaError) {
    const nodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const elements = [];
    while (continueReadingValues) {
        const csvNodeKind = "Csv" /* Csv */;
        IParserState_1.IParserStateUtils.startContext(state, csvNodeKind);
        const maybeErr = testPostCommaError(state);
        if (maybeErr) {
            throw maybeErr;
        }
        const node = valueReader();
        const maybeCommaConstant = common_2.maybeReadTokenKindAsConstant(state, "Comma" /* Comma */, "," /* Comma */);
        const element = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: csvNodeKind, isLeaf: false, node,
            maybeCommaConstant });
        IParserState_1.IParserStateUtils.endContext(state, element);
        elements.push(element);
        continueReadingValues = maybeCommaConstant !== undefined;
    }
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, elements });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
function readKeyValuePair(state, nodeKind, keyReader, valueReader) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const key = keyReader();
    const equalConstant = common_2.readTokenKindAsConstant(state, "Equal" /* Equal */, "=" /* Equal */);
    const value = valueReader();
    const keyValuePair = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, key,
        equalConstant,
        value });
    IParserState_1.IParserStateUtils.endContext(state, keyValuePair);
    return keyValuePair;
}
function readPairedConstant(state, nodeKind, constantReader, pairedReader) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const constant = constantReader();
    const paired = pairedReader();
    const pairedConstant = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, constant,
        paired });
    IParserState_1.IParserStateUtils.endContext(state, pairedConstant);
    return pairedConstant;
}
function maybeReadPairedConstant(state, nodeKind, condition, constantReader, pairedReader) {
    if (condition()) {
        return readPairedConstant(state, nodeKind, constantReader, pairedReader);
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
        return undefined;
    }
}
function genericReadParameterList(state, parser, typeReader) {
    const nodeKind = "ParameterList" /* ParameterList */;
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const leftParenthesisConstant = common_2.readTokenKindAsConstant(state, "LeftParenthesis" /* LeftParenthesis */, "(" /* LeftParenthesis */);
    let continueReadingValues = !IParserState_1.IParserStateUtils.isOnTokenKind(state, "RightParenthesis" /* RightParenthesis */);
    let reachedOptionalParameter = false;
    const paramterArrayNodeKind = "ArrayWrapper" /* ArrayWrapper */;
    IParserState_1.IParserStateUtils.startContext(state, paramterArrayNodeKind);
    const parameters = [];
    while (continueReadingValues) {
        IParserState_1.IParserStateUtils.startContext(state, "Csv" /* Csv */);
        IParserState_1.IParserStateUtils.startContext(state, "Parameter" /* Parameter */);
        const maybeErr = testCsvContinuationDanglingCommaForParenthesis(state);
        if (maybeErr) {
            throw maybeErr;
        }
        const maybeOptionalConstant = maybeReadConstantKind(state, "optional" /* Optional */);
        if (reachedOptionalParameter && !maybeOptionalConstant) {
            const token = IParserState_1.IParserStateUtils.expectTokenAt(state, state.tokenIndex);
            throw new __1.ParseError.RequiredParameterAfterOptionalParameterError(state.localizationTemplates, token, state.lexerSnapshot.graphemePositionStartFrom(token));
        }
        else if (maybeOptionalConstant) {
            reachedOptionalParameter = true;
        }
        const name = parser.readIdentifier(state, parser);
        const maybeParameterType = typeReader();
        const parameter = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: "Parameter" /* Parameter */, isLeaf: false, maybeOptionalConstant,
            name,
            maybeParameterType });
        IParserState_1.IParserStateUtils.endContext(state, parameter);
        const maybeCommaConstant = common_2.maybeReadTokenKindAsConstant(state, "Comma" /* Comma */, "," /* Comma */);
        continueReadingValues = maybeCommaConstant !== undefined;
        const csv = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: "Csv" /* Csv */, isLeaf: false, node: parameter, maybeCommaConstant });
        IParserState_1.IParserStateUtils.endContext(state, csv);
        parameters.push(csv);
    }
    const parameterArray = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: paramterArrayNodeKind, elements: parameters, isLeaf: false });
    IParserState_1.IParserStateUtils.endContext(state, parameterArray);
    const rightParenthesisConstant = common_2.readTokenKindAsConstant(state, "RightParenthesis" /* RightParenthesis */, ")" /* RightParenthesis */);
    const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, openWrapperConstant: leftParenthesisConstant, content: parameterArray, closeWrapperConstant: rightParenthesisConstant });
    IParserState_1.IParserStateUtils.endContext(state, astNode);
    return astNode;
}
function readWrapped(state, nodeKind, openConstantReader, contentReader, closeConstantReader, allowOptionalConstant) {
    IParserState_1.IParserStateUtils.startContext(state, nodeKind);
    const openWrapperConstant = openConstantReader();
    const content = contentReader();
    const closeWrapperConstant = closeConstantReader();
    let maybeOptionalConstant;
    if (allowOptionalConstant) {
        maybeOptionalConstant = common_2.maybeReadTokenKindAsConstant(state, "QuestionMark" /* QuestionMark */, "?" /* QuestionMark */);
    }
    const wrapped = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: false, openWrapperConstant,
        content,
        closeWrapperConstant,
        maybeOptionalConstant });
    IParserState_1.IParserStateUtils.endContext(state, wrapped);
    return wrapped;
}
// -------------------------------------------------------
// ---------- Helper functions (read functions) ----------
// -------------------------------------------------------
function readTokenKind(state, tokenKind) {
    const maybeErr = IParserState_1.IParserStateUtils.testIsOnTokenKind(state, tokenKind);
    if (maybeErr) {
        throw maybeErr;
    }
    return common_2.readToken(state);
}
function readConstantKind(state, constantKind) {
    const maybeConstant = maybeReadConstantKind(state, constantKind);
    if (!maybeConstant) {
        const details = { constantKind };
        throw new common_1.CommonError.InvariantError(`couldn't convert constantKind`, details);
    }
    return maybeConstant;
}
function maybeReadConstantKind(state, constantKind) {
    if (IParserState_1.IParserStateUtils.isOnConstantKind(state, constantKind)) {
        const nodeKind = "Constant" /* Constant */;
        IParserState_1.IParserStateUtils.startContext(state, nodeKind);
        common_2.readToken(state);
        const astNode = Object.assign(Object.assign({}, IParserState_1.IParserStateUtils.expectContextNodeMetadata(state)), { kind: nodeKind, isLeaf: true, constantKind });
        IParserState_1.IParserStateUtils.endContext(state, astNode);
        return astNode;
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
        return undefined;
    }
}
function maybeReadLiteralAttributes(state, parser) {
    if (IParserState_1.IParserStateUtils.isOnTokenKind(state, "LeftBracket" /* LeftBracket */)) {
        return parser.readRecordLiteral(state, parser);
    }
    else {
        IParserState_1.IParserStateUtils.incrementAttributeCounter(state);
        return undefined;
    }
}
// -------------------------------------------------------
// ---------- Helper functions (test functions) ----------
// -------------------------------------------------------
function testCsvContinuationDanglingCommaForBrace(state) {
    return IParserState_1.IParserStateUtils.testCsvContinuationDanglingComma(state, "RightBrace" /* RightBrace */);
}
function testCsvContinuationDanglingCommaForBracket(state) {
    return IParserState_1.IParserStateUtils.testCsvContinuationDanglingComma(state, "RightBracket" /* RightBracket */);
}
function testCsvContinuationDanglingCommaForParenthesis(state) {
    return IParserState_1.IParserStateUtils.testCsvContinuationDanglingComma(state, "RightParenthesis" /* RightParenthesis */);
}
//# sourceMappingURL=naive.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/recursiveDescentParser.js":
/*!****************************************************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/recursiveDescentParser.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/parsers/index.js");
exports.RecursiveDescentParser = {
    // 12.1.6 Identifiers
    readIdentifier: _1.Naive.readIdentifier,
    readGeneralizedIdentifier: _1.Naive.readGeneralizedIdentifier,
    readKeyword: _1.Naive.readKeyword,
    // 12.2.1 Documents
    readDocument: _1.Naive.readDocument,
    // 12.2.2 Section Documents
    readSectionDocument: _1.Naive.readSectionDocument,
    readSectionMembers: _1.Naive.readSectionMembers,
    readSectionMember: _1.Naive.readSectionMember,
    // 12.2.3.1 Expressions
    readExpression: _1.Naive.readExpression,
    // 12.2.3.2 Logical expressions
    readLogicalExpression: _1.Naive.readLogicalExpression,
    // 12.2.3.3 Is expression
    readIsExpression: _1.Naive.readIsExpression,
    readNullablePrimitiveType: _1.Naive.readNullablePrimitiveType,
    // 12.2.3.4 As expression
    readAsExpression: _1.Naive.readAsExpression,
    // 12.2.3.5 Equality expression
    readEqualityExpression: _1.Naive.readEqualityExpression,
    // 12.2.3.6 Relational expression
    readRelationalExpression: _1.Naive.readRelationalExpression,
    // 12.2.3.7 Arithmetic expressions
    readArithmeticExpression: _1.Naive.readArithmeticExpression,
    // 12.2.3.8 Metadata expression
    readMetadataExpression: _1.Naive.readMetadataExpression,
    // 12.2.3.9 Unary expression
    readUnaryExpression: _1.Naive.readUnaryExpression,
    // 12.2.3.10 Primary expression
    readPrimaryExpression: _1.Naive.readPrimaryExpression,
    readRecursivePrimaryExpression: _1.Naive.readRecursivePrimaryExpression,
    // 12.2.3.11 Literal expression
    readLiteralExpression: _1.Naive.readLiteralExpression,
    // 12.2.3.12 Identifier expression
    readIdentifierExpression: _1.Naive.readIdentifierExpression,
    // 12.2.3.14 Parenthesized expression
    readParenthesizedExpression: _1.Naive.readParenthesizedExpression,
    // 12.2.3.15 Not-implemented expression
    readNotImplementedExpression: _1.Naive.readNotImplementedExpression,
    // 12.2.3.16 Invoke expression
    readInvokeExpression: _1.Naive.readInvokeExpression,
    // 12.2.3.17 List expression
    readListExpression: _1.Naive.readListExpression,
    readListItem: _1.Naive.readListItem,
    // 12.2.3.18 Record expression
    readRecordExpression: _1.Naive.readRecordExpression,
    // 12.2.3.19 Item access expression
    readItemAccessExpression: _1.Naive.readItemAccessExpression,
    // 12.2.3.20 Field access expression
    readFieldSelection: _1.Naive.readFieldSelection,
    readFieldProjection: _1.Naive.readFieldProjection,
    readFieldSelector: _1.Naive.readFieldSelector,
    // 12.2.3.21 Function expression
    readFunctionExpression: _1.Naive.readFunctionExpression,
    readParameterList: _1.Naive.readParameterList,
    readAsType: _1.Naive.readAsType,
    // 12.2.3.22 Each expression
    readEachExpression: _1.Naive.readEachExpression,
    // 12.2.3.23 Let expression
    readLetExpression: _1.Naive.readLetExpression,
    // 12.2.3.24 If expression
    readIfExpression: _1.Naive.readIfExpression,
    // 12.2.3.25 Type expression
    readTypeExpression: _1.Naive.readTypeExpression,
    readType: _1.Naive.readType,
    readPrimaryType: _1.Naive.readPrimaryType,
    readRecordType: _1.Naive.readRecordType,
    readTableType: _1.Naive.readTableType,
    readFieldSpecificationList: _1.Naive.readFieldSpecificationList,
    readListType: _1.Naive.readListType,
    readFunctionType: _1.Naive.readFunctionType,
    readParameterSpecificationList: _1.Naive.readParameterSpecificationList,
    readNullableType: _1.Naive.readNullableType,
    // 12.2.3.26 Error raising expression
    readErrorRaisingExpression: _1.Naive.readErrorRaisingExpression,
    // 12.2.3.27 Error handling expression
    readErrorHandlingExpression: _1.Naive.readErrorHandlingExpression,
    // 12.2.4 Literal Attributes
    readRecordLiteral: _1.Naive.readRecordLiteral,
    readFieldNamePairedAnyLiterals: _1.Naive.readFieldNamePairedAnyLiterals,
    readListLiteral: _1.Naive.readListLiteral,
    readAnyLiteral: _1.Naive.readAnyLiteral,
    readPrimitiveType: _1.Naive.readPrimitiveType,
    // Disambiguation
    disambiguateBracket: _1.Naive.disambiguateBracket,
    disambiguateParenthesis: _1.Naive.disambiguateParenthesis,
    // key-value pairs
    readIdentifierPairedExpressions: _1.Naive.readIdentifierPairedExpressions,
    readGeneralizedIdentifierPairedExpressions: _1.Naive.readGeneralizedIdentifierPairedExpressions,
    readGeneralizedIdentifierPairedExpression: _1.Naive.readGeneralizedIdentifierPairedExpression,
    readIdentifierPairedExpression: _1.Naive.readIdentifierPairedExpression,
};
//# sourceMappingURL=recursiveDescentParser.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/settings.js":
/*!***********************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/settings.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const localization_1 = __webpack_require__(/*! ./localization */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/localization/index.js");
const parser_1 = __webpack_require__(/*! ./parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/parser/index.js");
exports.DefaultSettings = {
    parser: parser_1.Parser.CombinatorialParser,
    newParserState: (parseSettings, lexerSnapshot) => parser_1.IParserStateUtils.newState(parseSettings, lexerSnapshot),
    localizationTemplates: localization_1.DefaultTemplates,
};
//# sourceMappingURL=settings.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/tasks.js":
/*!********************************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/tasks.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = __webpack_require__(/*! . */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const common_1 = __webpack_require__(/*! ./common */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/common/index.js");
const lexer_1 = __webpack_require__(/*! ./lexer */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/lexer/index.js");
function tryLex(settings, text) {
    const state = lexer_1.Lexer.stateFrom(settings, text);
    const maybeErrorLineMap = lexer_1.Lexer.maybeErrorLineMap(state);
    if (maybeErrorLineMap) {
        const errorLineMap = maybeErrorLineMap;
        return common_1.ResultUtils.errFactory(new lexer_1.LexError.LexError(new lexer_1.LexError.ErrorLineMapError(settings.localizationTemplates, errorLineMap)));
    }
    return lexer_1.LexerSnapshot.tryFrom(state);
}
exports.tryLex = tryLex;
function tryParse(settings, lexerSnapshot) {
    const parser = settings.parser;
    const parserState = settings.newParserState(settings, lexerSnapshot);
    return parser.readDocument(parserState, parser);
}
exports.tryParse = tryParse;
function tryInspection(settings, triedParse, position) {
    let leafNodeIds;
    let nodeIdMapCollection;
    let maybeParseError;
    if (common_1.ResultUtils.isErr(triedParse)) {
        if (triedParse.error instanceof common_1.CommonError.CommonError) {
            // Returning triedParse /should/ be safe, but Typescript has a problem with it.
            // However, if I repackage the same error it satisfies the type check.
            // There's no harm in having to repackage the error, and by not casting it we can prevent
            // future regressions if TriedParse changes.
            return common_1.ResultUtils.errFactory(triedParse.error);
        }
        else {
            maybeParseError = triedParse.error;
        }
        const context = triedParse.error.state.contextState;
        leafNodeIds = context.leafNodeIds;
        nodeIdMapCollection = context.nodeIdMapCollection;
    }
    else {
        const parseOk = triedParse.value;
        leafNodeIds = parseOk.leafNodeIds;
        nodeIdMapCollection = parseOk.nodeIdMapCollection;
    }
    return _1.Inspection.tryFrom(settings, position, nodeIdMapCollection, leafNodeIds, maybeParseError);
}
exports.tryInspection = tryInspection;
function tryLexParse(settings, text) {
    const triedLexerSnapshot = tryLex(settings, text);
    if (common_1.ResultUtils.isErr(triedLexerSnapshot)) {
        return triedLexerSnapshot;
    }
    const lexerSnapshot = triedLexerSnapshot.value;
    const triedParse = tryParse(settings, lexerSnapshot);
    if (common_1.ResultUtils.isOk(triedParse)) {
        return common_1.ResultUtils.okFactory(Object.assign(Object.assign({}, triedParse.value), { lexerSnapshot }));
    }
    else {
        return triedParse;
    }
}
exports.tryLexParse = tryLexParse;
function tryLexParseInspection(settings, text, position) {
    const triedLexParse = tryLexParse(settings, text);
    if (common_1.ResultUtils.isErr(triedLexParse) && triedLexParse.error instanceof lexer_1.LexError.LexError) {
        return triedLexParse;
    }
    // The if statement above should remove LexError from the error type in Result<T, E>
    const casted = triedLexParse;
    const triedInspection = tryInspection(settings, casted, position);
    if (common_1.ResultUtils.isErr(triedInspection)) {
        return triedInspection;
    }
    return common_1.ResultUtils.okFactory(Object.assign(Object.assign({}, triedInspection.value), { triedParse: casted }));
}
exports.tryLexParseInspection = tryLexParseInspection;
//# sourceMappingURL=tasks.js.map

/***/ }),

/***/ "../packages/powerquery-format/node_modules/grapheme-splitter/index.js":
/*!*****************************************************************************!*\
  !*** ../packages/powerquery-format/node_modules/grapheme-splitter/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
Breaks a Javascript string into individual user-perceived "characters" 
called extended grapheme clusters by implementing the Unicode UAX-29 standard, version 10.0.0

Usage:
var splitter = new GraphemeSplitter();
//returns an array of strings, one string for each grapheme cluster
var graphemes = splitter.splitGraphemes(string); 

*/
function GraphemeSplitter(){
	var CR = 0,
		LF = 1,
		Control = 2,
		Extend = 3,
		Regional_Indicator = 4,
		SpacingMark = 5,
		L = 6,
		V = 7,
		T = 8,
		LV = 9,
		LVT = 10,
		Other = 11,
		Prepend = 12,
		E_Base = 13,
		E_Modifier = 14,
		ZWJ = 15,
		Glue_After_Zwj = 16,
		E_Base_GAZ = 17;
		
	// BreakTypes
	var NotBreak = 0,
		BreakStart = 1,
		Break = 2,
		BreakLastRegional = 3,
		BreakPenultimateRegional = 4;
		
	function isSurrogate(str, pos) {
		return  0xd800 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 0xdbff && 
				0xdc00 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 0xdfff;
	}
		
	// Private function, gets a Unicode code point from a JavaScript UTF-16 string
	// handling surrogate pairs appropriately
	function codePointAt(str, idx){
		if(idx === undefined){
			idx = 0;
		}
		var code = str.charCodeAt(idx);

		// if a high surrogate
		if (0xD800 <= code && code <= 0xDBFF && 
			idx < str.length - 1){
			var hi = code;
			var low = str.charCodeAt(idx + 1);
			if (0xDC00 <= low && low <= 0xDFFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return hi;
		}
		
		// if a low surrogate
		if (0xDC00 <= code && code <= 0xDFFF &&
			idx >= 1){
			var hi = str.charCodeAt(idx - 1);
			var low = code;
			if (0xD800 <= hi && hi <= 0xDBFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return low;
		}
		
		//just return the char if an unmatched surrogate half or a 
		//single-char codepoint
		return code;
	}
	
	// Private function, returns whether a break is allowed between the 
	// two given grapheme breaking classes
	function shouldBreak(start, mid, end){
		var all = [start].concat(mid).concat([end]);
		var previous = all[all.length - 2]
		var next = end
		
		// Lookahead termintor for:
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var eModifierIndex = all.lastIndexOf(E_Modifier)
		if(eModifierIndex > 1 &&
			all.slice(1, eModifierIndex).every(function(c){return c == Extend}) &&
			[Extend, E_Base, E_Base_GAZ].indexOf(start) == -1){
			return Break
		}

		// Lookahead termintor for:
		// GB12. ^ (RI RI)* RI	?	RI
		// GB13. [^RI] (RI RI)* RI	?	RI
		var rIIndex = all.lastIndexOf(Regional_Indicator)
		if(rIIndex > 0 &&
			all.slice(1, rIIndex).every(function(c){return c == Regional_Indicator}) &&
			[Prepend, Regional_Indicator].indexOf(previous) == -1) { 
			if(all.filter(function(c){return c == Regional_Indicator}).length % 2 == 1) {
				return BreakLastRegional
			}
			else {
				return BreakPenultimateRegional
			}
		}
		
		// GB3. CR X LF
		if(previous == CR && next == LF){
			return NotBreak;
		}
		// GB4. (Control|CR|LF) 
		else if(previous == Control || previous == CR || previous == LF){
			if(next == E_Modifier && mid.every(function(c){return c == Extend})){
				return Break
			}
			else {
				return BreakStart
			}
		}
		// GB5.  (Control|CR|LF)
		else if(next == Control || next == CR || next == LF){
			return BreakStart;
		}
		// GB6. L X (L|V|LV|LVT)
		else if(previous == L && 
			(next == L || next == V || next == LV || next == LVT)){
			return NotBreak;
		}
		// GB7. (LV|V) X (V|T)
		else if((previous == LV || previous == V) && 
			(next == V || next == T)){
			return NotBreak;
		}
		// GB8. (LVT|T) X (T)
		else if((previous == LVT || previous == T) && 
			next == T){
			return NotBreak;
		}
		// GB9. X (Extend|ZWJ)
		else if (next == Extend || next == ZWJ){
			return NotBreak;
		}
		// GB9a. X SpacingMark
		else if(next == SpacingMark){
			return NotBreak;
		}
		// GB9b. Prepend X
		else if (previous == Prepend){
			return NotBreak;
		}
		
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
		if([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 &&
			all.slice(previousNonExtendIndex + 1, -1).every(function(c){return c == Extend}) &&
			next == E_Modifier){
			return NotBreak;
		}
		
		// GB11. ZWJ ? (Glue_After_Zwj | EBG)
		if(previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
			return NotBreak;
		}

		// GB12. ^ (RI RI)* RI ? RI
		// GB13. [^RI] (RI RI)* RI ? RI
		if(mid.indexOf(Regional_Indicator) != -1) { 
			return Break;
		}
		if(previous == Regional_Indicator && next == Regional_Indicator) {
			return NotBreak;
		}

		// GB999. Any ? Any
		return BreakStart;
	}
	
	// Returns the next grapheme break in the string after the given index
	this.nextBreak = function(string, index){
		if(index === undefined){
			index = 0;
		}
		if(index < 0){
			return 0;
		}
		if(index >= string.length - 1){
			return string.length;
		}
		var prev = getGraphemeBreakProperty(codePointAt(string, index));
		var mid = []
		for (var i = index + 1; i < string.length; i++) {
			// check for already processed low surrogates
			if(isSurrogate(string, i - 1)){
				continue;
			}
		
			var next = getGraphemeBreakProperty(codePointAt(string, i));
			if(shouldBreak(prev, mid, next)){
				return i;
			}
			
			mid.push(next);
		}
		return string.length;
	};
	
	// Breaks the given string into an array of grapheme cluster strings
	this.splitGraphemes = function(str){
		var res = [];
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			res.push(str.slice(index, brk));
			index = brk;
		}
		if(index < str.length){
			res.push(str.slice(index));
		}
		return res;
	};

	// Returns the iterator of grapheme clusters there are in the given string
	this.iterateGraphemes = function(str) {
		var index = 0;
		var res = {
			next: (function() {
				var value;
				var brk;
				if ((brk = this.nextBreak(str, index)) < str.length) {
					value = str.slice(index, brk);
					index = brk;
					return { value: value, done: false };
				}
				if (index < str.length) {
					value = str.slice(index);
					index = str.length;
					return { value: value, done: false };
				}
				return { value: undefined, done: true };
			}).bind(this)
		};
		// ES2015 @@iterator method (iterable) for spread syntax and for...of statement
		if (typeof Symbol !== 'undefined' && Symbol.iterator) {
			res[Symbol.iterator] = function() {return res};
		}
		return res;
	};

	// Returns the number of grapheme clusters there are in the given string
	this.countGraphemes = function(str){
		var count = 0;
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			index = brk;
			count++;
		}
		if(index < str.length){
			count++;
		}
		return count;
	};
	
	//given a Unicode code point, determines this symbol's grapheme break property
	function getGraphemeBreakProperty(code){
		
		//grapheme break property for Unicode 10.0.0, 
		//taken from http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
		//and adapted to JavaScript rules
		
		if(		
		(0x0600 <= code && code <= 0x0605) || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
		0x06DD == code || // Cf       ARABIC END OF AYAH
		0x070F == code || // Cf       SYRIAC ABBREVIATION MARK
		0x08E2 == code || // Cf       ARABIC DISPUTED END OF AYAH
		0x0D4E == code || // Lo       MALAYALAM LETTER DOT REPH
		0x110BD == code || // Cf       KAITHI NUMBER SIGN
		(0x111C2 <= code && code <= 0x111C3) || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
		0x11A3A == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
		(0x11A86 <= code && code <= 0x11A89) || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
		0x11D46 == code // Lo       MASARAM GONDI REPHA
		){
			return Prepend;
		}
		if(
		0x000D == code // Cc       <control-000D>
		){
			return CR;
		}
		
		if(
		0x000A == code // Cc       <control-000A>
		){
			return LF;
		}
		
		
		if(
		(0x0000 <= code && code <= 0x0009) || // Cc  [10] <control-0000>..<control-0009>
		(0x000B <= code && code <= 0x000C) || // Cc   [2] <control-000B>..<control-000C>
		(0x000E <= code && code <= 0x001F) || // Cc  [18] <control-000E>..<control-001F>
		(0x007F <= code && code <= 0x009F) || // Cc  [33] <control-007F>..<control-009F>
		0x00AD == code || // Cf       SOFT HYPHEN
		0x061C == code || // Cf       ARABIC LETTER MARK
	
		0x180E == code || // Cf       MONGOLIAN VOWEL SEPARATOR
		0x200B == code || // Cf       ZERO WIDTH SPACE
		(0x200E <= code && code <= 0x200F) || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
		0x2028 == code || // Zl       LINE SEPARATOR
		0x2029 == code || // Zp       PARAGRAPH SEPARATOR
		(0x202A <= code && code <= 0x202E) || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
		(0x2060 <= code && code <= 0x2064) || // Cf   [5] WORD JOINER..INVISIBLE PLUS
		0x2065 == code || // Cn       <reserved-2065>
		(0x2066 <= code && code <= 0x206F) || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
		(0xD800 <= code && code <= 0xDFFF) || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
		0xFEFF == code || // Cf       ZERO WIDTH NO-BREAK SPACE
		(0xFFF0 <= code && code <= 0xFFF8) || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
		(0xFFF9 <= code && code <= 0xFFFB) || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
		(0x1BCA0 <= code && code <= 0x1BCA3) || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
		(0x1D173 <= code && code <= 0x1D17A) || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
		0xE0000 == code || // Cn       <reserved-E0000>
		0xE0001 == code || // Cf       LANGUAGE TAG
		(0xE0002 <= code && code <= 0xE001F) || // Cn  [30] <reserved-E0002>..<reserved-E001F>
		(0xE0080 <= code && code <= 0xE00FF) || // Cn [128] <reserved-E0080>..<reserved-E00FF>
		(0xE01F0 <= code && code <= 0xE0FFF) // Cn [3600] <reserved-E01F0>..<reserved-E0FFF>
		){
			return Control;
		}
		
		
		if(
		(0x0300 <= code && code <= 0x036F) || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
		(0x0483 <= code && code <= 0x0487) || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
		(0x0488 <= code && code <= 0x0489) || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
		(0x0591 <= code && code <= 0x05BD) || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
		0x05BF == code || // Mn       HEBREW POINT RAFE
		(0x05C1 <= code && code <= 0x05C2) || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
		(0x05C4 <= code && code <= 0x05C5) || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
		0x05C7 == code || // Mn       HEBREW POINT QAMATS QATAN
		(0x0610 <= code && code <= 0x061A) || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
		(0x064B <= code && code <= 0x065F) || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
		0x0670 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
		(0x06D6 <= code && code <= 0x06DC) || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
		(0x06DF <= code && code <= 0x06E4) || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
		(0x06E7 <= code && code <= 0x06E8) || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
		(0x06EA <= code && code <= 0x06ED) || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
		0x0711 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
		(0x0730 <= code && code <= 0x074A) || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
		(0x07A6 <= code && code <= 0x07B0) || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
		(0x07EB <= code && code <= 0x07F3) || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
		(0x0816 <= code && code <= 0x0819) || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
		(0x081B <= code && code <= 0x0823) || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
		(0x0825 <= code && code <= 0x0827) || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
		(0x0829 <= code && code <= 0x082D) || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
		(0x0859 <= code && code <= 0x085B) || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
		(0x08D4 <= code && code <= 0x08E1) || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
		(0x08E3 <= code && code <= 0x0902) || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
		0x093A == code || // Mn       DEVANAGARI VOWEL SIGN OE
		0x093C == code || // Mn       DEVANAGARI SIGN NUKTA
		(0x0941 <= code && code <= 0x0948) || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
		0x094D == code || // Mn       DEVANAGARI SIGN VIRAMA
		(0x0951 <= code && code <= 0x0957) || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
		(0x0962 <= code && code <= 0x0963) || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
		0x0981 == code || // Mn       BENGALI SIGN CANDRABINDU
		0x09BC == code || // Mn       BENGALI SIGN NUKTA
		0x09BE == code || // Mc       BENGALI VOWEL SIGN AA
		(0x09C1 <= code && code <= 0x09C4) || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
		0x09CD == code || // Mn       BENGALI SIGN VIRAMA
		0x09D7 == code || // Mc       BENGALI AU LENGTH MARK
		(0x09E2 <= code && code <= 0x09E3) || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
		(0x0A01 <= code && code <= 0x0A02) || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
		0x0A3C == code || // Mn       GURMUKHI SIGN NUKTA
		(0x0A41 <= code && code <= 0x0A42) || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
		(0x0A47 <= code && code <= 0x0A48) || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
		(0x0A4B <= code && code <= 0x0A4D) || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
		0x0A51 == code || // Mn       GURMUKHI SIGN UDAAT
		(0x0A70 <= code && code <= 0x0A71) || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
		0x0A75 == code || // Mn       GURMUKHI SIGN YAKASH
		(0x0A81 <= code && code <= 0x0A82) || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
		0x0ABC == code || // Mn       GUJARATI SIGN NUKTA
		(0x0AC1 <= code && code <= 0x0AC5) || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
		(0x0AC7 <= code && code <= 0x0AC8) || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
		0x0ACD == code || // Mn       GUJARATI SIGN VIRAMA
		(0x0AE2 <= code && code <= 0x0AE3) || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
		(0x0AFA <= code && code <= 0x0AFF) || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
		0x0B01 == code || // Mn       ORIYA SIGN CANDRABINDU
		0x0B3C == code || // Mn       ORIYA SIGN NUKTA
		0x0B3E == code || // Mc       ORIYA VOWEL SIGN AA
		0x0B3F == code || // Mn       ORIYA VOWEL SIGN I
		(0x0B41 <= code && code <= 0x0B44) || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
		0x0B4D == code || // Mn       ORIYA SIGN VIRAMA
		0x0B56 == code || // Mn       ORIYA AI LENGTH MARK
		0x0B57 == code || // Mc       ORIYA AU LENGTH MARK
		(0x0B62 <= code && code <= 0x0B63) || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
		0x0B82 == code || // Mn       TAMIL SIGN ANUSVARA
		0x0BBE == code || // Mc       TAMIL VOWEL SIGN AA
		0x0BC0 == code || // Mn       TAMIL VOWEL SIGN II
		0x0BCD == code || // Mn       TAMIL SIGN VIRAMA
		0x0BD7 == code || // Mc       TAMIL AU LENGTH MARK
		0x0C00 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
		(0x0C3E <= code && code <= 0x0C40) || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
		(0x0C46 <= code && code <= 0x0C48) || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
		(0x0C4A <= code && code <= 0x0C4D) || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
		(0x0C55 <= code && code <= 0x0C56) || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
		(0x0C62 <= code && code <= 0x0C63) || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
		0x0C81 == code || // Mn       KANNADA SIGN CANDRABINDU
		0x0CBC == code || // Mn       KANNADA SIGN NUKTA
		0x0CBF == code || // Mn       KANNADA VOWEL SIGN I
		0x0CC2 == code || // Mc       KANNADA VOWEL SIGN UU
		0x0CC6 == code || // Mn       KANNADA VOWEL SIGN E
		(0x0CCC <= code && code <= 0x0CCD) || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
		(0x0CD5 <= code && code <= 0x0CD6) || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
		(0x0CE2 <= code && code <= 0x0CE3) || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
		(0x0D00 <= code && code <= 0x0D01) || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
		(0x0D3B <= code && code <= 0x0D3C) || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
		0x0D3E == code || // Mc       MALAYALAM VOWEL SIGN AA
		(0x0D41 <= code && code <= 0x0D44) || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
		0x0D4D == code || // Mn       MALAYALAM SIGN VIRAMA
		0x0D57 == code || // Mc       MALAYALAM AU LENGTH MARK
		(0x0D62 <= code && code <= 0x0D63) || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
		0x0DCA == code || // Mn       SINHALA SIGN AL-LAKUNA
		0x0DCF == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
		(0x0DD2 <= code && code <= 0x0DD4) || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
		0x0DD6 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
		0x0DDF == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
		0x0E31 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
		(0x0E34 <= code && code <= 0x0E3A) || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
		(0x0E47 <= code && code <= 0x0E4E) || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
		0x0EB1 == code || // Mn       LAO VOWEL SIGN MAI KAN
		(0x0EB4 <= code && code <= 0x0EB9) || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
		(0x0EBB <= code && code <= 0x0EBC) || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
		(0x0EC8 <= code && code <= 0x0ECD) || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
		(0x0F18 <= code && code <= 0x0F19) || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
		0x0F35 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
		0x0F37 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
		0x0F39 == code || // Mn       TIBETAN MARK TSA -PHRU
		(0x0F71 <= code && code <= 0x0F7E) || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
		(0x0F80 <= code && code <= 0x0F84) || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
		(0x0F86 <= code && code <= 0x0F87) || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
		(0x0F8D <= code && code <= 0x0F97) || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
		(0x0F99 <= code && code <= 0x0FBC) || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
		0x0FC6 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
		(0x102D <= code && code <= 0x1030) || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
		(0x1032 <= code && code <= 0x1037) || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
		(0x1039 <= code && code <= 0x103A) || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
		(0x103D <= code && code <= 0x103E) || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
		(0x1058 <= code && code <= 0x1059) || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
		(0x105E <= code && code <= 0x1060) || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
		(0x1071 <= code && code <= 0x1074) || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
		0x1082 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
		(0x1085 <= code && code <= 0x1086) || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
		0x108D == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
		0x109D == code || // Mn       MYANMAR VOWEL SIGN AITON AI
		(0x135D <= code && code <= 0x135F) || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
		(0x1712 <= code && code <= 0x1714) || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
		(0x1732 <= code && code <= 0x1734) || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
		(0x1752 <= code && code <= 0x1753) || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
		(0x1772 <= code && code <= 0x1773) || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
		(0x17B4 <= code && code <= 0x17B5) || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
		(0x17B7 <= code && code <= 0x17BD) || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
		0x17C6 == code || // Mn       KHMER SIGN NIKAHIT
		(0x17C9 <= code && code <= 0x17D3) || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
		0x17DD == code || // Mn       KHMER SIGN ATTHACAN
		(0x180B <= code && code <= 0x180D) || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
		(0x1885 <= code && code <= 0x1886) || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
		0x18A9 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
		(0x1920 <= code && code <= 0x1922) || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
		(0x1927 <= code && code <= 0x1928) || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
		0x1932 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
		(0x1939 <= code && code <= 0x193B) || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
		(0x1A17 <= code && code <= 0x1A18) || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
		0x1A1B == code || // Mn       BUGINESE VOWEL SIGN AE
		0x1A56 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
		(0x1A58 <= code && code <= 0x1A5E) || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
		0x1A60 == code || // Mn       TAI THAM SIGN SAKOT
		0x1A62 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
		(0x1A65 <= code && code <= 0x1A6C) || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
		(0x1A73 <= code && code <= 0x1A7C) || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
		0x1A7F == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
		(0x1AB0 <= code && code <= 0x1ABD) || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
		0x1ABE == code || // Me       COMBINING PARENTHESES OVERLAY
		(0x1B00 <= code && code <= 0x1B03) || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
		0x1B34 == code || // Mn       BALINESE SIGN REREKAN
		(0x1B36 <= code && code <= 0x1B3A) || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
		0x1B3C == code || // Mn       BALINESE VOWEL SIGN LA LENGA
		0x1B42 == code || // Mn       BALINESE VOWEL SIGN PEPET
		(0x1B6B <= code && code <= 0x1B73) || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
		(0x1B80 <= code && code <= 0x1B81) || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
		(0x1BA2 <= code && code <= 0x1BA5) || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
		(0x1BA8 <= code && code <= 0x1BA9) || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
		(0x1BAB <= code && code <= 0x1BAD) || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
		0x1BE6 == code || // Mn       BATAK SIGN TOMPI
		(0x1BE8 <= code && code <= 0x1BE9) || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
		0x1BED == code || // Mn       BATAK VOWEL SIGN KARO O
		(0x1BEF <= code && code <= 0x1BF1) || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
		(0x1C2C <= code && code <= 0x1C33) || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
		(0x1C36 <= code && code <= 0x1C37) || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
		(0x1CD0 <= code && code <= 0x1CD2) || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
		(0x1CD4 <= code && code <= 0x1CE0) || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
		(0x1CE2 <= code && code <= 0x1CE8) || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
		0x1CED == code || // Mn       VEDIC SIGN TIRYAK
		0x1CF4 == code || // Mn       VEDIC TONE CANDRA ABOVE
		(0x1CF8 <= code && code <= 0x1CF9) || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
		(0x1DC0 <= code && code <= 0x1DF9) || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
		(0x1DFB <= code && code <= 0x1DFF) || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
		0x200C == code || // Cf       ZERO WIDTH NON-JOINER
		(0x20D0 <= code && code <= 0x20DC) || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
		(0x20DD <= code && code <= 0x20E0) || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
		0x20E1 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
		(0x20E2 <= code && code <= 0x20E4) || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
		(0x20E5 <= code && code <= 0x20F0) || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
		(0x2CEF <= code && code <= 0x2CF1) || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
		0x2D7F == code || // Mn       TIFINAGH CONSONANT JOINER
		(0x2DE0 <= code && code <= 0x2DFF) || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
		(0x302A <= code && code <= 0x302D) || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
		(0x302E <= code && code <= 0x302F) || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
		(0x3099 <= code && code <= 0x309A) || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
		0xA66F == code || // Mn       COMBINING CYRILLIC VZMET
		(0xA670 <= code && code <= 0xA672) || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
		(0xA674 <= code && code <= 0xA67D) || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
		(0xA69E <= code && code <= 0xA69F) || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
		(0xA6F0 <= code && code <= 0xA6F1) || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
		0xA802 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
		0xA806 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
		0xA80B == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
		(0xA825 <= code && code <= 0xA826) || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
		(0xA8C4 <= code && code <= 0xA8C5) || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
		(0xA8E0 <= code && code <= 0xA8F1) || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
		(0xA926 <= code && code <= 0xA92D) || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
		(0xA947 <= code && code <= 0xA951) || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
		(0xA980 <= code && code <= 0xA982) || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
		0xA9B3 == code || // Mn       JAVANESE SIGN CECAK TELU
		(0xA9B6 <= code && code <= 0xA9B9) || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
		0xA9BC == code || // Mn       JAVANESE VOWEL SIGN PEPET
		0xA9E5 == code || // Mn       MYANMAR SIGN SHAN SAW
		(0xAA29 <= code && code <= 0xAA2E) || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
		(0xAA31 <= code && code <= 0xAA32) || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
		(0xAA35 <= code && code <= 0xAA36) || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
		0xAA43 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
		0xAA4C == code || // Mn       CHAM CONSONANT SIGN FINAL M
		0xAA7C == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
		0xAAB0 == code || // Mn       TAI VIET MAI KANG
		(0xAAB2 <= code && code <= 0xAAB4) || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
		(0xAAB7 <= code && code <= 0xAAB8) || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
		(0xAABE <= code && code <= 0xAABF) || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
		0xAAC1 == code || // Mn       TAI VIET TONE MAI THO
		(0xAAEC <= code && code <= 0xAAED) || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
		0xAAF6 == code || // Mn       MEETEI MAYEK VIRAMA
		0xABE5 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
		0xABE8 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
		0xABED == code || // Mn       MEETEI MAYEK APUN IYEK
		0xFB1E == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
		(0xFE00 <= code && code <= 0xFE0F) || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
		(0xFE20 <= code && code <= 0xFE2F) || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
		(0xFF9E <= code && code <= 0xFF9F) || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
		0x101FD == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
		0x102E0 == code || // Mn       COPTIC EPACT THOUSANDS MARK
		(0x10376 <= code && code <= 0x1037A) || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
		(0x10A01 <= code && code <= 0x10A03) || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
		(0x10A05 <= code && code <= 0x10A06) || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
		(0x10A0C <= code && code <= 0x10A0F) || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
		(0x10A38 <= code && code <= 0x10A3A) || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
		0x10A3F == code || // Mn       KHAROSHTHI VIRAMA
		(0x10AE5 <= code && code <= 0x10AE6) || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
		0x11001 == code || // Mn       BRAHMI SIGN ANUSVARA
		(0x11038 <= code && code <= 0x11046) || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
		(0x1107F <= code && code <= 0x11081) || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
		(0x110B3 <= code && code <= 0x110B6) || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
		(0x110B9 <= code && code <= 0x110BA) || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
		(0x11100 <= code && code <= 0x11102) || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
		(0x11127 <= code && code <= 0x1112B) || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
		(0x1112D <= code && code <= 0x11134) || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
		0x11173 == code || // Mn       MAHAJANI SIGN NUKTA
		(0x11180 <= code && code <= 0x11181) || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
		(0x111B6 <= code && code <= 0x111BE) || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
		(0x111CA <= code && code <= 0x111CC) || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
		(0x1122F <= code && code <= 0x11231) || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
		0x11234 == code || // Mn       KHOJKI SIGN ANUSVARA
		(0x11236 <= code && code <= 0x11237) || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
		0x1123E == code || // Mn       KHOJKI SIGN SUKUN
		0x112DF == code || // Mn       KHUDAWADI SIGN ANUSVARA
		(0x112E3 <= code && code <= 0x112EA) || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
		(0x11300 <= code && code <= 0x11301) || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
		0x1133C == code || // Mn       GRANTHA SIGN NUKTA
		0x1133E == code || // Mc       GRANTHA VOWEL SIGN AA
		0x11340 == code || // Mn       GRANTHA VOWEL SIGN II
		0x11357 == code || // Mc       GRANTHA AU LENGTH MARK
		(0x11366 <= code && code <= 0x1136C) || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
		(0x11370 <= code && code <= 0x11374) || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
		(0x11438 <= code && code <= 0x1143F) || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
		(0x11442 <= code && code <= 0x11444) || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
		0x11446 == code || // Mn       NEWA SIGN NUKTA
		0x114B0 == code || // Mc       TIRHUTA VOWEL SIGN AA
		(0x114B3 <= code && code <= 0x114B8) || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
		0x114BA == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
		0x114BD == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
		(0x114BF <= code && code <= 0x114C0) || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
		(0x114C2 <= code && code <= 0x114C3) || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
		0x115AF == code || // Mc       SIDDHAM VOWEL SIGN AA
		(0x115B2 <= code && code <= 0x115B5) || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
		(0x115BC <= code && code <= 0x115BD) || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
		(0x115BF <= code && code <= 0x115C0) || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
		(0x115DC <= code && code <= 0x115DD) || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
		(0x11633 <= code && code <= 0x1163A) || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
		0x1163D == code || // Mn       MODI SIGN ANUSVARA
		(0x1163F <= code && code <= 0x11640) || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
		0x116AB == code || // Mn       TAKRI SIGN ANUSVARA
		0x116AD == code || // Mn       TAKRI VOWEL SIGN AA
		(0x116B0 <= code && code <= 0x116B5) || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
		0x116B7 == code || // Mn       TAKRI SIGN NUKTA
		(0x1171D <= code && code <= 0x1171F) || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
		(0x11722 <= code && code <= 0x11725) || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
		(0x11727 <= code && code <= 0x1172B) || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
		(0x11A01 <= code && code <= 0x11A06) || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
		(0x11A09 <= code && code <= 0x11A0A) || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
		(0x11A33 <= code && code <= 0x11A38) || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
		(0x11A3B <= code && code <= 0x11A3E) || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
		0x11A47 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
		(0x11A51 <= code && code <= 0x11A56) || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
		(0x11A59 <= code && code <= 0x11A5B) || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
		(0x11A8A <= code && code <= 0x11A96) || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
		(0x11A98 <= code && code <= 0x11A99) || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
		(0x11C30 <= code && code <= 0x11C36) || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
		(0x11C38 <= code && code <= 0x11C3D) || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
		0x11C3F == code || // Mn       BHAIKSUKI SIGN VIRAMA
		(0x11C92 <= code && code <= 0x11CA7) || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
		(0x11CAA <= code && code <= 0x11CB0) || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
		(0x11CB2 <= code && code <= 0x11CB3) || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
		(0x11CB5 <= code && code <= 0x11CB6) || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
		(0x11D31 <= code && code <= 0x11D36) || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
		0x11D3A == code || // Mn       MASARAM GONDI VOWEL SIGN E
		(0x11D3C <= code && code <= 0x11D3D) || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
		(0x11D3F <= code && code <= 0x11D45) || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
		0x11D47 == code || // Mn       MASARAM GONDI RA-KARA
		(0x16AF0 <= code && code <= 0x16AF4) || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
		(0x16B30 <= code && code <= 0x16B36) || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
		(0x16F8F <= code && code <= 0x16F92) || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
		(0x1BC9D <= code && code <= 0x1BC9E) || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
		0x1D165 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
		(0x1D167 <= code && code <= 0x1D169) || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
		(0x1D16E <= code && code <= 0x1D172) || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
		(0x1D17B <= code && code <= 0x1D182) || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
		(0x1D185 <= code && code <= 0x1D18B) || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
		(0x1D1AA <= code && code <= 0x1D1AD) || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
		(0x1D242 <= code && code <= 0x1D244) || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
		(0x1DA00 <= code && code <= 0x1DA36) || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
		(0x1DA3B <= code && code <= 0x1DA6C) || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
		0x1DA75 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
		0x1DA84 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
		(0x1DA9B <= code && code <= 0x1DA9F) || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
		(0x1DAA1 <= code && code <= 0x1DAAF) || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
		(0x1E000 <= code && code <= 0x1E006) || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
		(0x1E008 <= code && code <= 0x1E018) || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
		(0x1E01B <= code && code <= 0x1E021) || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
		(0x1E023 <= code && code <= 0x1E024) || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
		(0x1E026 <= code && code <= 0x1E02A) || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
		(0x1E8D0 <= code && code <= 0x1E8D6) || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
		(0x1E944 <= code && code <= 0x1E94A) || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
		(0xE0020 <= code && code <= 0xE007F) || // Cf  [96] TAG SPACE..CANCEL TAG
		(0xE0100 <= code && code <= 0xE01EF) // Mn [240] VARIATION SELECTOR-17..VARIATION SELECTOR-256
		){
			return Extend;
		}
		
		
		if(
		(0x1F1E6 <= code && code <= 0x1F1FF) // So  [26] REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z
		){
			return Regional_Indicator;
		}
		
		if(
		0x0903 == code || // Mc       DEVANAGARI SIGN VISARGA
		0x093B == code || // Mc       DEVANAGARI VOWEL SIGN OOE
		(0x093E <= code && code <= 0x0940) || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
		(0x0949 <= code && code <= 0x094C) || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
		(0x094E <= code && code <= 0x094F) || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
		(0x0982 <= code && code <= 0x0983) || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
		(0x09BF <= code && code <= 0x09C0) || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
		(0x09C7 <= code && code <= 0x09C8) || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
		(0x09CB <= code && code <= 0x09CC) || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
		0x0A03 == code || // Mc       GURMUKHI SIGN VISARGA
		(0x0A3E <= code && code <= 0x0A40) || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
		0x0A83 == code || // Mc       GUJARATI SIGN VISARGA
		(0x0ABE <= code && code <= 0x0AC0) || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
		0x0AC9 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
		(0x0ACB <= code && code <= 0x0ACC) || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
		(0x0B02 <= code && code <= 0x0B03) || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
		0x0B40 == code || // Mc       ORIYA VOWEL SIGN II
		(0x0B47 <= code && code <= 0x0B48) || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
		(0x0B4B <= code && code <= 0x0B4C) || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
		0x0BBF == code || // Mc       TAMIL VOWEL SIGN I
		(0x0BC1 <= code && code <= 0x0BC2) || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
		(0x0BC6 <= code && code <= 0x0BC8) || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
		(0x0BCA <= code && code <= 0x0BCC) || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
		(0x0C01 <= code && code <= 0x0C03) || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
		(0x0C41 <= code && code <= 0x0C44) || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
		(0x0C82 <= code && code <= 0x0C83) || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
		0x0CBE == code || // Mc       KANNADA VOWEL SIGN AA
		(0x0CC0 <= code && code <= 0x0CC1) || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
		(0x0CC3 <= code && code <= 0x0CC4) || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
		(0x0CC7 <= code && code <= 0x0CC8) || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
		(0x0CCA <= code && code <= 0x0CCB) || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
		(0x0D02 <= code && code <= 0x0D03) || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
		(0x0D3F <= code && code <= 0x0D40) || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
		(0x0D46 <= code && code <= 0x0D48) || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
		(0x0D4A <= code && code <= 0x0D4C) || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
		(0x0D82 <= code && code <= 0x0D83) || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
		(0x0DD0 <= code && code <= 0x0DD1) || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
		(0x0DD8 <= code && code <= 0x0DDE) || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
		(0x0DF2 <= code && code <= 0x0DF3) || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
		0x0E33 == code || // Lo       THAI CHARACTER SARA AM
		0x0EB3 == code || // Lo       LAO VOWEL SIGN AM
		(0x0F3E <= code && code <= 0x0F3F) || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
		0x0F7F == code || // Mc       TIBETAN SIGN RNAM BCAD
		0x1031 == code || // Mc       MYANMAR VOWEL SIGN E
		(0x103B <= code && code <= 0x103C) || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
		(0x1056 <= code && code <= 0x1057) || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
		0x1084 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
		0x17B6 == code || // Mc       KHMER VOWEL SIGN AA
		(0x17BE <= code && code <= 0x17C5) || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
		(0x17C7 <= code && code <= 0x17C8) || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
		(0x1923 <= code && code <= 0x1926) || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
		(0x1929 <= code && code <= 0x192B) || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
		(0x1930 <= code && code <= 0x1931) || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
		(0x1933 <= code && code <= 0x1938) || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
		(0x1A19 <= code && code <= 0x1A1A) || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
		0x1A55 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
		0x1A57 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
		(0x1A6D <= code && code <= 0x1A72) || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
		0x1B04 == code || // Mc       BALINESE SIGN BISAH
		0x1B35 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
		0x1B3B == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
		(0x1B3D <= code && code <= 0x1B41) || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
		(0x1B43 <= code && code <= 0x1B44) || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
		0x1B82 == code || // Mc       SUNDANESE SIGN PANGWISAD
		0x1BA1 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
		(0x1BA6 <= code && code <= 0x1BA7) || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
		0x1BAA == code || // Mc       SUNDANESE SIGN PAMAAEH
		0x1BE7 == code || // Mc       BATAK VOWEL SIGN E
		(0x1BEA <= code && code <= 0x1BEC) || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
		0x1BEE == code || // Mc       BATAK VOWEL SIGN U
		(0x1BF2 <= code && code <= 0x1BF3) || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
		(0x1C24 <= code && code <= 0x1C2B) || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
		(0x1C34 <= code && code <= 0x1C35) || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
		0x1CE1 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
		(0x1CF2 <= code && code <= 0x1CF3) || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
		0x1CF7 == code || // Mc       VEDIC SIGN ATIKRAMA
		(0xA823 <= code && code <= 0xA824) || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
		0xA827 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
		(0xA880 <= code && code <= 0xA881) || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
		(0xA8B4 <= code && code <= 0xA8C3) || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
		(0xA952 <= code && code <= 0xA953) || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
		0xA983 == code || // Mc       JAVANESE SIGN WIGNYAN
		(0xA9B4 <= code && code <= 0xA9B5) || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
		(0xA9BA <= code && code <= 0xA9BB) || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
		(0xA9BD <= code && code <= 0xA9C0) || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
		(0xAA2F <= code && code <= 0xAA30) || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
		(0xAA33 <= code && code <= 0xAA34) || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
		0xAA4D == code || // Mc       CHAM CONSONANT SIGN FINAL H
		0xAAEB == code || // Mc       MEETEI MAYEK VOWEL SIGN II
		(0xAAEE <= code && code <= 0xAAEF) || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
		0xAAF5 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
		(0xABE3 <= code && code <= 0xABE4) || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
		(0xABE6 <= code && code <= 0xABE7) || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
		(0xABE9 <= code && code <= 0xABEA) || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
		0xABEC == code || // Mc       MEETEI MAYEK LUM IYEK
		0x11000 == code || // Mc       BRAHMI SIGN CANDRABINDU
		0x11002 == code || // Mc       BRAHMI SIGN VISARGA
		0x11082 == code || // Mc       KAITHI SIGN VISARGA
		(0x110B0 <= code && code <= 0x110B2) || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
		(0x110B7 <= code && code <= 0x110B8) || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
		0x1112C == code || // Mc       CHAKMA VOWEL SIGN E
		0x11182 == code || // Mc       SHARADA SIGN VISARGA
		(0x111B3 <= code && code <= 0x111B5) || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
		(0x111BF <= code && code <= 0x111C0) || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
		(0x1122C <= code && code <= 0x1122E) || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
		(0x11232 <= code && code <= 0x11233) || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
		0x11235 == code || // Mc       KHOJKI SIGN VIRAMA
		(0x112E0 <= code && code <= 0x112E2) || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
		(0x11302 <= code && code <= 0x11303) || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
		0x1133F == code || // Mc       GRANTHA VOWEL SIGN I
		(0x11341 <= code && code <= 0x11344) || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
		(0x11347 <= code && code <= 0x11348) || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
		(0x1134B <= code && code <= 0x1134D) || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
		(0x11362 <= code && code <= 0x11363) || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
		(0x11435 <= code && code <= 0x11437) || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
		(0x11440 <= code && code <= 0x11441) || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
		0x11445 == code || // Mc       NEWA SIGN VISARGA
		(0x114B1 <= code && code <= 0x114B2) || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
		0x114B9 == code || // Mc       TIRHUTA VOWEL SIGN E
		(0x114BB <= code && code <= 0x114BC) || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
		0x114BE == code || // Mc       TIRHUTA VOWEL SIGN AU
		0x114C1 == code || // Mc       TIRHUTA SIGN VISARGA
		(0x115B0 <= code && code <= 0x115B1) || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
		(0x115B8 <= code && code <= 0x115BB) || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
		0x115BE == code || // Mc       SIDDHAM SIGN VISARGA
		(0x11630 <= code && code <= 0x11632) || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
		(0x1163B <= code && code <= 0x1163C) || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
		0x1163E == code || // Mc       MODI SIGN VISARGA
		0x116AC == code || // Mc       TAKRI SIGN VISARGA
		(0x116AE <= code && code <= 0x116AF) || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
		0x116B6 == code || // Mc       TAKRI SIGN VIRAMA
		(0x11720 <= code && code <= 0x11721) || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
		0x11726 == code || // Mc       AHOM VOWEL SIGN E
		(0x11A07 <= code && code <= 0x11A08) || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
		0x11A39 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
		(0x11A57 <= code && code <= 0x11A58) || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
		0x11A97 == code || // Mc       SOYOMBO SIGN VISARGA
		0x11C2F == code || // Mc       BHAIKSUKI VOWEL SIGN AA
		0x11C3E == code || // Mc       BHAIKSUKI SIGN VISARGA
		0x11CA9 == code || // Mc       MARCHEN SUBJOINED LETTER YA
		0x11CB1 == code || // Mc       MARCHEN VOWEL SIGN I
		0x11CB4 == code || // Mc       MARCHEN VOWEL SIGN O
		(0x16F51 <= code && code <= 0x16F7E) || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
		0x1D166 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
		0x1D16D == code // Mc       MUSICAL SYMBOL COMBINING AUGMENTATION DOT
		){
			return SpacingMark;
		}
		
		
		if(
		(0x1100 <= code && code <= 0x115F) || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
		(0xA960 <= code && code <= 0xA97C) // Lo  [29] HANGUL CHOSEONG TIKEUT-MIEUM..HANGUL CHOSEONG SSANGYEORINHIEUH
		){
			return L;
		}
		
		if(
		(0x1160 <= code && code <= 0x11A7) || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
		(0xD7B0 <= code && code <= 0xD7C6) // Lo  [23] HANGUL JUNGSEONG O-YEO..HANGUL JUNGSEONG ARAEA-E
		){
			return V;
		}
		
		
		if(
		(0x11A8 <= code && code <= 0x11FF) || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
		(0xD7CB <= code && code <= 0xD7FB) // Lo  [49] HANGUL JONGSEONG NIEUN-RIEUL..HANGUL JONGSEONG PHIEUPH-THIEUTH
		){
			return T;
		}
		
		if(
		0xAC00 == code || // Lo       HANGUL SYLLABLE GA
		0xAC1C == code || // Lo       HANGUL SYLLABLE GAE
		0xAC38 == code || // Lo       HANGUL SYLLABLE GYA
		0xAC54 == code || // Lo       HANGUL SYLLABLE GYAE
		0xAC70 == code || // Lo       HANGUL SYLLABLE GEO
		0xAC8C == code || // Lo       HANGUL SYLLABLE GE
		0xACA8 == code || // Lo       HANGUL SYLLABLE GYEO
		0xACC4 == code || // Lo       HANGUL SYLLABLE GYE
		0xACE0 == code || // Lo       HANGUL SYLLABLE GO
		0xACFC == code || // Lo       HANGUL SYLLABLE GWA
		0xAD18 == code || // Lo       HANGUL SYLLABLE GWAE
		0xAD34 == code || // Lo       HANGUL SYLLABLE GOE
		0xAD50 == code || // Lo       HANGUL SYLLABLE GYO
		0xAD6C == code || // Lo       HANGUL SYLLABLE GU
		0xAD88 == code || // Lo       HANGUL SYLLABLE GWEO
		0xADA4 == code || // Lo       HANGUL SYLLABLE GWE
		0xADC0 == code || // Lo       HANGUL SYLLABLE GWI
		0xADDC == code || // Lo       HANGUL SYLLABLE GYU
		0xADF8 == code || // Lo       HANGUL SYLLABLE GEU
		0xAE14 == code || // Lo       HANGUL SYLLABLE GYI
		0xAE30 == code || // Lo       HANGUL SYLLABLE GI
		0xAE4C == code || // Lo       HANGUL SYLLABLE GGA
		0xAE68 == code || // Lo       HANGUL SYLLABLE GGAE
		0xAE84 == code || // Lo       HANGUL SYLLABLE GGYA
		0xAEA0 == code || // Lo       HANGUL SYLLABLE GGYAE
		0xAEBC == code || // Lo       HANGUL SYLLABLE GGEO
		0xAED8 == code || // Lo       HANGUL SYLLABLE GGE
		0xAEF4 == code || // Lo       HANGUL SYLLABLE GGYEO
		0xAF10 == code || // Lo       HANGUL SYLLABLE GGYE
		0xAF2C == code || // Lo       HANGUL SYLLABLE GGO
		0xAF48 == code || // Lo       HANGUL SYLLABLE GGWA
		0xAF64 == code || // Lo       HANGUL SYLLABLE GGWAE
		0xAF80 == code || // Lo       HANGUL SYLLABLE GGOE
		0xAF9C == code || // Lo       HANGUL SYLLABLE GGYO
		0xAFB8 == code || // Lo       HANGUL SYLLABLE GGU
		0xAFD4 == code || // Lo       HANGUL SYLLABLE GGWEO
		0xAFF0 == code || // Lo       HANGUL SYLLABLE GGWE
		0xB00C == code || // Lo       HANGUL SYLLABLE GGWI
		0xB028 == code || // Lo       HANGUL SYLLABLE GGYU
		0xB044 == code || // Lo       HANGUL SYLLABLE GGEU
		0xB060 == code || // Lo       HANGUL SYLLABLE GGYI
		0xB07C == code || // Lo       HANGUL SYLLABLE GGI
		0xB098 == code || // Lo       HANGUL SYLLABLE NA
		0xB0B4 == code || // Lo       HANGUL SYLLABLE NAE
		0xB0D0 == code || // Lo       HANGUL SYLLABLE NYA
		0xB0EC == code || // Lo       HANGUL SYLLABLE NYAE
		0xB108 == code || // Lo       HANGUL SYLLABLE NEO
		0xB124 == code || // Lo       HANGUL SYLLABLE NE
		0xB140 == code || // Lo       HANGUL SYLLABLE NYEO
		0xB15C == code || // Lo       HANGUL SYLLABLE NYE
		0xB178 == code || // Lo       HANGUL SYLLABLE NO
		0xB194 == code || // Lo       HANGUL SYLLABLE NWA
		0xB1B0 == code || // Lo       HANGUL SYLLABLE NWAE
		0xB1CC == code || // Lo       HANGUL SYLLABLE NOE
		0xB1E8 == code || // Lo       HANGUL SYLLABLE NYO
		0xB204 == code || // Lo       HANGUL SYLLABLE NU
		0xB220 == code || // Lo       HANGUL SYLLABLE NWEO
		0xB23C == code || // Lo       HANGUL SYLLABLE NWE
		0xB258 == code || // Lo       HANGUL SYLLABLE NWI
		0xB274 == code || // Lo       HANGUL SYLLABLE NYU
		0xB290 == code || // Lo       HANGUL SYLLABLE NEU
		0xB2AC == code || // Lo       HANGUL SYLLABLE NYI
		0xB2C8 == code || // Lo       HANGUL SYLLABLE NI
		0xB2E4 == code || // Lo       HANGUL SYLLABLE DA
		0xB300 == code || // Lo       HANGUL SYLLABLE DAE
		0xB31C == code || // Lo       HANGUL SYLLABLE DYA
		0xB338 == code || // Lo       HANGUL SYLLABLE DYAE
		0xB354 == code || // Lo       HANGUL SYLLABLE DEO
		0xB370 == code || // Lo       HANGUL SYLLABLE DE
		0xB38C == code || // Lo       HANGUL SYLLABLE DYEO
		0xB3A8 == code || // Lo       HANGUL SYLLABLE DYE
		0xB3C4 == code || // Lo       HANGUL SYLLABLE DO
		0xB3E0 == code || // Lo       HANGUL SYLLABLE DWA
		0xB3FC == code || // Lo       HANGUL SYLLABLE DWAE
		0xB418 == code || // Lo       HANGUL SYLLABLE DOE
		0xB434 == code || // Lo       HANGUL SYLLABLE DYO
		0xB450 == code || // Lo       HANGUL SYLLABLE DU
		0xB46C == code || // Lo       HANGUL SYLLABLE DWEO
		0xB488 == code || // Lo       HANGUL SYLLABLE DWE
		0xB4A4 == code || // Lo       HANGUL SYLLABLE DWI
		0xB4C0 == code || // Lo       HANGUL SYLLABLE DYU
		0xB4DC == code || // Lo       HANGUL SYLLABLE DEU
		0xB4F8 == code || // Lo       HANGUL SYLLABLE DYI
		0xB514 == code || // Lo       HANGUL SYLLABLE DI
		0xB530 == code || // Lo       HANGUL SYLLABLE DDA
		0xB54C == code || // Lo       HANGUL SYLLABLE DDAE
		0xB568 == code || // Lo       HANGUL SYLLABLE DDYA
		0xB584 == code || // Lo       HANGUL SYLLABLE DDYAE
		0xB5A0 == code || // Lo       HANGUL SYLLABLE DDEO
		0xB5BC == code || // Lo       HANGUL SYLLABLE DDE
		0xB5D8 == code || // Lo       HANGUL SYLLABLE DDYEO
		0xB5F4 == code || // Lo       HANGUL SYLLABLE DDYE
		0xB610 == code || // Lo       HANGUL SYLLABLE DDO
		0xB62C == code || // Lo       HANGUL SYLLABLE DDWA
		0xB648 == code || // Lo       HANGUL SYLLABLE DDWAE
		0xB664 == code || // Lo       HANGUL SYLLABLE DDOE
		0xB680 == code || // Lo       HANGUL SYLLABLE DDYO
		0xB69C == code || // Lo       HANGUL SYLLABLE DDU
		0xB6B8 == code || // Lo       HANGUL SYLLABLE DDWEO
		0xB6D4 == code || // Lo       HANGUL SYLLABLE DDWE
		0xB6F0 == code || // Lo       HANGUL SYLLABLE DDWI
		0xB70C == code || // Lo       HANGUL SYLLABLE DDYU
		0xB728 == code || // Lo       HANGUL SYLLABLE DDEU
		0xB744 == code || // Lo       HANGUL SYLLABLE DDYI
		0xB760 == code || // Lo       HANGUL SYLLABLE DDI
		0xB77C == code || // Lo       HANGUL SYLLABLE RA
		0xB798 == code || // Lo       HANGUL SYLLABLE RAE
		0xB7B4 == code || // Lo       HANGUL SYLLABLE RYA
		0xB7D0 == code || // Lo       HANGUL SYLLABLE RYAE
		0xB7EC == code || // Lo       HANGUL SYLLABLE REO
		0xB808 == code || // Lo       HANGUL SYLLABLE RE
		0xB824 == code || // Lo       HANGUL SYLLABLE RYEO
		0xB840 == code || // Lo       HANGUL SYLLABLE RYE
		0xB85C == code || // Lo       HANGUL SYLLABLE RO
		0xB878 == code || // Lo       HANGUL SYLLABLE RWA
		0xB894 == code || // Lo       HANGUL SYLLABLE RWAE
		0xB8B0 == code || // Lo       HANGUL SYLLABLE ROE
		0xB8CC == code || // Lo       HANGUL SYLLABLE RYO
		0xB8E8 == code || // Lo       HANGUL SYLLABLE RU
		0xB904 == code || // Lo       HANGUL SYLLABLE RWEO
		0xB920 == code || // Lo       HANGUL SYLLABLE RWE
		0xB93C == code || // Lo       HANGUL SYLLABLE RWI
		0xB958 == code || // Lo       HANGUL SYLLABLE RYU
		0xB974 == code || // Lo       HANGUL SYLLABLE REU
		0xB990 == code || // Lo       HANGUL SYLLABLE RYI
		0xB9AC == code || // Lo       HANGUL SYLLABLE RI
		0xB9C8 == code || // Lo       HANGUL SYLLABLE MA
		0xB9E4 == code || // Lo       HANGUL SYLLABLE MAE
		0xBA00 == code || // Lo       HANGUL SYLLABLE MYA
		0xBA1C == code || // Lo       HANGUL SYLLABLE MYAE
		0xBA38 == code || // Lo       HANGUL SYLLABLE MEO
		0xBA54 == code || // Lo       HANGUL SYLLABLE ME
		0xBA70 == code || // Lo       HANGUL SYLLABLE MYEO
		0xBA8C == code || // Lo       HANGUL SYLLABLE MYE
		0xBAA8 == code || // Lo       HANGUL SYLLABLE MO
		0xBAC4 == code || // Lo       HANGUL SYLLABLE MWA
		0xBAE0 == code || // Lo       HANGUL SYLLABLE MWAE
		0xBAFC == code || // Lo       HANGUL SYLLABLE MOE
		0xBB18 == code || // Lo       HANGUL SYLLABLE MYO
		0xBB34 == code || // Lo       HANGUL SYLLABLE MU
		0xBB50 == code || // Lo       HANGUL SYLLABLE MWEO
		0xBB6C == code || // Lo       HANGUL SYLLABLE MWE
		0xBB88 == code || // Lo       HANGUL SYLLABLE MWI
		0xBBA4 == code || // Lo       HANGUL SYLLABLE MYU
		0xBBC0 == code || // Lo       HANGUL SYLLABLE MEU
		0xBBDC == code || // Lo       HANGUL SYLLABLE MYI
		0xBBF8 == code || // Lo       HANGUL SYLLABLE MI
		0xBC14 == code || // Lo       HANGUL SYLLABLE BA
		0xBC30 == code || // Lo       HANGUL SYLLABLE BAE
		0xBC4C == code || // Lo       HANGUL SYLLABLE BYA
		0xBC68 == code || // Lo       HANGUL SYLLABLE BYAE
		0xBC84 == code || // Lo       HANGUL SYLLABLE BEO
		0xBCA0 == code || // Lo       HANGUL SYLLABLE BE
		0xBCBC == code || // Lo       HANGUL SYLLABLE BYEO
		0xBCD8 == code || // Lo       HANGUL SYLLABLE BYE
		0xBCF4 == code || // Lo       HANGUL SYLLABLE BO
		0xBD10 == code || // Lo       HANGUL SYLLABLE BWA
		0xBD2C == code || // Lo       HANGUL SYLLABLE BWAE
		0xBD48 == code || // Lo       HANGUL SYLLABLE BOE
		0xBD64 == code || // Lo       HANGUL SYLLABLE BYO
		0xBD80 == code || // Lo       HANGUL SYLLABLE BU
		0xBD9C == code || // Lo       HANGUL SYLLABLE BWEO
		0xBDB8 == code || // Lo       HANGUL SYLLABLE BWE
		0xBDD4 == code || // Lo       HANGUL SYLLABLE BWI
		0xBDF0 == code || // Lo       HANGUL SYLLABLE BYU
		0xBE0C == code || // Lo       HANGUL SYLLABLE BEU
		0xBE28 == code || // Lo       HANGUL SYLLABLE BYI
		0xBE44 == code || // Lo       HANGUL SYLLABLE BI
		0xBE60 == code || // Lo       HANGUL SYLLABLE BBA
		0xBE7C == code || // Lo       HANGUL SYLLABLE BBAE
		0xBE98 == code || // Lo       HANGUL SYLLABLE BBYA
		0xBEB4 == code || // Lo       HANGUL SYLLABLE BBYAE
		0xBED0 == code || // Lo       HANGUL SYLLABLE BBEO
		0xBEEC == code || // Lo       HANGUL SYLLABLE BBE
		0xBF08 == code || // Lo       HANGUL SYLLABLE BBYEO
		0xBF24 == code || // Lo       HANGUL SYLLABLE BBYE
		0xBF40 == code || // Lo       HANGUL SYLLABLE BBO
		0xBF5C == code || // Lo       HANGUL SYLLABLE BBWA
		0xBF78 == code || // Lo       HANGUL SYLLABLE BBWAE
		0xBF94 == code || // Lo       HANGUL SYLLABLE BBOE
		0xBFB0 == code || // Lo       HANGUL SYLLABLE BBYO
		0xBFCC == code || // Lo       HANGUL SYLLABLE BBU
		0xBFE8 == code || // Lo       HANGUL SYLLABLE BBWEO
		0xC004 == code || // Lo       HANGUL SYLLABLE BBWE
		0xC020 == code || // Lo       HANGUL SYLLABLE BBWI
		0xC03C == code || // Lo       HANGUL SYLLABLE BBYU
		0xC058 == code || // Lo       HANGUL SYLLABLE BBEU
		0xC074 == code || // Lo       HANGUL SYLLABLE BBYI
		0xC090 == code || // Lo       HANGUL SYLLABLE BBI
		0xC0AC == code || // Lo       HANGUL SYLLABLE SA
		0xC0C8 == code || // Lo       HANGUL SYLLABLE SAE
		0xC0E4 == code || // Lo       HANGUL SYLLABLE SYA
		0xC100 == code || // Lo       HANGUL SYLLABLE SYAE
		0xC11C == code || // Lo       HANGUL SYLLABLE SEO
		0xC138 == code || // Lo       HANGUL SYLLABLE SE
		0xC154 == code || // Lo       HANGUL SYLLABLE SYEO
		0xC170 == code || // Lo       HANGUL SYLLABLE SYE
		0xC18C == code || // Lo       HANGUL SYLLABLE SO
		0xC1A8 == code || // Lo       HANGUL SYLLABLE SWA
		0xC1C4 == code || // Lo       HANGUL SYLLABLE SWAE
		0xC1E0 == code || // Lo       HANGUL SYLLABLE SOE
		0xC1FC == code || // Lo       HANGUL SYLLABLE SYO
		0xC218 == code || // Lo       HANGUL SYLLABLE SU
		0xC234 == code || // Lo       HANGUL SYLLABLE SWEO
		0xC250 == code || // Lo       HANGUL SYLLABLE SWE
		0xC26C == code || // Lo       HANGUL SYLLABLE SWI
		0xC288 == code || // Lo       HANGUL SYLLABLE SYU
		0xC2A4 == code || // Lo       HANGUL SYLLABLE SEU
		0xC2C0 == code || // Lo       HANGUL SYLLABLE SYI
		0xC2DC == code || // Lo       HANGUL SYLLABLE SI
		0xC2F8 == code || // Lo       HANGUL SYLLABLE SSA
		0xC314 == code || // Lo       HANGUL SYLLABLE SSAE
		0xC330 == code || // Lo       HANGUL SYLLABLE SSYA
		0xC34C == code || // Lo       HANGUL SYLLABLE SSYAE
		0xC368 == code || // Lo       HANGUL SYLLABLE SSEO
		0xC384 == code || // Lo       HANGUL SYLLABLE SSE
		0xC3A0 == code || // Lo       HANGUL SYLLABLE SSYEO
		0xC3BC == code || // Lo       HANGUL SYLLABLE SSYE
		0xC3D8 == code || // Lo       HANGUL SYLLABLE SSO
		0xC3F4 == code || // Lo       HANGUL SYLLABLE SSWA
		0xC410 == code || // Lo       HANGUL SYLLABLE SSWAE
		0xC42C == code || // Lo       HANGUL SYLLABLE SSOE
		0xC448 == code || // Lo       HANGUL SYLLABLE SSYO
		0xC464 == code || // Lo       HANGUL SYLLABLE SSU
		0xC480 == code || // Lo       HANGUL SYLLABLE SSWEO
		0xC49C == code || // Lo       HANGUL SYLLABLE SSWE
		0xC4B8 == code || // Lo       HANGUL SYLLABLE SSWI
		0xC4D4 == code || // Lo       HANGUL SYLLABLE SSYU
		0xC4F0 == code || // Lo       HANGUL SYLLABLE SSEU
		0xC50C == code || // Lo       HANGUL SYLLABLE SSYI
		0xC528 == code || // Lo       HANGUL SYLLABLE SSI
		0xC544 == code || // Lo       HANGUL SYLLABLE A
		0xC560 == code || // Lo       HANGUL SYLLABLE AE
		0xC57C == code || // Lo       HANGUL SYLLABLE YA
		0xC598 == code || // Lo       HANGUL SYLLABLE YAE
		0xC5B4 == code || // Lo       HANGUL SYLLABLE EO
		0xC5D0 == code || // Lo       HANGUL SYLLABLE E
		0xC5EC == code || // Lo       HANGUL SYLLABLE YEO
		0xC608 == code || // Lo       HANGUL SYLLABLE YE
		0xC624 == code || // Lo       HANGUL SYLLABLE O
		0xC640 == code || // Lo       HANGUL SYLLABLE WA
		0xC65C == code || // Lo       HANGUL SYLLABLE WAE
		0xC678 == code || // Lo       HANGUL SYLLABLE OE
		0xC694 == code || // Lo       HANGUL SYLLABLE YO
		0xC6B0 == code || // Lo       HANGUL SYLLABLE U
		0xC6CC == code || // Lo       HANGUL SYLLABLE WEO
		0xC6E8 == code || // Lo       HANGUL SYLLABLE WE
		0xC704 == code || // Lo       HANGUL SYLLABLE WI
		0xC720 == code || // Lo       HANGUL SYLLABLE YU
		0xC73C == code || // Lo       HANGUL SYLLABLE EU
		0xC758 == code || // Lo       HANGUL SYLLABLE YI
		0xC774 == code || // Lo       HANGUL SYLLABLE I
		0xC790 == code || // Lo       HANGUL SYLLABLE JA
		0xC7AC == code || // Lo       HANGUL SYLLABLE JAE
		0xC7C8 == code || // Lo       HANGUL SYLLABLE JYA
		0xC7E4 == code || // Lo       HANGUL SYLLABLE JYAE
		0xC800 == code || // Lo       HANGUL SYLLABLE JEO
		0xC81C == code || // Lo       HANGUL SYLLABLE JE
		0xC838 == code || // Lo       HANGUL SYLLABLE JYEO
		0xC854 == code || // Lo       HANGUL SYLLABLE JYE
		0xC870 == code || // Lo       HANGUL SYLLABLE JO
		0xC88C == code || // Lo       HANGUL SYLLABLE JWA
		0xC8A8 == code || // Lo       HANGUL SYLLABLE JWAE
		0xC8C4 == code || // Lo       HANGUL SYLLABLE JOE
		0xC8E0 == code || // Lo       HANGUL SYLLABLE JYO
		0xC8FC == code || // Lo       HANGUL SYLLABLE JU
		0xC918 == code || // Lo       HANGUL SYLLABLE JWEO
		0xC934 == code || // Lo       HANGUL SYLLABLE JWE
		0xC950 == code || // Lo       HANGUL SYLLABLE JWI
		0xC96C == code || // Lo       HANGUL SYLLABLE JYU
		0xC988 == code || // Lo       HANGUL SYLLABLE JEU
		0xC9A4 == code || // Lo       HANGUL SYLLABLE JYI
		0xC9C0 == code || // Lo       HANGUL SYLLABLE JI
		0xC9DC == code || // Lo       HANGUL SYLLABLE JJA
		0xC9F8 == code || // Lo       HANGUL SYLLABLE JJAE
		0xCA14 == code || // Lo       HANGUL SYLLABLE JJYA
		0xCA30 == code || // Lo       HANGUL SYLLABLE JJYAE
		0xCA4C == code || // Lo       HANGUL SYLLABLE JJEO
		0xCA68 == code || // Lo       HANGUL SYLLABLE JJE
		0xCA84 == code || // Lo       HANGUL SYLLABLE JJYEO
		0xCAA0 == code || // Lo       HANGUL SYLLABLE JJYE
		0xCABC == code || // Lo       HANGUL SYLLABLE JJO
		0xCAD8 == code || // Lo       HANGUL SYLLABLE JJWA
		0xCAF4 == code || // Lo       HANGUL SYLLABLE JJWAE
		0xCB10 == code || // Lo       HANGUL SYLLABLE JJOE
		0xCB2C == code || // Lo       HANGUL SYLLABLE JJYO
		0xCB48 == code || // Lo       HANGUL SYLLABLE JJU
		0xCB64 == code || // Lo       HANGUL SYLLABLE JJWEO
		0xCB80 == code || // Lo       HANGUL SYLLABLE JJWE
		0xCB9C == code || // Lo       HANGUL SYLLABLE JJWI
		0xCBB8 == code || // Lo       HANGUL SYLLABLE JJYU
		0xCBD4 == code || // Lo       HANGUL SYLLABLE JJEU
		0xCBF0 == code || // Lo       HANGUL SYLLABLE JJYI
		0xCC0C == code || // Lo       HANGUL SYLLABLE JJI
		0xCC28 == code || // Lo       HANGUL SYLLABLE CA
		0xCC44 == code || // Lo       HANGUL SYLLABLE CAE
		0xCC60 == code || // Lo       HANGUL SYLLABLE CYA
		0xCC7C == code || // Lo       HANGUL SYLLABLE CYAE
		0xCC98 == code || // Lo       HANGUL SYLLABLE CEO
		0xCCB4 == code || // Lo       HANGUL SYLLABLE CE
		0xCCD0 == code || // Lo       HANGUL SYLLABLE CYEO
		0xCCEC == code || // Lo       HANGUL SYLLABLE CYE
		0xCD08 == code || // Lo       HANGUL SYLLABLE CO
		0xCD24 == code || // Lo       HANGUL SYLLABLE CWA
		0xCD40 == code || // Lo       HANGUL SYLLABLE CWAE
		0xCD5C == code || // Lo       HANGUL SYLLABLE COE
		0xCD78 == code || // Lo       HANGUL SYLLABLE CYO
		0xCD94 == code || // Lo       HANGUL SYLLABLE CU
		0xCDB0 == code || // Lo       HANGUL SYLLABLE CWEO
		0xCDCC == code || // Lo       HANGUL SYLLABLE CWE
		0xCDE8 == code || // Lo       HANGUL SYLLABLE CWI
		0xCE04 == code || // Lo       HANGUL SYLLABLE CYU
		0xCE20 == code || // Lo       HANGUL SYLLABLE CEU
		0xCE3C == code || // Lo       HANGUL SYLLABLE CYI
		0xCE58 == code || // Lo       HANGUL SYLLABLE CI
		0xCE74 == code || // Lo       HANGUL SYLLABLE KA
		0xCE90 == code || // Lo       HANGUL SYLLABLE KAE
		0xCEAC == code || // Lo       HANGUL SYLLABLE KYA
		0xCEC8 == code || // Lo       HANGUL SYLLABLE KYAE
		0xCEE4 == code || // Lo       HANGUL SYLLABLE KEO
		0xCF00 == code || // Lo       HANGUL SYLLABLE KE
		0xCF1C == code || // Lo       HANGUL SYLLABLE KYEO
		0xCF38 == code || // Lo       HANGUL SYLLABLE KYE
		0xCF54 == code || // Lo       HANGUL SYLLABLE KO
		0xCF70 == code || // Lo       HANGUL SYLLABLE KWA
		0xCF8C == code || // Lo       HANGUL SYLLABLE KWAE
		0xCFA8 == code || // Lo       HANGUL SYLLABLE KOE
		0xCFC4 == code || // Lo       HANGUL SYLLABLE KYO
		0xCFE0 == code || // Lo       HANGUL SYLLABLE KU
		0xCFFC == code || // Lo       HANGUL SYLLABLE KWEO
		0xD018 == code || // Lo       HANGUL SYLLABLE KWE
		0xD034 == code || // Lo       HANGUL SYLLABLE KWI
		0xD050 == code || // Lo       HANGUL SYLLABLE KYU
		0xD06C == code || // Lo       HANGUL SYLLABLE KEU
		0xD088 == code || // Lo       HANGUL SYLLABLE KYI
		0xD0A4 == code || // Lo       HANGUL SYLLABLE KI
		0xD0C0 == code || // Lo       HANGUL SYLLABLE TA
		0xD0DC == code || // Lo       HANGUL SYLLABLE TAE
		0xD0F8 == code || // Lo       HANGUL SYLLABLE TYA
		0xD114 == code || // Lo       HANGUL SYLLABLE TYAE
		0xD130 == code || // Lo       HANGUL SYLLABLE TEO
		0xD14C == code || // Lo       HANGUL SYLLABLE TE
		0xD168 == code || // Lo       HANGUL SYLLABLE TYEO
		0xD184 == code || // Lo       HANGUL SYLLABLE TYE
		0xD1A0 == code || // Lo       HANGUL SYLLABLE TO
		0xD1BC == code || // Lo       HANGUL SYLLABLE TWA
		0xD1D8 == code || // Lo       HANGUL SYLLABLE TWAE
		0xD1F4 == code || // Lo       HANGUL SYLLABLE TOE
		0xD210 == code || // Lo       HANGUL SYLLABLE TYO
		0xD22C == code || // Lo       HANGUL SYLLABLE TU
		0xD248 == code || // Lo       HANGUL SYLLABLE TWEO
		0xD264 == code || // Lo       HANGUL SYLLABLE TWE
		0xD280 == code || // Lo       HANGUL SYLLABLE TWI
		0xD29C == code || // Lo       HANGUL SYLLABLE TYU
		0xD2B8 == code || // Lo       HANGUL SYLLABLE TEU
		0xD2D4 == code || // Lo       HANGUL SYLLABLE TYI
		0xD2F0 == code || // Lo       HANGUL SYLLABLE TI
		0xD30C == code || // Lo       HANGUL SYLLABLE PA
		0xD328 == code || // Lo       HANGUL SYLLABLE PAE
		0xD344 == code || // Lo       HANGUL SYLLABLE PYA
		0xD360 == code || // Lo       HANGUL SYLLABLE PYAE
		0xD37C == code || // Lo       HANGUL SYLLABLE PEO
		0xD398 == code || // Lo       HANGUL SYLLABLE PE
		0xD3B4 == code || // Lo       HANGUL SYLLABLE PYEO
		0xD3D0 == code || // Lo       HANGUL SYLLABLE PYE
		0xD3EC == code || // Lo       HANGUL SYLLABLE PO
		0xD408 == code || // Lo       HANGUL SYLLABLE PWA
		0xD424 == code || // Lo       HANGUL SYLLABLE PWAE
		0xD440 == code || // Lo       HANGUL SYLLABLE POE
		0xD45C == code || // Lo       HANGUL SYLLABLE PYO
		0xD478 == code || // Lo       HANGUL SYLLABLE PU
		0xD494 == code || // Lo       HANGUL SYLLABLE PWEO
		0xD4B0 == code || // Lo       HANGUL SYLLABLE PWE
		0xD4CC == code || // Lo       HANGUL SYLLABLE PWI
		0xD4E8 == code || // Lo       HANGUL SYLLABLE PYU
		0xD504 == code || // Lo       HANGUL SYLLABLE PEU
		0xD520 == code || // Lo       HANGUL SYLLABLE PYI
		0xD53C == code || // Lo       HANGUL SYLLABLE PI
		0xD558 == code || // Lo       HANGUL SYLLABLE HA
		0xD574 == code || // Lo       HANGUL SYLLABLE HAE
		0xD590 == code || // Lo       HANGUL SYLLABLE HYA
		0xD5AC == code || // Lo       HANGUL SYLLABLE HYAE
		0xD5C8 == code || // Lo       HANGUL SYLLABLE HEO
		0xD5E4 == code || // Lo       HANGUL SYLLABLE HE
		0xD600 == code || // Lo       HANGUL SYLLABLE HYEO
		0xD61C == code || // Lo       HANGUL SYLLABLE HYE
		0xD638 == code || // Lo       HANGUL SYLLABLE HO
		0xD654 == code || // Lo       HANGUL SYLLABLE HWA
		0xD670 == code || // Lo       HANGUL SYLLABLE HWAE
		0xD68C == code || // Lo       HANGUL SYLLABLE HOE
		0xD6A8 == code || // Lo       HANGUL SYLLABLE HYO
		0xD6C4 == code || // Lo       HANGUL SYLLABLE HU
		0xD6E0 == code || // Lo       HANGUL SYLLABLE HWEO
		0xD6FC == code || // Lo       HANGUL SYLLABLE HWE
		0xD718 == code || // Lo       HANGUL SYLLABLE HWI
		0xD734 == code || // Lo       HANGUL SYLLABLE HYU
		0xD750 == code || // Lo       HANGUL SYLLABLE HEU
		0xD76C == code || // Lo       HANGUL SYLLABLE HYI
		0xD788 == code // Lo       HANGUL SYLLABLE HI
		){
			return LV;
		}
		
		if(
		(0xAC01 <= code && code <= 0xAC1B) || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
		(0xAC1D <= code && code <= 0xAC37) || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
		(0xAC39 <= code && code <= 0xAC53) || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
		(0xAC55 <= code && code <= 0xAC6F) || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
		(0xAC71 <= code && code <= 0xAC8B) || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
		(0xAC8D <= code && code <= 0xACA7) || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
		(0xACA9 <= code && code <= 0xACC3) || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
		(0xACC5 <= code && code <= 0xACDF) || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
		(0xACE1 <= code && code <= 0xACFB) || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
		(0xACFD <= code && code <= 0xAD17) || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
		(0xAD19 <= code && code <= 0xAD33) || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
		(0xAD35 <= code && code <= 0xAD4F) || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
		(0xAD51 <= code && code <= 0xAD6B) || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
		(0xAD6D <= code && code <= 0xAD87) || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
		(0xAD89 <= code && code <= 0xADA3) || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
		(0xADA5 <= code && code <= 0xADBF) || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
		(0xADC1 <= code && code <= 0xADDB) || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
		(0xADDD <= code && code <= 0xADF7) || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
		(0xADF9 <= code && code <= 0xAE13) || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
		(0xAE15 <= code && code <= 0xAE2F) || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
		(0xAE31 <= code && code <= 0xAE4B) || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
		(0xAE4D <= code && code <= 0xAE67) || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
		(0xAE69 <= code && code <= 0xAE83) || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
		(0xAE85 <= code && code <= 0xAE9F) || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
		(0xAEA1 <= code && code <= 0xAEBB) || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
		(0xAEBD <= code && code <= 0xAED7) || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
		(0xAED9 <= code && code <= 0xAEF3) || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
		(0xAEF5 <= code && code <= 0xAF0F) || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
		(0xAF11 <= code && code <= 0xAF2B) || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
		(0xAF2D <= code && code <= 0xAF47) || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
		(0xAF49 <= code && code <= 0xAF63) || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
		(0xAF65 <= code && code <= 0xAF7F) || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
		(0xAF81 <= code && code <= 0xAF9B) || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
		(0xAF9D <= code && code <= 0xAFB7) || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
		(0xAFB9 <= code && code <= 0xAFD3) || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
		(0xAFD5 <= code && code <= 0xAFEF) || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
		(0xAFF1 <= code && code <= 0xB00B) || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
		(0xB00D <= code && code <= 0xB027) || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
		(0xB029 <= code && code <= 0xB043) || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
		(0xB045 <= code && code <= 0xB05F) || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
		(0xB061 <= code && code <= 0xB07B) || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
		(0xB07D <= code && code <= 0xB097) || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
		(0xB099 <= code && code <= 0xB0B3) || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
		(0xB0B5 <= code && code <= 0xB0CF) || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
		(0xB0D1 <= code && code <= 0xB0EB) || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
		(0xB0ED <= code && code <= 0xB107) || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
		(0xB109 <= code && code <= 0xB123) || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
		(0xB125 <= code && code <= 0xB13F) || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
		(0xB141 <= code && code <= 0xB15B) || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
		(0xB15D <= code && code <= 0xB177) || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
		(0xB179 <= code && code <= 0xB193) || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
		(0xB195 <= code && code <= 0xB1AF) || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
		(0xB1B1 <= code && code <= 0xB1CB) || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
		(0xB1CD <= code && code <= 0xB1E7) || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
		(0xB1E9 <= code && code <= 0xB203) || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
		(0xB205 <= code && code <= 0xB21F) || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
		(0xB221 <= code && code <= 0xB23B) || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
		(0xB23D <= code && code <= 0xB257) || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
		(0xB259 <= code && code <= 0xB273) || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
		(0xB275 <= code && code <= 0xB28F) || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
		(0xB291 <= code && code <= 0xB2AB) || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
		(0xB2AD <= code && code <= 0xB2C7) || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
		(0xB2C9 <= code && code <= 0xB2E3) || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
		(0xB2E5 <= code && code <= 0xB2FF) || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
		(0xB301 <= code && code <= 0xB31B) || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
		(0xB31D <= code && code <= 0xB337) || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
		(0xB339 <= code && code <= 0xB353) || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
		(0xB355 <= code && code <= 0xB36F) || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
		(0xB371 <= code && code <= 0xB38B) || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
		(0xB38D <= code && code <= 0xB3A7) || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
		(0xB3A9 <= code && code <= 0xB3C3) || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
		(0xB3C5 <= code && code <= 0xB3DF) || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
		(0xB3E1 <= code && code <= 0xB3FB) || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
		(0xB3FD <= code && code <= 0xB417) || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
		(0xB419 <= code && code <= 0xB433) || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
		(0xB435 <= code && code <= 0xB44F) || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
		(0xB451 <= code && code <= 0xB46B) || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
		(0xB46D <= code && code <= 0xB487) || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
		(0xB489 <= code && code <= 0xB4A3) || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
		(0xB4A5 <= code && code <= 0xB4BF) || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
		(0xB4C1 <= code && code <= 0xB4DB) || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
		(0xB4DD <= code && code <= 0xB4F7) || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
		(0xB4F9 <= code && code <= 0xB513) || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
		(0xB515 <= code && code <= 0xB52F) || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
		(0xB531 <= code && code <= 0xB54B) || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
		(0xB54D <= code && code <= 0xB567) || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
		(0xB569 <= code && code <= 0xB583) || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
		(0xB585 <= code && code <= 0xB59F) || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
		(0xB5A1 <= code && code <= 0xB5BB) || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
		(0xB5BD <= code && code <= 0xB5D7) || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
		(0xB5D9 <= code && code <= 0xB5F3) || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
		(0xB5F5 <= code && code <= 0xB60F) || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
		(0xB611 <= code && code <= 0xB62B) || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
		(0xB62D <= code && code <= 0xB647) || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
		(0xB649 <= code && code <= 0xB663) || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
		(0xB665 <= code && code <= 0xB67F) || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
		(0xB681 <= code && code <= 0xB69B) || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
		(0xB69D <= code && code <= 0xB6B7) || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
		(0xB6B9 <= code && code <= 0xB6D3) || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
		(0xB6D5 <= code && code <= 0xB6EF) || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
		(0xB6F1 <= code && code <= 0xB70B) || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
		(0xB70D <= code && code <= 0xB727) || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
		(0xB729 <= code && code <= 0xB743) || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
		(0xB745 <= code && code <= 0xB75F) || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
		(0xB761 <= code && code <= 0xB77B) || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
		(0xB77D <= code && code <= 0xB797) || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
		(0xB799 <= code && code <= 0xB7B3) || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
		(0xB7B5 <= code && code <= 0xB7CF) || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
		(0xB7D1 <= code && code <= 0xB7EB) || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
		(0xB7ED <= code && code <= 0xB807) || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
		(0xB809 <= code && code <= 0xB823) || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
		(0xB825 <= code && code <= 0xB83F) || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
		(0xB841 <= code && code <= 0xB85B) || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
		(0xB85D <= code && code <= 0xB877) || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
		(0xB879 <= code && code <= 0xB893) || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
		(0xB895 <= code && code <= 0xB8AF) || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
		(0xB8B1 <= code && code <= 0xB8CB) || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
		(0xB8CD <= code && code <= 0xB8E7) || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
		(0xB8E9 <= code && code <= 0xB903) || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
		(0xB905 <= code && code <= 0xB91F) || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
		(0xB921 <= code && code <= 0xB93B) || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
		(0xB93D <= code && code <= 0xB957) || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
		(0xB959 <= code && code <= 0xB973) || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
		(0xB975 <= code && code <= 0xB98F) || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
		(0xB991 <= code && code <= 0xB9AB) || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
		(0xB9AD <= code && code <= 0xB9C7) || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
		(0xB9C9 <= code && code <= 0xB9E3) || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
		(0xB9E5 <= code && code <= 0xB9FF) || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
		(0xBA01 <= code && code <= 0xBA1B) || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
		(0xBA1D <= code && code <= 0xBA37) || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
		(0xBA39 <= code && code <= 0xBA53) || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
		(0xBA55 <= code && code <= 0xBA6F) || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
		(0xBA71 <= code && code <= 0xBA8B) || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
		(0xBA8D <= code && code <= 0xBAA7) || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
		(0xBAA9 <= code && code <= 0xBAC3) || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
		(0xBAC5 <= code && code <= 0xBADF) || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
		(0xBAE1 <= code && code <= 0xBAFB) || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
		(0xBAFD <= code && code <= 0xBB17) || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
		(0xBB19 <= code && code <= 0xBB33) || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
		(0xBB35 <= code && code <= 0xBB4F) || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
		(0xBB51 <= code && code <= 0xBB6B) || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
		(0xBB6D <= code && code <= 0xBB87) || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
		(0xBB89 <= code && code <= 0xBBA3) || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
		(0xBBA5 <= code && code <= 0xBBBF) || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
		(0xBBC1 <= code && code <= 0xBBDB) || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
		(0xBBDD <= code && code <= 0xBBF7) || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
		(0xBBF9 <= code && code <= 0xBC13) || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
		(0xBC15 <= code && code <= 0xBC2F) || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
		(0xBC31 <= code && code <= 0xBC4B) || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
		(0xBC4D <= code && code <= 0xBC67) || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
		(0xBC69 <= code && code <= 0xBC83) || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
		(0xBC85 <= code && code <= 0xBC9F) || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
		(0xBCA1 <= code && code <= 0xBCBB) || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
		(0xBCBD <= code && code <= 0xBCD7) || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
		(0xBCD9 <= code && code <= 0xBCF3) || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
		(0xBCF5 <= code && code <= 0xBD0F) || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
		(0xBD11 <= code && code <= 0xBD2B) || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
		(0xBD2D <= code && code <= 0xBD47) || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
		(0xBD49 <= code && code <= 0xBD63) || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
		(0xBD65 <= code && code <= 0xBD7F) || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
		(0xBD81 <= code && code <= 0xBD9B) || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
		(0xBD9D <= code && code <= 0xBDB7) || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
		(0xBDB9 <= code && code <= 0xBDD3) || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
		(0xBDD5 <= code && code <= 0xBDEF) || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
		(0xBDF1 <= code && code <= 0xBE0B) || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
		(0xBE0D <= code && code <= 0xBE27) || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
		(0xBE29 <= code && code <= 0xBE43) || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
		(0xBE45 <= code && code <= 0xBE5F) || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
		(0xBE61 <= code && code <= 0xBE7B) || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
		(0xBE7D <= code && code <= 0xBE97) || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
		(0xBE99 <= code && code <= 0xBEB3) || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
		(0xBEB5 <= code && code <= 0xBECF) || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
		(0xBED1 <= code && code <= 0xBEEB) || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
		(0xBEED <= code && code <= 0xBF07) || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
		(0xBF09 <= code && code <= 0xBF23) || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
		(0xBF25 <= code && code <= 0xBF3F) || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
		(0xBF41 <= code && code <= 0xBF5B) || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
		(0xBF5D <= code && code <= 0xBF77) || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
		(0xBF79 <= code && code <= 0xBF93) || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
		(0xBF95 <= code && code <= 0xBFAF) || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
		(0xBFB1 <= code && code <= 0xBFCB) || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
		(0xBFCD <= code && code <= 0xBFE7) || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
		(0xBFE9 <= code && code <= 0xC003) || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
		(0xC005 <= code && code <= 0xC01F) || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
		(0xC021 <= code && code <= 0xC03B) || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
		(0xC03D <= code && code <= 0xC057) || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
		(0xC059 <= code && code <= 0xC073) || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
		(0xC075 <= code && code <= 0xC08F) || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
		(0xC091 <= code && code <= 0xC0AB) || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
		(0xC0AD <= code && code <= 0xC0C7) || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
		(0xC0C9 <= code && code <= 0xC0E3) || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
		(0xC0E5 <= code && code <= 0xC0FF) || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
		(0xC101 <= code && code <= 0xC11B) || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
		(0xC11D <= code && code <= 0xC137) || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
		(0xC139 <= code && code <= 0xC153) || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
		(0xC155 <= code && code <= 0xC16F) || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
		(0xC171 <= code && code <= 0xC18B) || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
		(0xC18D <= code && code <= 0xC1A7) || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
		(0xC1A9 <= code && code <= 0xC1C3) || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
		(0xC1C5 <= code && code <= 0xC1DF) || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
		(0xC1E1 <= code && code <= 0xC1FB) || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
		(0xC1FD <= code && code <= 0xC217) || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
		(0xC219 <= code && code <= 0xC233) || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
		(0xC235 <= code && code <= 0xC24F) || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
		(0xC251 <= code && code <= 0xC26B) || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
		(0xC26D <= code && code <= 0xC287) || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
		(0xC289 <= code && code <= 0xC2A3) || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
		(0xC2A5 <= code && code <= 0xC2BF) || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
		(0xC2C1 <= code && code <= 0xC2DB) || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
		(0xC2DD <= code && code <= 0xC2F7) || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
		(0xC2F9 <= code && code <= 0xC313) || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
		(0xC315 <= code && code <= 0xC32F) || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
		(0xC331 <= code && code <= 0xC34B) || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
		(0xC34D <= code && code <= 0xC367) || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
		(0xC369 <= code && code <= 0xC383) || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
		(0xC385 <= code && code <= 0xC39F) || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
		(0xC3A1 <= code && code <= 0xC3BB) || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
		(0xC3BD <= code && code <= 0xC3D7) || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
		(0xC3D9 <= code && code <= 0xC3F3) || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
		(0xC3F5 <= code && code <= 0xC40F) || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
		(0xC411 <= code && code <= 0xC42B) || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
		(0xC42D <= code && code <= 0xC447) || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
		(0xC449 <= code && code <= 0xC463) || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
		(0xC465 <= code && code <= 0xC47F) || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
		(0xC481 <= code && code <= 0xC49B) || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
		(0xC49D <= code && code <= 0xC4B7) || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
		(0xC4B9 <= code && code <= 0xC4D3) || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
		(0xC4D5 <= code && code <= 0xC4EF) || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
		(0xC4F1 <= code && code <= 0xC50B) || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
		(0xC50D <= code && code <= 0xC527) || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
		(0xC529 <= code && code <= 0xC543) || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
		(0xC545 <= code && code <= 0xC55F) || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
		(0xC561 <= code && code <= 0xC57B) || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
		(0xC57D <= code && code <= 0xC597) || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
		(0xC599 <= code && code <= 0xC5B3) || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
		(0xC5B5 <= code && code <= 0xC5CF) || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
		(0xC5D1 <= code && code <= 0xC5EB) || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
		(0xC5ED <= code && code <= 0xC607) || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
		(0xC609 <= code && code <= 0xC623) || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
		(0xC625 <= code && code <= 0xC63F) || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
		(0xC641 <= code && code <= 0xC65B) || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
		(0xC65D <= code && code <= 0xC677) || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
		(0xC679 <= code && code <= 0xC693) || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
		(0xC695 <= code && code <= 0xC6AF) || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
		(0xC6B1 <= code && code <= 0xC6CB) || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
		(0xC6CD <= code && code <= 0xC6E7) || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
		(0xC6E9 <= code && code <= 0xC703) || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
		(0xC705 <= code && code <= 0xC71F) || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
		(0xC721 <= code && code <= 0xC73B) || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
		(0xC73D <= code && code <= 0xC757) || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
		(0xC759 <= code && code <= 0xC773) || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
		(0xC775 <= code && code <= 0xC78F) || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
		(0xC791 <= code && code <= 0xC7AB) || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
		(0xC7AD <= code && code <= 0xC7C7) || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
		(0xC7C9 <= code && code <= 0xC7E3) || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
		(0xC7E5 <= code && code <= 0xC7FF) || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
		(0xC801 <= code && code <= 0xC81B) || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
		(0xC81D <= code && code <= 0xC837) || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
		(0xC839 <= code && code <= 0xC853) || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
		(0xC855 <= code && code <= 0xC86F) || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
		(0xC871 <= code && code <= 0xC88B) || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
		(0xC88D <= code && code <= 0xC8A7) || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
		(0xC8A9 <= code && code <= 0xC8C3) || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
		(0xC8C5 <= code && code <= 0xC8DF) || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
		(0xC8E1 <= code && code <= 0xC8FB) || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
		(0xC8FD <= code && code <= 0xC917) || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
		(0xC919 <= code && code <= 0xC933) || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
		(0xC935 <= code && code <= 0xC94F) || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
		(0xC951 <= code && code <= 0xC96B) || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
		(0xC96D <= code && code <= 0xC987) || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
		(0xC989 <= code && code <= 0xC9A3) || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
		(0xC9A5 <= code && code <= 0xC9BF) || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
		(0xC9C1 <= code && code <= 0xC9DB) || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
		(0xC9DD <= code && code <= 0xC9F7) || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
		(0xC9F9 <= code && code <= 0xCA13) || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
		(0xCA15 <= code && code <= 0xCA2F) || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
		(0xCA31 <= code && code <= 0xCA4B) || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
		(0xCA4D <= code && code <= 0xCA67) || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
		(0xCA69 <= code && code <= 0xCA83) || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
		(0xCA85 <= code && code <= 0xCA9F) || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
		(0xCAA1 <= code && code <= 0xCABB) || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
		(0xCABD <= code && code <= 0xCAD7) || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
		(0xCAD9 <= code && code <= 0xCAF3) || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
		(0xCAF5 <= code && code <= 0xCB0F) || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
		(0xCB11 <= code && code <= 0xCB2B) || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
		(0xCB2D <= code && code <= 0xCB47) || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
		(0xCB49 <= code && code <= 0xCB63) || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
		(0xCB65 <= code && code <= 0xCB7F) || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
		(0xCB81 <= code && code <= 0xCB9B) || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
		(0xCB9D <= code && code <= 0xCBB7) || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
		(0xCBB9 <= code && code <= 0xCBD3) || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
		(0xCBD5 <= code && code <= 0xCBEF) || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
		(0xCBF1 <= code && code <= 0xCC0B) || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
		(0xCC0D <= code && code <= 0xCC27) || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
		(0xCC29 <= code && code <= 0xCC43) || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
		(0xCC45 <= code && code <= 0xCC5F) || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
		(0xCC61 <= code && code <= 0xCC7B) || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
		(0xCC7D <= code && code <= 0xCC97) || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
		(0xCC99 <= code && code <= 0xCCB3) || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
		(0xCCB5 <= code && code <= 0xCCCF) || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
		(0xCCD1 <= code && code <= 0xCCEB) || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
		(0xCCED <= code && code <= 0xCD07) || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
		(0xCD09 <= code && code <= 0xCD23) || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
		(0xCD25 <= code && code <= 0xCD3F) || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
		(0xCD41 <= code && code <= 0xCD5B) || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
		(0xCD5D <= code && code <= 0xCD77) || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
		(0xCD79 <= code && code <= 0xCD93) || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
		(0xCD95 <= code && code <= 0xCDAF) || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
		(0xCDB1 <= code && code <= 0xCDCB) || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
		(0xCDCD <= code && code <= 0xCDE7) || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
		(0xCDE9 <= code && code <= 0xCE03) || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
		(0xCE05 <= code && code <= 0xCE1F) || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
		(0xCE21 <= code && code <= 0xCE3B) || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
		(0xCE3D <= code && code <= 0xCE57) || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
		(0xCE59 <= code && code <= 0xCE73) || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
		(0xCE75 <= code && code <= 0xCE8F) || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
		(0xCE91 <= code && code <= 0xCEAB) || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
		(0xCEAD <= code && code <= 0xCEC7) || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
		(0xCEC9 <= code && code <= 0xCEE3) || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
		(0xCEE5 <= code && code <= 0xCEFF) || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
		(0xCF01 <= code && code <= 0xCF1B) || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
		(0xCF1D <= code && code <= 0xCF37) || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
		(0xCF39 <= code && code <= 0xCF53) || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
		(0xCF55 <= code && code <= 0xCF6F) || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
		(0xCF71 <= code && code <= 0xCF8B) || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
		(0xCF8D <= code && code <= 0xCFA7) || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
		(0xCFA9 <= code && code <= 0xCFC3) || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
		(0xCFC5 <= code && code <= 0xCFDF) || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
		(0xCFE1 <= code && code <= 0xCFFB) || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
		(0xCFFD <= code && code <= 0xD017) || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
		(0xD019 <= code && code <= 0xD033) || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
		(0xD035 <= code && code <= 0xD04F) || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
		(0xD051 <= code && code <= 0xD06B) || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
		(0xD06D <= code && code <= 0xD087) || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
		(0xD089 <= code && code <= 0xD0A3) || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
		(0xD0A5 <= code && code <= 0xD0BF) || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
		(0xD0C1 <= code && code <= 0xD0DB) || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
		(0xD0DD <= code && code <= 0xD0F7) || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
		(0xD0F9 <= code && code <= 0xD113) || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
		(0xD115 <= code && code <= 0xD12F) || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
		(0xD131 <= code && code <= 0xD14B) || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
		(0xD14D <= code && code <= 0xD167) || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
		(0xD169 <= code && code <= 0xD183) || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
		(0xD185 <= code && code <= 0xD19F) || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
		(0xD1A1 <= code && code <= 0xD1BB) || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
		(0xD1BD <= code && code <= 0xD1D7) || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
		(0xD1D9 <= code && code <= 0xD1F3) || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
		(0xD1F5 <= code && code <= 0xD20F) || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
		(0xD211 <= code && code <= 0xD22B) || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
		(0xD22D <= code && code <= 0xD247) || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
		(0xD249 <= code && code <= 0xD263) || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
		(0xD265 <= code && code <= 0xD27F) || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
		(0xD281 <= code && code <= 0xD29B) || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
		(0xD29D <= code && code <= 0xD2B7) || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
		(0xD2B9 <= code && code <= 0xD2D3) || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
		(0xD2D5 <= code && code <= 0xD2EF) || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
		(0xD2F1 <= code && code <= 0xD30B) || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
		(0xD30D <= code && code <= 0xD327) || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
		(0xD329 <= code && code <= 0xD343) || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
		(0xD345 <= code && code <= 0xD35F) || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
		(0xD361 <= code && code <= 0xD37B) || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
		(0xD37D <= code && code <= 0xD397) || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
		(0xD399 <= code && code <= 0xD3B3) || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
		(0xD3B5 <= code && code <= 0xD3CF) || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
		(0xD3D1 <= code && code <= 0xD3EB) || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
		(0xD3ED <= code && code <= 0xD407) || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
		(0xD409 <= code && code <= 0xD423) || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
		(0xD425 <= code && code <= 0xD43F) || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
		(0xD441 <= code && code <= 0xD45B) || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
		(0xD45D <= code && code <= 0xD477) || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
		(0xD479 <= code && code <= 0xD493) || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
		(0xD495 <= code && code <= 0xD4AF) || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
		(0xD4B1 <= code && code <= 0xD4CB) || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
		(0xD4CD <= code && code <= 0xD4E7) || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
		(0xD4E9 <= code && code <= 0xD503) || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
		(0xD505 <= code && code <= 0xD51F) || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
		(0xD521 <= code && code <= 0xD53B) || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
		(0xD53D <= code && code <= 0xD557) || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
		(0xD559 <= code && code <= 0xD573) || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
		(0xD575 <= code && code <= 0xD58F) || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
		(0xD591 <= code && code <= 0xD5AB) || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
		(0xD5AD <= code && code <= 0xD5C7) || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
		(0xD5C9 <= code && code <= 0xD5E3) || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
		(0xD5E5 <= code && code <= 0xD5FF) || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
		(0xD601 <= code && code <= 0xD61B) || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
		(0xD61D <= code && code <= 0xD637) || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
		(0xD639 <= code && code <= 0xD653) || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
		(0xD655 <= code && code <= 0xD66F) || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
		(0xD671 <= code && code <= 0xD68B) || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
		(0xD68D <= code && code <= 0xD6A7) || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
		(0xD6A9 <= code && code <= 0xD6C3) || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
		(0xD6C5 <= code && code <= 0xD6DF) || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
		(0xD6E1 <= code && code <= 0xD6FB) || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
		(0xD6FD <= code && code <= 0xD717) || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
		(0xD719 <= code && code <= 0xD733) || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
		(0xD735 <= code && code <= 0xD74F) || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
		(0xD751 <= code && code <= 0xD76B) || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
		(0xD76D <= code && code <= 0xD787) || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
		(0xD789 <= code && code <= 0xD7A3) // Lo  [27] HANGUL SYLLABLE HIG..HANGUL SYLLABLE HIH
		){
			return LVT;
		}
		
		if(
		0x261D == code || // So       WHITE UP POINTING INDEX
		0x26F9 == code || // So       PERSON WITH BALL
		(0x270A <= code && code <= 0x270D) || // So   [4] RAISED FIST..WRITING HAND
		0x1F385 == code || // So       FATHER CHRISTMAS
		(0x1F3C2 <= code && code <= 0x1F3C4) || // So   [3] SNOWBOARDER..SURFER
		0x1F3C7 == code || // So       HORSE RACING
		(0x1F3CA <= code && code <= 0x1F3CC) || // So   [3] SWIMMER..GOLFER
		(0x1F442 <= code && code <= 0x1F443) || // So   [2] EAR..NOSE
		(0x1F446 <= code && code <= 0x1F450) || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
		0x1F46E == code || // So       POLICE OFFICER
		(0x1F470 <= code && code <= 0x1F478) || // So   [9] BRIDE WITH VEIL..PRINCESS
		0x1F47C == code || // So       BABY ANGEL
		(0x1F481 <= code && code <= 0x1F483) || // So   [3] INFORMATION DESK PERSON..DANCER
		(0x1F485 <= code && code <= 0x1F487) || // So   [3] NAIL POLISH..HAIRCUT
		0x1F4AA == code || // So       FLEXED BICEPS
		(0x1F574 <= code && code <= 0x1F575) || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
		0x1F57A == code || // So       MAN DANCING
		0x1F590 == code || // So       RAISED HAND WITH FINGERS SPLAYED
		(0x1F595 <= code && code <= 0x1F596) || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
		(0x1F645 <= code && code <= 0x1F647) || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
		(0x1F64B <= code && code <= 0x1F64F) || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
		0x1F6A3 == code || // So       ROWBOAT
		(0x1F6B4 <= code && code <= 0x1F6B6) || // So   [3] BICYCLIST..PEDESTRIAN
		0x1F6C0 == code || // So       BATH
		0x1F6CC == code || // So       SLEEPING ACCOMMODATION
		(0x1F918 <= code && code <= 0x1F91C) || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
		(0x1F91E <= code && code <= 0x1F91F) || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
		0x1F926 == code || // So       FACE PALM
		(0x1F930 <= code && code <= 0x1F939) || // So  [10] PREGNANT WOMAN..JUGGLING
		(0x1F93D <= code && code <= 0x1F93E) || // So   [2] WATER POLO..HANDBALL
		(0x1F9D1 <= code && code <= 0x1F9DD) // So  [13] ADULT..ELF
		){
			return E_Base;
		}

		if(
		(0x1F3FB <= code && code <= 0x1F3FF) // Sk   [5] EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6
		){
			return E_Modifier;
		}

		if(
		0x200D == code // Cf       ZERO WIDTH JOINER
		){
			return ZWJ;
		}

		if(
		0x2640 == code || // So       FEMALE SIGN
		0x2642 == code || // So       MALE SIGN
		(0x2695 <= code && code <= 0x2696) || // So   [2] STAFF OF AESCULAPIUS..SCALES
		0x2708 == code || // So       AIRPLANE
		0x2764 == code || // So       HEAVY BLACK HEART
		0x1F308 == code || // So       RAINBOW
		0x1F33E == code || // So       EAR OF RICE
		0x1F373 == code || // So       COOKING
		0x1F393 == code || // So       GRADUATION CAP
		0x1F3A4 == code || // So       MICROPHONE
		0x1F3A8 == code || // So       ARTIST PALETTE
		0x1F3EB == code || // So       SCHOOL
		0x1F3ED == code || // So       FACTORY
		0x1F48B == code || // So       KISS MARK
		(0x1F4BB <= code && code <= 0x1F4BC) || // So   [2] PERSONAL COMPUTER..BRIEFCASE
		0x1F527 == code || // So       WRENCH
		0x1F52C == code || // So       MICROSCOPE
		0x1F5E8 == code || // So       LEFT SPEECH BUBBLE
		0x1F680 == code || // So       ROCKET
		0x1F692 == code // So       FIRE ENGINE
		){
			return Glue_After_Zwj;
		}

		if(
		(0x1F466 <= code && code <= 0x1F469) // So   [4] BOY..WOMAN
		){
			return E_Base_GAZ;
		}
		
		
		//all unlisted characters have a grapheme break property of "Other"
		return Other;
	}
	return this;
}

if ( true && module.exports) {
    module.exports = GraphemeSplitter;
}


/***/ }),

/***/ "../packages/powerquery-language-services/lib/index.js":
/*!*************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./language-services */ "../packages/powerquery-language-services/lib/language-services/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/analysis.js":
/*!**********************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/analysis.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Common = __webpack_require__(/*! ./common */ "../packages/powerquery-language-services/lib/language-services/common.js");
const currentDocumentSymbolProvider_1 = __webpack_require__(/*! ./currentDocumentSymbolProvider */ "../packages/powerquery-language-services/lib/language-services/currentDocumentSymbolProvider.js");
const InspectionHelpers = __webpack_require__(/*! ./inspectionHelpers */ "../packages/powerquery-language-services/lib/language-services/inspectionHelpers.js");
const keywordProvider_1 = __webpack_require__(/*! ./keywordProvider */ "../packages/powerquery-language-services/lib/language-services/keywordProvider.js");
const providers_1 = __webpack_require__(/*! ./providers */ "../packages/powerquery-language-services/lib/language-services/providers.js");
const WorkspaceCache = __webpack_require__(/*! ./workspaceCache */ "../packages/powerquery-language-services/lib/language-services/workspaceCache.js");
function createAnalysisSession(document, position, options) {
    return new DocumentAnalysis(document, position, options);
}
exports.createAnalysisSession = createAnalysisSession;
class DocumentAnalysis {
    constructor(document, position, options) {
        this.document = document;
        this.position = position;
        this.environmentSymbolProvider = options.environmentSymbolProvider
            ? options.environmentSymbolProvider
            : new providers_1.NullLibrarySymbolProvider();
        this.keywordProvider = new keywordProvider_1.KeywordProvider();
        this.librarySymbolProvider = options.librarySymbolProvider
            ? options.librarySymbolProvider
            : new providers_1.NullLibrarySymbolProvider();
        this.localSymbolProvider = new currentDocumentSymbolProvider_1.CurrentDocumentSymbolProvider(document, position);
    }
    getCompletionItems() {
        return __awaiter(this, void 0, void 0, function* () {
            let context = {};
            const maybeToken = maybeTokenAt(this.document, this.position);
            if (maybeToken !== undefined) {
                context = {
                    range: getTokenRangeForPosition(maybeToken, this.position),
                    text: maybeToken.data,
                    tokenKind: maybeToken.kind,
                };
            }
            // TODO: intellisense improvements
            // - honor expected data type
            // - get inspection for current scope
            // - only include current query name after @
            // - don't return completion items when on lefthand side of assignment
            // TODO: add tracing/logging to the catch()
            const getLibraryCompletionItems = this.librarySymbolProvider
                .getCompletionItems(context)
                .catch(() => {
                return Common.EmptyCompletionItems;
            });
            const getKeywords = this.keywordProvider.getCompletionItems(context).catch(() => {
                return Common.EmptyCompletionItems;
            });
            const getEnvironmentCompletionItems = this.environmentSymbolProvider
                .getCompletionItems(context)
                .catch(() => {
                return Common.EmptyCompletionItems;
            });
            const getLocalCompletionItems = this.localSymbolProvider
                .getCompletionItems(context)
                .catch(() => {
                return Common.EmptyCompletionItems;
            });
            const [libraryResponse, keywordResponse, environmentResponse, localResponse] = yield Promise.all([
                getLibraryCompletionItems,
                getKeywords,
                getEnvironmentCompletionItems,
                getLocalCompletionItems,
            ]);
            let completionItems = Array.isArray(keywordResponse) ? keywordResponse : [keywordResponse];
            completionItems = completionItems.concat(libraryResponse, environmentResponse, localResponse);
            return completionItems;
        });
    }
    getHover() {
        return __awaiter(this, void 0, void 0, function* () {
            const identifierToken = maybeIdentifierAt(this.document, this.position);
            if (identifierToken) {
                const context = {
                    range: getTokenRangeForPosition(identifierToken, this.position),
                    identifier: identifierToken.data,
                };
                // TODO: add tracing/logging to the catch()
                const getLibraryHover = this.librarySymbolProvider.getHover(context).catch(() => {
                    // tslint:disable-next-line: no-null-keyword
                    return null;
                });
                // TODO: use other providers
                // TODO: define priority when multiple providers return results
                const [libraryResponse] = yield Promise.all([getLibraryHover]);
                if (libraryResponse) {
                    return libraryResponse;
                }
            }
            return Common.EmptyHover;
        });
    }
    getSignatureHelp() {
        return __awaiter(this, void 0, void 0, function* () {
            const triedInspection = WorkspaceCache.getTriedInspection(this.document, this.position);
            if (triedInspection && triedInspection.kind === "Ok" /* Ok */) {
                const inspected = triedInspection.value;
                const maybeContext = InspectionHelpers.getContextForInspected(inspected);
                if (maybeContext !== undefined) {
                    const context = maybeContext;
                    if (context.maybeFunctionName) {
                        // TODO: add tracing/logging to the catch()
                        const librarySignatureHelp = this.librarySymbolProvider
                            .getSignatureHelp(context)
                            .catch(() => {
                            // tslint:disable-next-line: no-null-keyword
                            return null;
                        });
                        const [libraryResponse] = yield Promise.all([librarySignatureHelp]);
                        if (libraryResponse) {
                            return libraryResponse;
                        }
                    }
                }
            }
            return Common.EmptySignatureHelp;
        });
    }
}
function getTokenRangeForPosition(token, cursorPosition) {
    return {
        start: {
            line: cursorPosition.line,
            character: token.positionStart,
        },
        end: {
            line: cursorPosition.line,
            character: token.positionEnd,
        },
    };
}
function maybeIdentifierAt(document, position) {
    const maybeToken = maybeTokenAt(document, position);
    if (maybeToken) {
        const token = maybeToken;
        if (token.kind === "Identifier" /* Identifier */) {
            return token;
        }
    }
    return undefined;
}
function maybeLineTokensAt(document, position) {
    const lexResult = WorkspaceCache.getLexerState(document);
    const maybeLine = lexResult.lines[position.line];
    return maybeLine !== undefined ? maybeLine.tokens : undefined;
}
function maybeTokenAt(document, position) {
    const maybeLineTokens = maybeLineTokensAt(document, position);
    if (maybeLineTokens === undefined) {
        return undefined;
    }
    const lineTokens = maybeLineTokens;
    for (const token of lineTokens) {
        if (token.positionStart <= position.character && token.positionEnd >= position.character) {
            return token;
        }
    }
    // Token wasn't found - check for special case where current position is a trailing "." on an identifier
    const currentRange = {
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: position,
    };
    if (document.getText(currentRange) === ".") {
        for (const token of lineTokens) {
            if (token.positionStart <= position.character - 1 && token.positionEnd >= position.character - 1) {
                if (token.kind === "Identifier" /* Identifier */) {
                    // Use this token with an adjusted position
                    return {
                        data: `${token.data}.`,
                        kind: token.kind,
                        positionStart: token.positionStart,
                        positionEnd: token.positionEnd + 1,
                    };
                }
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=analysis.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/common.js":
/*!********************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/common.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js");
exports.EmptyCompletionItems = [];
exports.EmptyHover = {
    range: undefined,
    contents: [],
};
exports.EmptySignatureHelp = {
    signatures: [],
    // tslint:disable-next-line: no-null-keyword
    activeParameter: null,
    activeSignature: 0,
};
function documentSymbolToCompletionItem(documentSymbols) {
    const result = [];
    documentSymbols.forEach(sym => {
        result.push({
            deprecated: sym.deprecated,
            detail: sym.detail,
            label: sym.name,
            kind: symbolKindToCompletionItemKind(sym.kind),
        });
    });
    return result;
}
exports.documentSymbolToCompletionItem = documentSymbolToCompletionItem;
function symbolKindToCompletionItemKind(symbolKind) {
    switch (symbolKind) {
        case vscode_languageserver_types_1.SymbolKind.Module:
            return vscode_languageserver_types_1.CompletionItemKind.Module;
        case vscode_languageserver_types_1.SymbolKind.Field:
            return vscode_languageserver_types_1.CompletionItemKind.Field;
        case vscode_languageserver_types_1.SymbolKind.Constructor:
            return vscode_languageserver_types_1.CompletionItemKind.Constructor;
        case vscode_languageserver_types_1.SymbolKind.Enum:
            return vscode_languageserver_types_1.CompletionItemKind.Enum;
        case vscode_languageserver_types_1.SymbolKind.EnumMember:
            return vscode_languageserver_types_1.CompletionItemKind.EnumMember;
        case vscode_languageserver_types_1.SymbolKind.Function:
            return vscode_languageserver_types_1.CompletionItemKind.Function;
        case vscode_languageserver_types_1.SymbolKind.Variable:
            return vscode_languageserver_types_1.CompletionItemKind.Variable;
        case vscode_languageserver_types_1.SymbolKind.Constant:
            return vscode_languageserver_types_1.CompletionItemKind.Constant;
        case vscode_languageserver_types_1.SymbolKind.Array:
        case vscode_languageserver_types_1.SymbolKind.Boolean:
        case vscode_languageserver_types_1.SymbolKind.Number:
        case vscode_languageserver_types_1.SymbolKind.Null:
        case vscode_languageserver_types_1.SymbolKind.String:
            return vscode_languageserver_types_1.CompletionItemKind.Value;
        case vscode_languageserver_types_1.SymbolKind.Struct:
            return vscode_languageserver_types_1.CompletionItemKind.Struct;
        case vscode_languageserver_types_1.SymbolKind.TypeParameter:
            return vscode_languageserver_types_1.CompletionItemKind.TypeParameter;
        default:
            return undefined;
    }
}
exports.symbolKindToCompletionItemKind = symbolKindToCompletionItemKind;
function tokenPositionToPosition(tokenPosition) {
    return {
        line: tokenPosition.lineNumber,
        character: tokenPosition.lineCodeUnit,
    };
}
exports.tokenPositionToPosition = tokenPositionToPosition;
function tokenPositionToRange(startTokenPosition, endTokenPosition) {
    if (startTokenPosition && endTokenPosition) {
        return {
            start: tokenPositionToPosition(startTokenPosition),
            end: tokenPositionToPosition(endTokenPosition),
        };
    }
    return undefined;
}
exports.tokenPositionToRange = tokenPositionToRange;
function tokenRangeToRange(tokenRange) {
    return tokenPositionToRange(tokenRange.positionStart, tokenRange.positionEnd);
}
exports.tokenRangeToRange = tokenRangeToRange;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/currentDocumentSymbolProvider.js":
/*!*******************************************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/currentDocumentSymbolProvider.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Common = __webpack_require__(/*! ./common */ "../packages/powerquery-language-services/lib/language-services/common.js");
const InspectionHelpers = __webpack_require__(/*! ./inspectionHelpers */ "../packages/powerquery-language-services/lib/language-services/inspectionHelpers.js");
const WorkspaceCache = __webpack_require__(/*! ./workspaceCache */ "../packages/powerquery-language-services/lib/language-services/workspaceCache.js");
class CurrentDocumentSymbolProvider {
    constructor(textDocument, position) {
        this.document = textDocument;
        this.position = position;
    }
    getCompletionItems(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            return Common.documentSymbolToCompletionItem(this.getDocumentSymbols());
        });
    }
    getHover(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: implement - documentSymbols should be a map
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    getSignatureHelp(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: store parser/node info so we can reconstruct the function parameters
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    getDocumentSymbols() {
        if (this.documentSymbols === undefined) {
            this.documentSymbols = [];
            const triedInspection = WorkspaceCache.getTriedInspection(this.document, this.position);
            if (triedInspection && triedInspection.kind === "Ok" /* Ok */) {
                const inspected = triedInspection.value;
                this.documentSymbols = InspectionHelpers.getSymbolsForInspectionScope(inspected);
            }
        }
        return this.documentSymbols;
    }
}
exports.CurrentDocumentSymbolProvider = CurrentDocumentSymbolProvider;
//# sourceMappingURL=currentDocumentSymbolProvider.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/index.js":
/*!*******************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const WorkspaceCache = __webpack_require__(/*! ./workspaceCache */ "../packages/powerquery-language-services/lib/language-services/workspaceCache.js");
function documentUpdated(document) {
    WorkspaceCache.update(document);
}
exports.documentUpdated = documentUpdated;
function documentClosed(document) {
    WorkspaceCache.close(document);
}
exports.documentClosed = documentClosed;
__export(__webpack_require__(/*! ./analysis */ "../packages/powerquery-language-services/lib/language-services/analysis.js"));
__export(__webpack_require__(/*! ./providers */ "../packages/powerquery-language-services/lib/language-services/providers.js"));
__export(__webpack_require__(/*! ./validation */ "../packages/powerquery-language-services/lib/language-services/validation.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/inspectionHelpers.js":
/*!*******************************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/inspectionHelpers.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const PQP = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js");
const Common = __webpack_require__(/*! ./common */ "../packages/powerquery-language-services/lib/language-services/common.js");
function getContextForInspected(inspected) {
    return inspected.maybeInvokeExpression !== undefined
        ? getContextForInvokeExpression(inspected.maybeInvokeExpression)
        : undefined;
}
exports.getContextForInspected = getContextForInspected;
function getContextForInvokeExpression(maybeExpression) {
    const functionName = maybeExpression.maybeName !== undefined ? maybeExpression.maybeName : undefined;
    const argumentOrdinal = maybeExpression.maybeArguments !== undefined ? maybeExpression.maybeArguments.positionArgumentIndex : undefined;
    if (functionName !== undefined || argumentOrdinal !== undefined) {
        return {
            maybeArgumentOrdinal: argumentOrdinal,
            maybeFunctionName: functionName,
        };
    }
    else {
        return undefined;
    }
}
exports.getContextForInvokeExpression = getContextForInvokeExpression;
function getSymbolKindForLiteralExpression(node) {
    switch (node.literalKind) {
        case "List" /* List */:
            return vscode_languageserver_types_1.SymbolKind.Array;
        case "Logical" /* Logical */:
            return vscode_languageserver_types_1.SymbolKind.Boolean;
        case "Null" /* Null */:
            return vscode_languageserver_types_1.SymbolKind.Null;
        case "Numeric" /* Numeric */:
            return vscode_languageserver_types_1.SymbolKind.Number;
        case "Record" /* Record */:
            return vscode_languageserver_types_1.SymbolKind.Struct;
        case "Str" /* Str */:
            return vscode_languageserver_types_1.SymbolKind.String;
        default:
            return PQP.isNever(node.literalKind);
    }
}
exports.getSymbolKindForLiteralExpression = getSymbolKindForLiteralExpression;
function getSymbolKindFromNode(node) {
    switch (node.kind) {
        case "Constant" /* Constant */:
            return vscode_languageserver_types_1.SymbolKind.Constant;
        case "FunctionExpression" /* FunctionExpression */:
            return vscode_languageserver_types_1.SymbolKind.Function;
        case "ListExpression" /* ListExpression */:
            return vscode_languageserver_types_1.SymbolKind.Array;
        case "LiteralExpression" /* LiteralExpression */:
            return getSymbolKindForLiteralExpression(node);
        case "MetadataExpression" /* MetadataExpression */:
            return vscode_languageserver_types_1.SymbolKind.TypeParameter;
        case "RecordExpression" /* RecordExpression */:
            return vscode_languageserver_types_1.SymbolKind.Struct;
        default:
            return vscode_languageserver_types_1.SymbolKind.Variable;
    }
}
exports.getSymbolKindFromNode = getSymbolKindFromNode;
function getSymbolsForLetExpression(expressionNode) {
    const documentSymbols = [];
    for (const element of expressionNode.variableList.elements) {
        const pairedExpression = element;
        const memberSymbol = getSymbolForIdentifierPairedExpression(pairedExpression.node);
        documentSymbols.push(memberSymbol);
    }
    return documentSymbols;
}
exports.getSymbolsForLetExpression = getSymbolsForLetExpression;
function getSymbolsForSection(sectionNode) {
    const documentSymbols = [];
    for (const member of sectionNode.sectionMembers.elements) {
        const memberSymbol = getSymbolForIdentifierPairedExpression(member.namePairedExpression);
        documentSymbols.push(memberSymbol);
    }
    return documentSymbols;
}
exports.getSymbolsForSection = getSymbolsForSection;
function getSymbolForIdentifierPairedExpression(identifierPairedExpressionNode) {
    return {
        kind: getSymbolKindFromNode(identifierPairedExpressionNode.value),
        deprecated: false,
        name: identifierPairedExpressionNode.key.literal,
        range: Common.tokenRangeToRange(identifierPairedExpressionNode.tokenRange),
        selectionRange: Common.tokenRangeToRange(identifierPairedExpressionNode.key.tokenRange),
    };
}
exports.getSymbolForIdentifierPairedExpression = getSymbolForIdentifierPairedExpression;
function getSymbolsForInspectionScope(inspected) {
    const documentSymbols = [];
    for (const [key, scopeItem] of inspected.scope.entries()) {
        let kind;
        let range;
        switch (scopeItem.kind) {
            case "Each" /* Each */: {
                if (scopeItem.each.kind !== "Ast" /* Ast */) {
                    continue;
                }
                kind = vscode_languageserver_types_1.SymbolKind.Variable;
                range = Common.tokenRangeToRange(scopeItem.each.node.tokenRange);
                break;
            }
            case "KeyValuePair" /* KeyValuePair */: {
                if (scopeItem.maybeValue === undefined || scopeItem.maybeValue.kind !== "Ast" /* Ast */) {
                    continue;
                }
                kind = vscode_languageserver_types_1.SymbolKind.Variable;
                range = Common.tokenRangeToRange(scopeItem.key.tokenRange);
                break;
            }
            case "Parameter" /* Parameter */: {
                kind = vscode_languageserver_types_1.SymbolKind.Variable;
                range = Common.tokenRangeToRange(scopeItem.name.tokenRange);
                break;
            }
            case "SectionMember" /* SectionMember */: {
                kind = vscode_languageserver_types_1.SymbolKind.Variable;
                range = Common.tokenRangeToRange(scopeItem.key.tokenRange);
                break;
            }
            case "Undefined" /* Undefined */: {
                if (scopeItem.xorNode.kind !== "Ast" /* Ast */) {
                    continue;
                }
                kind = vscode_languageserver_types_1.SymbolKind.Variable;
                range = Common.tokenRangeToRange(scopeItem.xorNode.node.tokenRange);
                break;
            }
            default:
                throw PQP.isNever(scopeItem);
        }
        documentSymbols.push({
            name: key,
            kind,
            deprecated: false,
            range,
            selectionRange: range,
        });
    }
    return documentSymbols;
}
exports.getSymbolsForInspectionScope = getSymbolsForInspectionScope;
//# sourceMappingURL=inspectionHelpers.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/keywordProvider.js":
/*!*****************************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/keywordProvider.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const PQP = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js");
// TODO: Power Query parser defines constructor functions (ex. #table()) as keywords, but we want
// them to be treated like library functions instead.
const excludedKeywords = ["#binary", "#date", "#datetime", "#datetimezone", "#duration", "#table", "#time"];
class KeywordProvider {
    constructor() {
        this.keywordCompletionItems = [];
        PQP.Keywords.forEach(keyword => {
            if (excludedKeywords.indexOf(keyword) === -1) {
                this.keywordCompletionItems.push({
                    kind: vscode_languageserver_types_1.CompletionItemKind.Keyword,
                    label: keyword,
                });
            }
        });
    }
    // TODO: context sensitive keywords (closing "in" for "let", "otherwise" for "try", etc...)
    getCompletionItems(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keywordCompletionItems;
        });
    }
}
exports.KeywordProvider = KeywordProvider;
//# sourceMappingURL=keywordProvider.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/providers.js":
/*!***********************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/providers.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// TODO: providers for record fields and table columns
class NullLibrarySymbolProvider {
    getCompletionItems(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getHover(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    getSignatureHelp(_context) {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    includeModules(_modules) {
        // No impact
    }
}
exports.NullLibrarySymbolProvider = NullLibrarySymbolProvider;
//# sourceMappingURL=providers.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/validation.js":
/*!************************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/validation.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const PQP = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js");
const WorkspaceCache = __webpack_require__(/*! ./workspaceCache */ "../packages/powerquery-language-services/lib/language-services/workspaceCache.js");
function validate(document) {
    const triedLexParse = WorkspaceCache.getTriedLexParse(document);
    let diagnostics = [];
    if (triedLexParse.kind !== "Ok" /* Ok */) {
        const lexParseErr = triedLexParse.error;
        const innerError = lexParseErr.innerError;
        if (PQP.ParseError.isTInnerParseError(innerError)) {
            const maybeDiagnostic = maybeParseErrorToDiagnostic(innerError);
            if (maybeDiagnostic !== undefined) {
                diagnostics = [maybeDiagnostic];
            }
        }
        else if (PQP.LexError.isTInnerLexError(innerError)) {
            const maybeLexerErrorDiagnostics = maybeLexErrorToDiagnostics(innerError);
            if (maybeLexerErrorDiagnostics !== undefined) {
                diagnostics = maybeLexerErrorDiagnostics;
            }
        }
    }
    return {
        hasErrors: diagnostics.length > 0,
        diagnostics,
    };
}
exports.validate = validate;
function maybeLexErrorToDiagnostics(error) {
    const diagnostics = [];
    // TODO: handle other types of lexer errors
    if (error instanceof PQP.LexError.ErrorLineMapError) {
        for (const errorLine of error.errorLineMap.values()) {
            const innerError = errorLine.error.innerError;
            if (innerError.graphemePosition) {
                const graphemePosition = innerError.graphemePosition;
                const message = innerError.message;
                const position = {
                    line: graphemePosition.lineNumber,
                    character: graphemePosition.lineCodeUnit,
                };
                // TODO: "lex" errors aren't that useful to display to end user. Should we make it more generic?
                diagnostics.push({
                    message: message,
                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                    range: {
                        start: position,
                        end: position,
                    },
                });
            }
        }
    }
    return diagnostics.length ? diagnostics : undefined;
}
function maybeParseErrorToDiagnostic(error) {
    const message = error.message;
    let errorToken;
    if ((error instanceof PQP.ParseError.ExpectedAnyTokenKindError ||
        error instanceof PQP.ParseError.ExpectedTokenKindError) &&
        error.maybeFoundToken !== undefined) {
        errorToken = error.maybeFoundToken.token;
    }
    else if (error instanceof PQP.ParseError.InvalidPrimitiveTypeError) {
        errorToken = error.token;
    }
    else if (error instanceof PQP.ParseError.UnterminatedBracketError) {
        errorToken = error.openBracketToken;
    }
    else if (error instanceof PQP.ParseError.UnterminatedParenthesesError) {
        errorToken = error.openParenthesesToken;
    }
    else if (error instanceof PQP.ParseError.UnusedTokensRemainError) {
        errorToken = error.firstUnusedToken;
    }
    else {
        return undefined;
    }
    return {
        message: message,
        severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
        range: {
            start: {
                line: errorToken.positionStart.lineNumber,
                character: errorToken.positionStart.lineCodeUnit,
            },
            end: {
                line: errorToken.positionEnd.lineNumber,
                character: errorToken.positionEnd.lineCodeUnit,
            },
        },
    };
}
//# sourceMappingURL=validation.js.map

/***/ }),

/***/ "../packages/powerquery-language-services/lib/language-services/workspaceCache.js":
/*!****************************************************************************************!*\
  !*** ../packages/powerquery-language-services/lib/language-services/workspaceCache.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const PQP = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const lexerStateCache = new Map();
const lexerSnapshotCache = new Map();
const triedLexParseCache = new Map();
const triedInspectionCache = new Map();
const allCaches = [lexerSnapshotCache, lexerStateCache, triedLexParseCache, triedInspectionCache];
// TODO: is the position key valid for a single intellisense operation,
// or would it be the same for multiple invocations?
function close(textDocument) {
    allCaches.forEach(map => {
        map.delete(textDocument.uri);
    });
}
exports.close = close;
function update(textDocument) {
    // TODO: support incremental lexing
    // TODO: premptively prepare cache on background thread?
    // TODO: use document version
    close(textDocument);
}
exports.update = update;
function getLexerState(textDocument) {
    return getOrCreate(lexerStateCache, textDocument, createLexerState);
}
exports.getLexerState = getLexerState;
function getTriedLexerSnapshot(textDocument) {
    return getOrCreate(lexerSnapshotCache, textDocument, createTriedLexerSnapshot);
}
exports.getTriedLexerSnapshot = getTriedLexerSnapshot;
function getTriedLexParse(textDocument) {
    return getOrCreate(triedLexParseCache, textDocument, createTriedLexParse);
}
exports.getTriedLexParse = getTriedLexParse;
// We can't easily reuse getOrCreate because inspections require a position argument.
// This results in a double layer cache.
function getTriedInspection(textDocument, position) {
    const cacheKey = textDocument.uri;
    const maybePositionCache = triedInspectionCache.get(cacheKey);
    let positionCache;
    // document has been inspected before
    if (maybePositionCache !== undefined) {
        positionCache = maybePositionCache;
    }
    else {
        positionCache = new WeakMap();
        triedInspectionCache.set(textDocument.uri, positionCache);
    }
    if (positionCache.has(position)) {
        return positionCache.get(position);
    }
    else {
        const value = createTriedInspection(textDocument, position);
        positionCache.set(position, value);
        return value;
    }
}
exports.getTriedInspection = getTriedInspection;
function getOrCreate(cache, textDocument, factoryFn) {
    const cacheKey = textDocument.uri;
    const maybeValue = cache.get(cacheKey);
    if (maybeValue === undefined) {
        const value = factoryFn(textDocument);
        cache.set(cacheKey, value);
        return value;
    }
    else {
        return maybeValue;
    }
}
function createLexerState(textDocument) {
    // TODO (Localization): update settings based on locale
    return PQP.Lexer.stateFrom(PQP.DefaultSettings, textDocument.getText());
}
function createTriedLexerSnapshot(textDocument) {
    const lexerState = getLexerState(textDocument);
    return PQP.LexerSnapshot.tryFrom(lexerState);
}
function createTriedLexParse(textDocument) {
    const triedLexerSnapshot = getTriedLexerSnapshot(textDocument);
    if (triedLexerSnapshot.kind === "Err" /* Err */) {
        return triedLexerSnapshot;
    }
    const lexerSnapshot = triedLexerSnapshot.value;
    // TODO (Localization): update settings based on locale
    const triedParse = PQP.tryParse(PQP.DefaultSettings, lexerSnapshot);
    if (triedParse.kind === "Err" /* Err */) {
        return triedParse;
    }
    const parseOk = triedParse.value;
    return {
        kind: "Ok" /* Ok */,
        value: Object.assign(Object.assign({}, parseOk), { lexerSnapshot }),
    };
}
// We're allowed to return undefined because if a document wasn't parsed
// then there's no way to perform an inspection.
function createTriedInspection(textDocument, position) {
    const triedLexParse = getTriedLexParse(textDocument);
    let nodeIdMapCollection;
    let leafNodeIds;
    let maybeParseError;
    if (triedLexParse.kind === "Err" /* Err */) {
        // You can't inspect something that was never parsed
        if (!(triedLexParse.error instanceof PQP.ParseError.ParseError)) {
            return undefined;
        }
        const context = triedLexParse.error.state.contextState;
        nodeIdMapCollection = context.nodeIdMapCollection;
        leafNodeIds = context.leafNodeIds;
        maybeParseError = triedLexParse.error;
    }
    else {
        const parseOk = triedLexParse.value;
        nodeIdMapCollection = parseOk.nodeIdMapCollection;
        leafNodeIds = parseOk.leafNodeIds;
    }
    const inspectionPosition = {
        lineNumber: position.line,
        lineCodeUnit: position.character,
    };
    return PQP.Inspection.tryFrom(PQP.DefaultSettings, inspectionPosition, nodeIdMapCollection, leafNodeIds, maybeParseError);
}
//# sourceMappingURL=workspaceCache.js.map

/***/ }),

/***/ "../packages/powerquery-library/lib/index.js":
/*!***************************************************!*\
  !*** ../packages/powerquery-library/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./library */ "../packages/powerquery-library/lib/library/index.js"));
__export(__webpack_require__(/*! ./library/jsonTypes */ "../packages/powerquery-library/lib/library/jsonTypes.js"));
__export(__webpack_require__(/*! ./library/staticLibrarySymbolProvider */ "../packages/powerquery-library/lib/library/staticLibrarySymbolProvider.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-library/lib/library/index.js":
/*!***********************************************************!*\
  !*** ../packages/powerquery-library/lib/library/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const StandardLibrary = __webpack_require__(/*! ./standard.json */ "../packages/powerquery-library/lib/library/standard.json");
exports.AllModules = loadAllModules();
// TODO:
// - Use Visibility to define 'ModuleSets' for a given environment (i.e. Power BI, or the SDK)
// - Export LibraryLoader and add constructor that takes in a string[] or ModuleSet
// - Modules can be added/removed from LibraryLoader
// - Call LibraryLoader.load() when ready to retrieve definition
function loadAllModules() {
    return loadStandardLibrary();
}
function loadStandardLibrary() {
    var _a;
    const library = new Map();
    // standard library is listed by module
    for (const mod of StandardLibrary) {
        for (const exported of mod.exports) {
            const signatures = (_a = exported.signatures) !== null && _a !== void 0 ? _a : [];
            library.set(exported.export, Object.assign(Object.assign({}, exported), { label: exported.export, kind: exported.kind, module: {
                    name: mod.module,
                    // TODO until there's at least 1 non-null for version there will be typing issues.
                    // eg `mod.version !== null ? mod.version : mod.version` fails as version is always null,
                    // so Typescript always goes to the false ternary expression which is null causing the ternary's
                    // type to become null.
                    version: undefined,
                    visibility: mod.visibility,
                }, signatures }));
        }
    }
    return library;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../packages/powerquery-library/lib/library/jsonTypes.js":
/*!***************************************************************!*\
  !*** ../packages/powerquery-library/lib/library/jsonTypes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=jsonTypes.js.map

/***/ }),

/***/ "../packages/powerquery-library/lib/library/standard.json":
/*!****************************************************************!*\
  !*** ../packages/powerquery-library/lib/library/standard.json ***!
  \****************************************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, default */
/***/ (function(module) {

module.exports = JSON.parse("[{\"module\":\"Core\",\"version\":null,\"exports\":[{\"export\":\"AccessControlEntry.ConditionContextType\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The authorization context against which an access control entry (ACE) condition is evaluated.\",\"signatures\":null},{\"export\":\"AccessControlEntry.ConditionToIdentities\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of identities that the condition will accept.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"identityProvider\",\"type\":\"function\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":69},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":71,\"signatureLabelEnd\":92}],\"label\":\"AccessControlEntry.ConditionToIdentities(identityProvider as function, condition as function)\"}]},{\"export\":\"AccessControlEntry.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"A table of access control entries (ACEs).\",\"signatures\":null},{\"export\":\"AccessControlKind.Allow\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Access is allowed.\",\"signatures\":null},{\"export\":\"AccessControlKind.Deny\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Access is denied.\",\"signatures\":null},{\"export\":\"AccessControlKind.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the kind of access control.\",\"signatures\":null},{\"export\":\"Any.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all values.\",\"signatures\":null},{\"export\":\"Binary.Buffer\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Buffers the binary value in memory.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39}],\"label\":\"Binary.Buffer(binary as nullable binary)\"}]},{\"export\":\"Binary.Combine\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Combines a list of binaries into a single binary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaries\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":31}],\"label\":\"Binary.Combine(binaries as list)\"}]},{\"export\":\"Binary.Compress\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Compresses a binary value using the given compression type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"compressionType\",\"type\":\"number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":68}],\"label\":\"Binary.Compress(binary as nullable binary, compressionType as number)\"}]},{\"export\":\"Binary.Decompress\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Decompresses a binary value using the given compression type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"compressionType\",\"type\":\"number\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":70}],\"label\":\"Binary.Decompress(binary as nullable binary, compressionType as number)\"}]},{\"export\":\"Binary.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Creates a binary from the given value\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Binary.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":53}],\"label\":\"Binary.From(value as any, encoding as nullable number)\"}]},{\"export\":\"Binary.FromList\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Converts a list of numbers into a binary value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Binary.FromList(list as list)\"}]},{\"export\":\"Binary.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Decodes data from a text form into binary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37}],\"label\":\"Binary.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":66}],\"label\":\"Binary.FromText(text as nullable text, encoding as nullable number)\"}]},{\"export\":\"Binary.InferContentType\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Reads the binary stream and tries to determine the content type and format information of the stream.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"binary\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":40}],\"label\":\"Binary.InferContentType(source as binary)\"}]},{\"export\":\"Binary.Length\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the number of characters.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39}],\"label\":\"Binary.Length(binary as nullable binary)\"}]},{\"export\":\"Binary.ToList\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Converts a binary value into a list of numbers.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":30}],\"label\":\"Binary.ToList(binary as binary)\"}]},{\"export\":\"Binary.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Encodes binary data into a text form.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39}],\"label\":\"Binary.ToText(binary as nullable binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":68}],\"label\":\"Binary.ToText(binary as nullable binary, encoding as nullable number)\"}]},{\"export\":\"Binary.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all binary values.\",\"signatures\":null},{\"export\":\"BinaryEncoding.Base64\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Constant to use as the encoding type when base-64 encoding is required.\",\"signatures\":null},{\"export\":\"BinaryEncoding.Hex\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Constant to use as the encoding type when hexadecimal encoding is required.\",\"signatures\":null},{\"export\":\"BinaryEncoding.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the type of binary encoding.\",\"signatures\":null},{\"export\":\"BinaryFormat.7BitEncodedSignedInteger\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 64-bit signed integer that was encoded using a 7-bit variable-length encoding.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":54}],\"label\":\"BinaryFormat.7BitEncodedSignedInteger(binary as binary)\"}]},{\"export\":\"BinaryFormat.7BitEncodedUnsignedInteger\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 64-bit unsigned integer that was encoded using a 7-bit variable-length encoding.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":56}],\"label\":\"BinaryFormat.7BitEncodedUnsignedInteger(binary as binary)\"}]},{\"export\":\"BinaryFormat.Binary\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that reads a binary value.\",\"signatures\":[{\"parameters\":[],\"label\":\"BinaryFormat.Binary()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"length\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":33}],\"label\":\"BinaryFormat.Binary(length as any)\"}]},{\"export\":\"BinaryFormat.Byte\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads an 8-bit unsigned integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":34}],\"label\":\"BinaryFormat.Byte(binary as binary)\"}]},{\"export\":\"BinaryFormat.ByteOrder\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format with the byte order specified by a function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"byteOrder\",\"type\":\"number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":68}],\"label\":\"BinaryFormat.ByteOrder(binaryFormat as function, byteOrder as number)\"}]},{\"export\":\"BinaryFormat.Choice\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that chooses the next binary format based on a value that has already been read.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"chooseFunction\",\"type\":\"function\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72}],\"label\":\"BinaryFormat.Choice(binaryFormat as function, chooseFunction as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"chooseFunction\",\"type\":\"function\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"type\",\"type\":\"nullable type\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":95}],\"label\":\"BinaryFormat.Choice(binaryFormat as function, chooseFunction as function, type as nullable type)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"chooseFunction\",\"type\":\"function\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"type\",\"type\":\"nullable type\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":95},{\"documentation\":null,\"label\":\"combineFunction\",\"type\":\"nullable function\",\"signatureLabelOffset\":97,\"signatureLabelEnd\":133}],\"label\":\"BinaryFormat.Choice(binaryFormat as function, chooseFunction as function, type as nullable type, combineFunction as nullable function)\"}]},{\"export\":\"BinaryFormat.Decimal\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a .NET 16-byte decimal value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":37}],\"label\":\"BinaryFormat.Decimal(binary as binary)\"}]},{\"export\":\"BinaryFormat.Double\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads an 8-byte IEEE double-precision floating point value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36}],\"label\":\"BinaryFormat.Double(binary as binary)\"}]},{\"export\":\"BinaryFormat.Group\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that reads a group of items.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"group\",\"type\":\"list\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":58}],\"label\":\"BinaryFormat.Group(binaryFormat as function, group as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"group\",\"type\":\"list\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"extra\",\"type\":\"nullable function\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":86}],\"label\":\"BinaryFormat.Group(binaryFormat as function, group as list, extra as nullable function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"group\",\"type\":\"list\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"extra\",\"type\":\"nullable function\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":86},{\"documentation\":null,\"label\":\"lastKey\",\"type\":\"any\",\"signatureLabelOffset\":88,\"signatureLabelEnd\":102}],\"label\":\"BinaryFormat.Group(binaryFormat as function, group as list, extra as nullable function, lastKey as any)\"}]},{\"export\":\"BinaryFormat.Length\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that limits the amount of data that can be read.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"length\",\"type\":\"any\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":59}],\"label\":\"BinaryFormat.Length(binaryFormat as function, length as any)\"}]},{\"export\":\"BinaryFormat.List\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that reads a sequence of items and returns a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":42}],\"label\":\"BinaryFormat.List(binaryFormat as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":67}],\"label\":\"BinaryFormat.List(binaryFormat as function, countOrCondition as any)\"}]},{\"export\":\"BinaryFormat.Null\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads zero bytes and returns null.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":34}],\"label\":\"BinaryFormat.Null(binary as binary)\"}]},{\"export\":\"BinaryFormat.Record\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that reads a record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36}],\"label\":\"BinaryFormat.Record(record as record)\"}]},{\"export\":\"BinaryFormat.SignedInteger16\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 16-bit signed integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45}],\"label\":\"BinaryFormat.SignedInteger16(binary as binary)\"}]},{\"export\":\"BinaryFormat.SignedInteger32\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 32-bit signed integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45}],\"label\":\"BinaryFormat.SignedInteger32(binary as binary)\"}]},{\"export\":\"BinaryFormat.SignedInteger64\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 64-bit signed integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45}],\"label\":\"BinaryFormat.SignedInteger64(binary as binary)\"}]},{\"export\":\"BinaryFormat.Single\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 4-byte IEEE single-precision floating point value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36}],\"label\":\"BinaryFormat.Single(binary as binary)\"}]},{\"export\":\"BinaryFormat.Text\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that reads a text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"length\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31}],\"label\":\"BinaryFormat.Text(length as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"length\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":60}],\"label\":\"BinaryFormat.Text(length as any, encoding as nullable number)\"}]},{\"export\":\"BinaryFormat.Transform\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a binary format that will transform the values read by another binary format.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binaryFormat\",\"type\":\"function\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":69}],\"label\":\"BinaryFormat.Transform(binaryFormat as function, function as function)\"}]},{\"export\":\"BinaryFormat.UnsignedInteger16\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 16-bit unsigned integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":47}],\"label\":\"BinaryFormat.UnsignedInteger16(binary as binary)\"}]},{\"export\":\"BinaryFormat.UnsignedInteger32\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 32-bit unsigned integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":47}],\"label\":\"BinaryFormat.UnsignedInteger32(binary as binary)\"}]},{\"export\":\"BinaryFormat.UnsignedInteger64\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"A binary format that reads a 64-bit unsigned integer.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":47}],\"label\":\"BinaryFormat.UnsignedInteger64(binary as binary)\"}]},{\"export\":\"BinaryOccurrence.Optional\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear zero or one time in the input.\",\"signatures\":null},{\"export\":\"BinaryOccurrence.Repeating\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear zero or more times in the input.\",\"signatures\":null},{\"export\":\"BinaryOccurrence.Required\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear once in the input.\",\"signatures\":null},{\"export\":\"BinaryOccurrence.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies how many times the item is expected to appear in the group.\",\"signatures\":null},{\"export\":\"Byte.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a 8-bit integer from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"Byte.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48}],\"label\":\"Byte.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":81}],\"label\":\"Byte.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Byte.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all bytes.\",\"signatures\":null},{\"export\":\"ByteOrder.BigEndian\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the <code>byteOrder</code> parameter in <code>BinaryFormat.ByteOrder</code>.  The most signficant byte appears first in Big Endian byte order.\",\"signatures\":null},{\"export\":\"ByteOrder.LittleEndian\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the <code>byteOrder</code> parameter in <code>BinaryFormat.ByteOrder</code>.  The least signficant byte appears first in Little Endian byte order.\",\"signatures\":null},{\"export\":\"ByteOrder.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the byte order.\",\"signatures\":null},{\"export\":\"Character.FromNumber\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Converts the number to its character value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":46}],\"label\":\"Character.FromNumber(number as nullable number)\"}]},{\"export\":\"Character.ToNumber\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Converts a character to its number value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"character\",\"type\":\"nullable text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":45}],\"label\":\"Character.ToNumber(character as nullable text)\"}]},{\"export\":\"Character.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all characters.\",\"signatures\":null},{\"export\":\"Combiner.CombineTextByDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that combines a list of text into a single text using the specified delimiter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":49}],\"label\":\"Combiner.CombineTextByDelimiter(delimiter as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":80}],\"label\":\"Combiner.CombineTextByDelimiter(delimiter as text, quoteStyle as nullable number)\"}]},{\"export\":\"Combiner.CombineTextByEachDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that combines a list of text into a single text using each specified delimiter in sequence.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":54}],\"label\":\"Combiner.CombineTextByEachDelimiter(delimiters as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":85}],\"label\":\"Combiner.CombineTextByEachDelimiter(delimiters as list, quoteStyle as nullable number)\"}]},{\"export\":\"Combiner.CombineTextByLengths\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that combines a list of text into a single text using the specified lengths.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lengths\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45}],\"label\":\"Combiner.CombineTextByLengths(lengths as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lengths\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"template\",\"type\":\"nullable text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":72}],\"label\":\"Combiner.CombineTextByLengths(lengths as list, template as nullable text)\"}]},{\"export\":\"Combiner.CombineTextByPositions\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that combines a list of text into a single text using the specified positions.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"positions\",\"type\":\"list\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":49}],\"label\":\"Combiner.CombineTextByPositions(positions as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"positions\",\"type\":\"list\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"template\",\"type\":\"nullable text\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":76}],\"label\":\"Combiner.CombineTextByPositions(positions as list, template as nullable text)\"}]},{\"export\":\"Combiner.CombineTextByRanges\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that combines a list of text into a single text using the specified positions and lengths.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"ranges\",\"type\":\"list\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":43}],\"label\":\"Combiner.CombineTextByRanges(ranges as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"ranges\",\"type\":\"list\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"template\",\"type\":\"nullable text\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":70}],\"label\":\"Combiner.CombineTextByRanges(ranges as list, template as nullable text)\"}]},{\"export\":\"Comparer.Equals\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns a logical value based on the equality check over the two given values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"comparer\",\"type\":\"function\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"x\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"y\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":56}],\"label\":\"Comparer.Equals(comparer as function, x as any, y as any)\"}]},{\"export\":\"Comparer.FromCulture\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a comparer function given the culture and a logical value for case sensitivity for the comparison.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"culture\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Comparer.FromCulture(culture as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"culture\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"ignoreCase\",\"type\":\"nullable logical\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":68}],\"label\":\"Comparer.FromCulture(culture as text, ignoreCase as nullable logical)\"}]},{\"export\":\"Comparer.Ordinal\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns a comparer function which uses Ordinal rules to compare values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"x\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"y\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":35}],\"label\":\"Comparer.Ordinal(x as any, y as any)\"}]},{\"export\":\"Comparer.OrdinalIgnoreCase\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns a case-insensitive comparer function which uses Ordinal rules to compare values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"x\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"y\",\"type\":\"any\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":45}],\"label\":\"Comparer.OrdinalIgnoreCase(x as any, y as any)\"}]},{\"export\":\"Compression.Deflate\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The compressed data is in the 'Deflate' format.\",\"signatures\":null},{\"export\":\"Compression.GZip\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The compressed data is in the 'GZip' format.\",\"signatures\":null},{\"export\":\"Compression.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the type of compression.\",\"signatures\":null},{\"export\":\"Csv.Document\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the contents of the CSV document as a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26}],\"label\":\"Csv.Document(source as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":42}],\"label\":\"Csv.Document(source as any, columns as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"any\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":60}],\"label\":\"Csv.Document(source as any, columns as any, delimiter as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"any\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"extraValues\",\"type\":\"nullable number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":92}],\"label\":\"Csv.Document(source as any, columns as any, delimiter as any, extraValues as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"any\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"extraValues\",\"type\":\"nullable number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":92},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":94,\"signatureLabelEnd\":121}],\"label\":\"Csv.Document(source as any, columns as any, delimiter as any, extraValues as nullable number, encoding as nullable number)\"}]},{\"export\":\"CsvStyle.QuoteAfterDelimiter\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Quotes in a field are only significant immediately following the delimiter.\",\"signatures\":null},{\"export\":\"CsvStyle.QuoteAlways\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Quotes in a field are always significant regardless of where they appear.\",\"signatures\":null},{\"export\":\"CsvStyle.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the significance of quotes in Csv documents.\",\"signatures\":null},{\"export\":\"Cube.AddAndExpandDimensionColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Merges the specified dimension table into the cubes filter context and changes the dimensional granularity of the filter context by expanding the specified set of dimension attributes.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"dimensionSelector\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"attributeNames\",\"type\":\"list\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":96}],\"label\":\"Cube.AddAndExpandDimensionColumn(cube as table, dimensionSelector as any, attributeNames as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"dimensionSelector\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"attributeNames\",\"type\":\"list\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":96},{\"documentation\":null,\"label\":\"newColumnNames\",\"type\":\"any\",\"signatureLabelOffset\":98,\"signatureLabelEnd\":119}],\"label\":\"Cube.AddAndExpandDimensionColumn(cube as table, dimensionSelector as any, attributeNames as list, newColumnNames as any)\"}]},{\"export\":\"Cube.AddMeasureColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Adds a column to the cube that contains the results of the measure applied in the row context of each row.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"measureSelector\",\"type\":\"any\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":75}],\"label\":\"Cube.AddMeasureColumn(cube as table, column as text, measureSelector as any)\"}]},{\"export\":\"Cube.ApplyParameter\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a cube after applying a parameter to it.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"parameter\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":51}],\"label\":\"Cube.ApplyParameter(cube as table, parameter as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"parameter\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"arguments\",\"type\":\"nullable list\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":79}],\"label\":\"Cube.ApplyParameter(cube as table, parameter as any, arguments as nullable list)\"}]},{\"export\":\"Cube.AttributeMemberId\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the unique member identifier from members property value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"attribute\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":39}],\"label\":\"Cube.AttributeMemberId(attribute as any)\"}]},{\"export\":\"Cube.AttributeMemberProperty\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a property of a dimension attribute.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"attribute\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"propertyName\",\"type\":\"text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":67}],\"label\":\"Cube.AttributeMemberProperty(attribute as any, propertyName as text)\"}]},{\"export\":\"Cube.CollapseAndRemoveColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Changes the dimensional granularity of the filter context for the cube by collapsing the attributes mapped to the specified columns.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"columnNames\",\"type\":\"list\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":64}],\"label\":\"Cube.CollapseAndRemoveColumns(cube as table, columnNames as list)\"}]},{\"export\":\"Cube.Dimensions\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the set of available dimensions.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":29}],\"label\":\"Cube.Dimensions(cube as table)\"}]},{\"export\":\"Cube.DisplayFolders\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a nested tree of tables representing the display folder hierarchy of the objects (e.g. dimensions and measures).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":33}],\"label\":\"Cube.DisplayFolders(cube as table)\"}]},{\"export\":\"Cube.MeasureProperties\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the set of available measure properties that are expanded in the cube.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":36}],\"label\":\"Cube.MeasureProperties(cube as table)\"}]},{\"export\":\"Cube.MeasureProperty\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a property of a measure (cell property).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"measure\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"propertyName\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":57}],\"label\":\"Cube.MeasureProperty(measure as any, propertyName as text)\"}]},{\"export\":\"Cube.Measures\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the set of available measures.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":25}],\"label\":\"Cube.Measures(cube as any)\"}]},{\"export\":\"Cube.Parameters\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the set of parameters that can be applied to the cube.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":29}],\"label\":\"Cube.Parameters(cube as table)\"}]},{\"export\":\"Cube.Properties\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the set of available properties for dimensions that are expanded in the cube.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":29}],\"label\":\"Cube.Properties(cube as table)\"}]},{\"export\":\"Cube.PropertyKey\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the key of a property.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"property\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Cube.PropertyKey(property as any)\"}]},{\"export\":\"Cube.ReplaceDimensions\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Cube.ReplaceDimensions\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"dimensions\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":55}],\"label\":\"Cube.ReplaceDimensions(cube as table, dimensions as any)\"}]},{\"export\":\"Cube.Transform\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Applies a list of cube functions.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"cube\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"transforms\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":48}],\"label\":\"Cube.Transform(cube as table, transforms as list)\"}]},{\"export\":\"Culture.Current\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Returns the name of the current culture for the application.\",\"signatures\":null},{\"export\":\"Currency.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a currency value from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Currency.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":52}],\"label\":\"Currency.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":85}],\"label\":\"Currency.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Currency.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents currency value.\",\"signatures\":null},{\"export\":\"Date.AddDays\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Adds the specified days to the date.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"numberOfDays\",\"type\":\"number\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":52}],\"label\":\"Date.AddDays(dateTime as any, numberOfDays as number)\"}]},{\"export\":\"Date.AddMonths\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Adds the specified months to the date.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"numberOfMonths\",\"type\":\"number\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":56}],\"label\":\"Date.AddMonths(dateTime as any, numberOfMonths as number)\"}]},{\"export\":\"Date.AddQuarters\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Adds the specified quarters to the date.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"numberOfQuarters\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":60}],\"label\":\"Date.AddQuarters(dateTime as any, numberOfQuarters as number)\"}]},{\"export\":\"Date.AddWeeks\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Adds the specified weeks to the date.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"numberOfWeeks\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":54}],\"label\":\"Date.AddWeeks(dateTime as any, numberOfWeeks as number)\"}]},{\"export\":\"Date.AddYears\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Adds the specified years to the date.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"numberOfYears\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":54}],\"label\":\"Date.AddYears(dateTime as any, numberOfYears as number)\"}]},{\"export\":\"Date.Day\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the day component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":24}],\"label\":\"Date.Day(dateTime as any)\"}]},{\"export\":\"Date.DayOfWeek\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number (from 0 to 6) indicating the day of the week of the provided value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Date.DayOfWeek(dateTime as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"firstDayOfWeek\",\"type\":\"nullable number\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":65}],\"label\":\"Date.DayOfWeek(dateTime as any, firstDayOfWeek as nullable number)\"}]},{\"export\":\"Date.DayOfWeekName\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the day of the week name.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"any\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":30}],\"label\":\"Date.DayOfWeekName(date as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"any\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":56}],\"label\":\"Date.DayOfWeekName(date as any, culture as nullable text)\"}]},{\"export\":\"Date.DayOfYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number from 1 to 366 representing the day of the year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Date.DayOfYear(dateTime as any)\"}]},{\"export\":\"Date.DaysInMonth\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number from 28 to 31 indicating the number of days in the month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Date.DaysInMonth(dateTime as any)\"}]},{\"export\":\"Date.EndOfDay\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last value of the day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29}],\"label\":\"Date.EndOfDay(dateTime as any)\"}]},{\"export\":\"Date.EndOfMonth\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last day of the month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Date.EndOfMonth(dateTime as any)\"}]},{\"export\":\"Date.EndOfQuarter\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last value of the quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33}],\"label\":\"Date.EndOfQuarter(dateTime as any)\"}]},{\"export\":\"Date.EndOfWeek\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last day of the week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Date.EndOfWeek(dateTime as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"firstDayOfWeek\",\"type\":\"nullable number\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":65}],\"label\":\"Date.EndOfWeek(dateTime as any, firstDayOfWeek as nullable number)\"}]},{\"export\":\"Date.EndOfYear\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last datetime value of the year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Date.EndOfYear(dateTime as any)\"}]},{\"export\":\"Date.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable date\",\"summary\":\"Creates a date from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"Date.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48}],\"label\":\"Date.From(value as any, culture as nullable text)\"}]},{\"export\":\"Date.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable date\",\"summary\":\"Creates a Date from local and universal Date formats.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35}],\"label\":\"Date.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":61}],\"label\":\"Date.FromText(text as nullable text, culture as nullable text)\"}]},{\"export\":\"Date.IsInCurrentDay\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current day, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35}],\"label\":\"Date.IsInCurrentDay(dateTime as any)\"}]},{\"export\":\"Date.IsInCurrentMonth\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current month, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37}],\"label\":\"Date.IsInCurrentMonth(dateTime as any)\"}]},{\"export\":\"Date.IsInCurrentQuarter\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current quarter, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39}],\"label\":\"Date.IsInCurrentQuarter(dateTime as any)\"}]},{\"export\":\"Date.IsInCurrentWeek\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current week, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Date.IsInCurrentWeek(dateTime as any)\"}]},{\"export\":\"Date.IsInCurrentYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current year, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Date.IsInCurrentYear(dateTime as any)\"}]},{\"export\":\"Date.IsInNextDay\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next day, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Date.IsInNextDay(dateTime as any)\"}]},{\"export\":\"Date.IsInNextMonth\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next month, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34}],\"label\":\"Date.IsInNextMonth(dateTime as any)\"}]},{\"export\":\"Date.IsInNextNDays\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next number of days, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"days\",\"type\":\"number\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50}],\"label\":\"Date.IsInNextNDays(dateTime as any, days as number)\"}]},{\"export\":\"Date.IsInNextNMonths\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next number of months, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"months\",\"type\":\"number\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":54}],\"label\":\"Date.IsInNextNMonths(dateTime as any, months as number)\"}]},{\"export\":\"Date.IsInNextNQuarters\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next number of quarters, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"quarters\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":58}],\"label\":\"Date.IsInNextNQuarters(dateTime as any, quarters as number)\"}]},{\"export\":\"Date.IsInNextNWeeks\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next number of weeks, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"weeks\",\"type\":\"number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":52}],\"label\":\"Date.IsInNextNWeeks(dateTime as any, weeks as number)\"}]},{\"export\":\"Date.IsInNextNYears\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next number of years, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"years\",\"type\":\"number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":52}],\"label\":\"Date.IsInNextNYears(dateTime as any, years as number)\"}]},{\"export\":\"Date.IsInNextQuarter\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next quarter, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Date.IsInNextQuarter(dateTime as any)\"}]},{\"export\":\"Date.IsInNextWeek\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next week, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33}],\"label\":\"Date.IsInNextWeek(dateTime as any)\"}]},{\"export\":\"Date.IsInNextYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the next year, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33}],\"label\":\"Date.IsInNextYear(dateTime as any)\"}]},{\"export\":\"Date.IsInPreviousDay\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous day, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Date.IsInPreviousDay(dateTime as any)\"}]},{\"export\":\"Date.IsInPreviousMonth\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous month, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":38}],\"label\":\"Date.IsInPreviousMonth(dateTime as any)\"}]},{\"export\":\"Date.IsInPreviousNDays\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous number of days, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"days\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":54}],\"label\":\"Date.IsInPreviousNDays(dateTime as any, days as number)\"}]},{\"export\":\"Date.IsInPreviousNMonths\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous number of months, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"months\",\"type\":\"number\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":58}],\"label\":\"Date.IsInPreviousNMonths(dateTime as any, months as number)\"}]},{\"export\":\"Date.IsInPreviousNQuarters\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous number of quarters, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"quarters\",\"type\":\"number\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":62}],\"label\":\"Date.IsInPreviousNQuarters(dateTime as any, quarters as number)\"}]},{\"export\":\"Date.IsInPreviousNWeeks\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous number of weeks, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"weeks\",\"type\":\"number\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56}],\"label\":\"Date.IsInPreviousNWeeks(dateTime as any, weeks as number)\"}]},{\"export\":\"Date.IsInPreviousNYears\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous number of years, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"years\",\"type\":\"number\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56}],\"label\":\"Date.IsInPreviousNYears(dateTime as any, years as number)\"}]},{\"export\":\"Date.IsInPreviousQuarter\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous quarter, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":40}],\"label\":\"Date.IsInPreviousQuarter(dateTime as any)\"}]},{\"export\":\"Date.IsInPreviousWeek\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous week, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37}],\"label\":\"Date.IsInPreviousWeek(dateTime as any)\"}]},{\"export\":\"Date.IsInPreviousYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the previous year, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37}],\"label\":\"Date.IsInPreviousYear(dateTime as any)\"}]},{\"export\":\"Date.IsInYearToDate\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date occurs during the current year and is on or before the current day, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35}],\"label\":\"Date.IsInYearToDate(dateTime as any)\"}]},{\"export\":\"Date.IsLeapYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this date falls in a leap year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Date.IsLeapYear(dateTime as any)\"}]},{\"export\":\"Date.Month\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the month component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26}],\"label\":\"Date.Month(dateTime as any)\"}]},{\"export\":\"Date.MonthName\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the name of the month component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26}],\"label\":\"Date.MonthName(date as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":52}],\"label\":\"Date.MonthName(date as any, culture as nullable text)\"}]},{\"export\":\"Date.QuarterOfYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number indicating which quarter of the year the date falls in.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34}],\"label\":\"Date.QuarterOfYear(dateTime as any)\"}]},{\"export\":\"Date.StartOfDay\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Date.StartOfDay(dateTime as any)\"}]},{\"export\":\"Date.StartOfMonth\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the month.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33}],\"label\":\"Date.StartOfMonth(dateTime as any)\"}]},{\"export\":\"Date.StartOfQuarter\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the quarter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35}],\"label\":\"Date.StartOfQuarter(dateTime as any)\"}]},{\"export\":\"Date.StartOfWeek\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the week.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Date.StartOfWeek(dateTime as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"firstDayOfWeek\",\"type\":\"nullable number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":67}],\"label\":\"Date.StartOfWeek(dateTime as any, firstDayOfWeek as nullable number)\"}]},{\"export\":\"Date.StartOfYear\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the year.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Date.StartOfYear(dateTime as any)\"}]},{\"export\":\"Date.ToRecord\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record containing parts of the date value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"date\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Date.ToRecord(date as date)\"}]},{\"export\":\"Date.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a textual representation of the Date value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"nullable date\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33}],\"label\":\"Date.ToText(date as nullable date)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"nullable date\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":58}],\"label\":\"Date.ToText(date as nullable date, format as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"date\",\"type\":\"nullable date\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":84}],\"label\":\"Date.ToText(date as nullable date, format as nullable text, culture as nullable text)\"}]},{\"export\":\"Date.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all date values.\",\"signatures\":null},{\"export\":\"Date.WeekOfMonth\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number from 1 to 5 indicating which week of the month this date falls in.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Date.WeekOfMonth(dateTime as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"firstDayOfWeek\",\"type\":\"nullable number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":67}],\"label\":\"Date.WeekOfMonth(dateTime as any, firstDayOfWeek as nullable number)\"}]},{\"export\":\"Date.WeekOfYear\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a number from 1 to 54 indicating which week of the year this date falls in.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Date.WeekOfYear(dateTime as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"firstDayOfWeek\",\"type\":\"nullable number\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":66}],\"label\":\"Date.WeekOfYear(dateTime as any, firstDayOfWeek as nullable number)\"}]},{\"export\":\"Date.Year\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the year component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":25}],\"label\":\"Date.Year(dateTime as any)\"}]},{\"export\":\"DateTime.AddZone\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Sets timezone information on the datetime value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"nullable datetime\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"timezoneHours\",\"type\":\"number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":71}],\"label\":\"DateTime.AddZone(dateTime as nullable datetime, timezoneHours as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"nullable datetime\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"timezoneHours\",\"type\":\"number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":71},{\"documentation\":null,\"label\":\"timezoneMinutes\",\"type\":\"nullable number\",\"signatureLabelOffset\":73,\"signatureLabelEnd\":107}],\"label\":\"DateTime.AddZone(dateTime as nullable datetime, timezoneHours as number, timezoneMinutes as nullable number)\"}]},{\"export\":\"DateTime.Date\",\"kind\":\"Function\",\"primitiveType\":\"nullable date\",\"summary\":\"Returns the date component of the given date, datetime, or datetimezone value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29}],\"label\":\"DateTime.Date(dateTime as any)\"}]},{\"export\":\"DateTime.FixedLocalNow\",\"kind\":\"Function\",\"primitiveType\":\"datetime\",\"summary\":\"Returns the current date and time in the local timezone. This value is fixed and will not change with successive calls.\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTime.FixedLocalNow()\"}]},{\"export\":\"DateTime.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetime\",\"summary\":\"Creates a datetime from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"DateTime.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":52}],\"label\":\"DateTime.From(value as any, culture as nullable text)\"}]},{\"export\":\"DateTime.FromFileTime\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetime\",\"summary\":\"Creates a datetime from a 64 bits long number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"fileTime\",\"type\":\"nullable number\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":49}],\"label\":\"DateTime.FromFileTime(fileTime as nullable number)\"}]},{\"export\":\"DateTime.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetime\",\"summary\":\"Creates a datetime from local and universal datetime formats.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":39}],\"label\":\"DateTime.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":65}],\"label\":\"DateTime.FromText(text as nullable text, culture as nullable text)\"}]},{\"export\":\"DateTime.IsInCurrentHour\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the current hour, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":40}],\"label\":\"DateTime.IsInCurrentHour(dateTime as any)\"}]},{\"export\":\"DateTime.IsInCurrentMinute\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the current minute, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":42}],\"label\":\"DateTime.IsInCurrentMinute(dateTime as any)\"}]},{\"export\":\"DateTime.IsInCurrentSecond\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the current second, as determined by the current date and time on the system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":42}],\"label\":\"DateTime.IsInCurrentSecond(dateTime as any)\"}]},{\"export\":\"DateTime.IsInNextHour\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next hour, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37}],\"label\":\"DateTime.IsInNextHour(dateTime as any)\"}]},{\"export\":\"DateTime.IsInNextMinute\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next minute, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39}],\"label\":\"DateTime.IsInNextMinute(dateTime as any)\"}]},{\"export\":\"DateTime.IsInNextNHours\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next number of hours, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"hours\",\"type\":\"number\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56}],\"label\":\"DateTime.IsInNextNHours(dateTime as any, hours as number)\"}]},{\"export\":\"DateTime.IsInNextNMinutes\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next number of minutes, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"minutes\",\"type\":\"number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60}],\"label\":\"DateTime.IsInNextNMinutes(dateTime as any, minutes as number)\"}]},{\"export\":\"DateTime.IsInNextNSeconds\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next number of seconds, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"seconds\",\"type\":\"number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60}],\"label\":\"DateTime.IsInNextNSeconds(dateTime as any, seconds as number)\"}]},{\"export\":\"DateTime.IsInNextSecond\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the next second, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39}],\"label\":\"DateTime.IsInNextSecond(dateTime as any)\"}]},{\"export\":\"DateTime.IsInPreviousHour\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous hour, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41}],\"label\":\"DateTime.IsInPreviousHour(dateTime as any)\"}]},{\"export\":\"DateTime.IsInPreviousMinute\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous minute, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":43}],\"label\":\"DateTime.IsInPreviousMinute(dateTime as any)\"}]},{\"export\":\"DateTime.IsInPreviousNHours\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous number of hours, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"hours\",\"type\":\"number\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":60}],\"label\":\"DateTime.IsInPreviousNHours(dateTime as any, hours as number)\"}]},{\"export\":\"DateTime.IsInPreviousNMinutes\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous number of minutes, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"minutes\",\"type\":\"number\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":64}],\"label\":\"DateTime.IsInPreviousNMinutes(dateTime as any, minutes as number)\"}]},{\"export\":\"DateTime.IsInPreviousNSeconds\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous number of seconds, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"seconds\",\"type\":\"number\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":64}],\"label\":\"DateTime.IsInPreviousNSeconds(dateTime as any, seconds as number)\"}]},{\"export\":\"DateTime.IsInPreviousSecond\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether this datetime occurs during the previous second, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":43}],\"label\":\"DateTime.IsInPreviousSecond(dateTime as any)\"}]},{\"export\":\"DateTime.LocalNow\",\"kind\":\"Function\",\"primitiveType\":\"datetime\",\"summary\":\"Returns the current date and time in the local timezone.\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTime.LocalNow()\"}]},{\"export\":\"DateTime.Time\",\"kind\":\"Function\",\"primitiveType\":\"nullable time\",\"summary\":\"Returns the time part of the given datetime value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29}],\"label\":\"DateTime.Time(dateTime as any)\"}]},{\"export\":\"DateTime.ToRecord\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record containing the datetime value's parts.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"datetime\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":38}],\"label\":\"DateTime.ToRecord(dateTime as datetime)\"}]},{\"export\":\"DateTime.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a textual representation of the datetime value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"nullable datetime\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":45}],\"label\":\"DateTime.ToText(dateTime as nullable datetime)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"nullable datetime\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":70}],\"label\":\"DateTime.ToText(dateTime as nullable datetime, format as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"nullable datetime\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":70},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":72,\"signatureLabelEnd\":96}],\"label\":\"DateTime.ToText(dateTime as nullable datetime, format as nullable text, culture as nullable text)\"}]},{\"export\":\"DateTime.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all date and time values without an associated timezone.\",\"signatures\":null},{\"export\":\"DateTimeZone.FixedLocalNow\",\"kind\":\"Function\",\"primitiveType\":\"datetimezone\",\"summary\":\"Returns the current date & time in the local timezone. This value is fixed and will not change with successive calls.\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTimeZone.FixedLocalNow()\"}]},{\"export\":\"DateTimeZone.FixedUtcNow\",\"kind\":\"Function\",\"primitiveType\":\"datetimezone\",\"summary\":\"Returns the current date and time in UTC (the GMT timezone). This value is fixed and will not change with successive calls.\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTimeZone.FixedUtcNow()\"}]},{\"export\":\"DateTimeZone.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Creates a datetimezone from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"DateTimeZone.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":56}],\"label\":\"DateTimeZone.From(value as any, culture as nullable text)\"}]},{\"export\":\"DateTimeZone.FromFileTime\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Creates a datetimezone from a 64 bits long number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"fileTime\",\"type\":\"nullable number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":53}],\"label\":\"DateTimeZone.FromFileTime(fileTime as nullable number)\"}]},{\"export\":\"DateTimeZone.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Creates a datetimezone from local and universal datetime formats.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":43}],\"label\":\"DateTimeZone.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":69}],\"label\":\"DateTimeZone.FromText(text as nullable text, culture as nullable text)\"}]},{\"export\":\"DateTimeZone.LocalNow\",\"kind\":\"Function\",\"primitiveType\":\"datetimezone\",\"summary\":\"Returns the current date & time in the local timezone.\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTimeZone.LocalNow()\"}]},{\"export\":\"DateTimeZone.RemoveZone\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetime\",\"summary\":\"Removes timezone information from the given datetimezone value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":61}],\"label\":\"DateTimeZone.RemoveZone(dateTimeZone as nullable datetimezone)\"}]},{\"export\":\"DateTimeZone.SwitchZone\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Changes the timezone of the value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"timezoneHours\",\"type\":\"number\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":86}],\"label\":\"DateTimeZone.SwitchZone(dateTimeZone as nullable datetimezone, timezoneHours as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"timezoneHours\",\"type\":\"number\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":86},{\"documentation\":null,\"label\":\"timezoneMinutes\",\"type\":\"nullable number\",\"signatureLabelOffset\":88,\"signatureLabelEnd\":122}],\"label\":\"DateTimeZone.SwitchZone(dateTimeZone as nullable datetimezone, timezoneHours as number, timezoneMinutes as nullable number)\"}]},{\"export\":\"DateTimeZone.ToLocal\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Converts the timezone component to the local timezone.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":58}],\"label\":\"DateTimeZone.ToLocal(dateTimeZone as nullable datetimezone)\"}]},{\"export\":\"DateTimeZone.ToRecord\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record containing the datetimezone value's parts.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"datetimezone\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":50}],\"label\":\"DateTimeZone.ToRecord(dateTimeZone as datetimezone)\"}]},{\"export\":\"DateTimeZone.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a textual representation of the datetimezone value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":57}],\"label\":\"DateTimeZone.ToText(dateTimeZone as nullable datetimezone)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":82}],\"label\":\"DateTimeZone.ToText(dateTimeZone as nullable datetimezone, format as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":82},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":84,\"signatureLabelEnd\":108}],\"label\":\"DateTimeZone.ToText(dateTimeZone as nullable datetimezone, format as nullable text, culture as nullable text)\"}]},{\"export\":\"DateTimeZone.ToUtc\",\"kind\":\"Function\",\"primitiveType\":\"nullable datetimezone\",\"summary\":\"Converts the timezone component to UTC timezone.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":56}],\"label\":\"DateTimeZone.ToUtc(dateTimeZone as nullable datetimezone)\"}]},{\"export\":\"DateTimeZone.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all date and time values relative to a timezone.\",\"signatures\":null},{\"export\":\"DateTimeZone.UtcNow\",\"kind\":\"Function\",\"primitiveType\":\"datetimezone\",\"summary\":\"Returns the current date and time in UTC (the GMT timezone).\",\"signatures\":[{\"parameters\":[],\"label\":\"DateTimeZone.UtcNow()\"}]},{\"export\":\"DateTimeZone.ZoneHours\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Changes the timezone of the value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":60}],\"label\":\"DateTimeZone.ZoneHours(dateTimeZone as nullable datetimezone)\"}]},{\"export\":\"DateTimeZone.ZoneMinutes\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Changes the timezone of the value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTimeZone\",\"type\":\"nullable datetimezone\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":62}],\"label\":\"DateTimeZone.ZoneMinutes(dateTimeZone as nullable datetimezone)\"}]},{\"export\":\"Day.Friday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Friday.\",\"signatures\":null},{\"export\":\"Day.Monday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Monday.\",\"signatures\":null},{\"export\":\"Day.Saturday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Saturday.\",\"signatures\":null},{\"export\":\"Day.Sunday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Sunday.\",\"signatures\":null},{\"export\":\"Day.Thursday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Thursday.\",\"signatures\":null},{\"export\":\"Day.Tuesday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Tuesday.\",\"signatures\":null},{\"export\":\"Day.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies a day of week.\",\"signatures\":null},{\"export\":\"Day.Wednesday\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Represents Wednesday.\",\"signatures\":null},{\"export\":\"Decimal.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a Decimal from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"Decimal.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":51}],\"label\":\"Decimal.From(value as any, culture as nullable text)\"}]},{\"export\":\"Decimal.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents fixed-point decimal number.\",\"signatures\":null},{\"export\":\"Diagnostics.ActivityId\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns an opaque identifier for the currently-running evaluation.\",\"signatures\":[{\"parameters\":[],\"label\":\"Diagnostics.ActivityId()\"}]},{\"export\":\"Diagnostics.Trace\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Writes a trace entry, if tracing is enabled, and returns the value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"traceLevel\",\"type\":\"number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"message\",\"type\":\"anynonnull\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":75}],\"label\":\"Diagnostics.Trace(traceLevel as number, message as anynonnull, value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"traceLevel\",\"type\":\"number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"message\",\"type\":\"anynonnull\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":75},{\"documentation\":null,\"label\":\"delayed\",\"type\":\"nullable logical\",\"signatureLabelOffset\":77,\"signatureLabelEnd\":104}],\"label\":\"Diagnostics.Trace(traceLevel as number, message as anynonnull, value as any, delayed as nullable logical)\"}]},{\"export\":\"DirectQueryCapabilities.From\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"DirectQueryCapabilities.From\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":41}],\"label\":\"DirectQueryCapabilities.From(value as any)\"}]},{\"export\":\"Double.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a Double from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Double.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":50}],\"label\":\"Double.From(value as any, culture as nullable text)\"}]},{\"export\":\"Double.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents double precision floating point number.\",\"signatures\":null},{\"export\":\"Duration.Days\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the days part of this duration.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":43}],\"label\":\"Duration.Days(duration as nullable duration)\"}]},{\"export\":\"Duration.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable duration\",\"summary\":\"Creates a duration from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Duration.From(value as any)\"}]},{\"export\":\"Duration.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable duration\",\"summary\":\"Returns a duration value from textual elapsed time forms (d.h:m:s).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":39}],\"label\":\"Duration.FromText(text as nullable text)\"}]},{\"export\":\"Duration.Hours\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the hours part of this duration.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":44}],\"label\":\"Duration.Hours(duration as nullable duration)\"}]},{\"export\":\"Duration.Minutes\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the minutes part of this duration.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":46}],\"label\":\"Duration.Minutes(duration as nullable duration)\"}]},{\"export\":\"Duration.Seconds\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the seconds part of this duration.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":46}],\"label\":\"Duration.Seconds(duration as nullable duration)\"}]},{\"export\":\"Duration.ToRecord\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record containing the parts of the duration.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"duration\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":38}],\"label\":\"Duration.ToRecord(duration as duration)\"}]},{\"export\":\"Duration.TotalDays\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the total days this duration spans.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":48}],\"label\":\"Duration.TotalDays(duration as nullable duration)\"}]},{\"export\":\"Duration.TotalHours\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the total hours this duration spans.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":49}],\"label\":\"Duration.TotalHours(duration as nullable duration)\"}]},{\"export\":\"Duration.TotalMinutes\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the total minutes this duration spans.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":51}],\"label\":\"Duration.TotalMinutes(duration as nullable duration)\"}]},{\"export\":\"Duration.TotalSeconds\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the total seconds this duration spans.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":51}],\"label\":\"Duration.TotalSeconds(duration as nullable duration)\"}]},{\"export\":\"Duration.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the text of the form \\\"d.h:m:s\\\".\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":45}],\"label\":\"Duration.ToText(duration as nullable duration)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"duration\",\"type\":\"nullable duration\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":70}],\"label\":\"Duration.ToText(duration as nullable duration, format as nullable text)\"}]},{\"export\":\"Duration.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all duration values\",\"signatures\":null},{\"export\":\"Embedded.Value\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Accesses a value by name in an embedded mashup.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":41}],\"label\":\"Embedded.Value(value as any, path as text)\"}]},{\"export\":\"Error.Record\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns an error record from the provided text values for reason, message and detail.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27}],\"label\":\"Error.Record(reason as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":53}],\"label\":\"Error.Record(reason as text, message as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"detail\",\"type\":\"any\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":68}],\"label\":\"Error.Record(reason as text, message as nullable text, detail as any)\"}]},{\"export\":\"Excel.Workbook\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a record of Sheets from the Excel workbook.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"workbook\",\"type\":\"binary\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":33}],\"label\":\"Excel.Workbook(workbook as binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"workbook\",\"type\":\"binary\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"useHeaders\",\"type\":\"nullable logical\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":65}],\"label\":\"Excel.Workbook(workbook as binary, useHeaders as nullable logical)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"workbook\",\"type\":\"binary\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"useHeaders\",\"type\":\"nullable logical\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"delayTypes\",\"type\":\"nullable logical\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":97}],\"label\":\"Excel.Workbook(workbook as binary, useHeaders as nullable logical, delayTypes as nullable logical)\"}]},{\"export\":\"Expression.Constant\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Returns the M source code representation of a constant value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":32}],\"label\":\"Expression.Constant(value as any)\"}]},{\"export\":\"Expression.Evaluate\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the result of evaluating an M expression.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"document\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36}],\"label\":\"Expression.Evaluate(document as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"document\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"environment\",\"type\":\"nullable record\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":68}],\"label\":\"Expression.Evaluate(document as text, environment as nullable record)\"}]},{\"export\":\"Expression.Identifier\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Returns the M source code representation of an identifier.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"name\",\"type\":\"text\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":34}],\"label\":\"Expression.Identifier(name as text)\"}]},{\"export\":\"ExtraValues.Error\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"If the splitter function returns more columns than the table expects, an error should be raised.\",\"signatures\":null},{\"export\":\"ExtraValues.Ignore\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"If the splitter function returns more columns than the table expects, they should be ignored.\",\"signatures\":null},{\"export\":\"ExtraValues.List\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"If the splitter function returns more columns than the table expects, they should be collected into a list.\",\"signatures\":null},{\"export\":\"ExtraValues.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the expected action for extra values in a row that contains columns more than expected.\",\"signatures\":null},{\"export\":\"Function.From\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Creates a function with a specific parameter signature on top of a function that takes a single list argument\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"functionType\",\"type\":\"type\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":56}],\"label\":\"Function.From(functionType as type, function as function)\"}]},{\"export\":\"Function.Invoke\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Invokes the given function\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"args\",\"type\":\"list\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":50}],\"label\":\"Function.Invoke(function as function, args as list)\"}]},{\"export\":\"Function.InvokeAfter\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Invokes the given function after the specified duration has passed.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"delay\",\"type\":\"duration\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60}],\"label\":\"Function.InvokeAfter(function as function, delay as duration)\"}]},{\"export\":\"Function.IsDataSource\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns whether or not a particular function is considered a data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":42}],\"label\":\"Function.IsDataSource(function as function)\"}]},{\"export\":\"Function.ScalarVector\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Creates a scalar function on top of a vector function, batching multiple invocations.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"scalarFunctionType\",\"type\":\"type\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"vectorFunction\",\"type\":\"function\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":76}],\"label\":\"Function.ScalarVector(scalarFunctionType as type, vectorFunction as function)\"}]},{\"export\":\"Function.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all functions.\",\"signatures\":null},{\"export\":\"GroupKind.Global\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"GroupKind.Global\",\"signatures\":null},{\"export\":\"GroupKind.Local\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"GroupKind.Local\",\"signatures\":null},{\"export\":\"GroupKind.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the kind of grouping.\",\"signatures\":null},{\"export\":\"Guid.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a guid value from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"nullable text\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":32}],\"label\":\"Guid.From(value as nullable text)\"}]},{\"export\":\"Guid.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents a Guid value.\",\"signatures\":null},{\"export\":\"Identity.From\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Creates an identity.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"identityProvider\",\"type\":\"function\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":56}],\"label\":\"Identity.From(identityProvider as function, value as any)\"}]},{\"export\":\"Identity.IsMemberOf\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Determines whether an identity is a member of an identity collection.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"identity\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"collection\",\"type\":\"record\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":60}],\"label\":\"Identity.IsMemberOf(identity as record, collection as record)\"}]},{\"export\":\"Identity.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"An identity represents a user, group, device, or other identifiable thing.\",\"signatures\":null},{\"export\":\"IdentityProvider.Default\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"The default identity provider for the current host.\",\"signatures\":[{\"parameters\":[],\"label\":\"IdentityProvider.Default()\"}]},{\"export\":\"IdentityProvider.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Defines a scope in which identities are created and compared.\",\"signatures\":null},{\"export\":\"Int16.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a 16-bit integer from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"Int16.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49}],\"label\":\"Int16.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":82}],\"label\":\"Int16.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Int16.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents signed 16 bit integer.\",\"signatures\":null},{\"export\":\"Int32.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a 32-bit integer from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"Int32.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49}],\"label\":\"Int32.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":82}],\"label\":\"Int32.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Int32.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents signed 32 bit integer.\",\"signatures\":null},{\"export\":\"Int64.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a 64-bit integer from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"Int64.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49}],\"label\":\"Int64.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":82}],\"label\":\"Int64.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Int64.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents signed 64 bit integer.\",\"signatures\":null},{\"export\":\"Int8.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a signed 8-bit integer from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"Int8.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48}],\"label\":\"Int8.From(value as any, culture as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":81}],\"label\":\"Int8.From(value as any, culture as nullable text, roundingMode as nullable number)\"}]},{\"export\":\"Int8.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents signed 8 bit integer.\",\"signatures\":null},{\"export\":\"ItemExpression.From\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the AST for the body of a function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":40}],\"label\":\"ItemExpression.From(function as function)\"}]},{\"export\":\"ItemExpression.Item\",\"kind\":\"Constant\",\"primitiveType\":\"record\",\"summary\":\"An AST node representing the item in an item expression.\",\"signatures\":null},{\"export\":\"JoinAlgorithm.Dynamic\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.Dynamic\",\"signatures\":null},{\"export\":\"JoinAlgorithm.LeftHash\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.LeftHash\",\"signatures\":null},{\"export\":\"JoinAlgorithm.LeftIndex\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.LeftIndex\",\"signatures\":null},{\"export\":\"JoinAlgorithm.PairwiseHash\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.PairwiseHash\",\"signatures\":null},{\"export\":\"JoinAlgorithm.RightHash\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.RightHash\",\"signatures\":null},{\"export\":\"JoinAlgorithm.RightIndex\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.RightIndex\",\"signatures\":null},{\"export\":\"JoinAlgorithm.SortMerge\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"JoinAlgorithm.SortMerge\",\"signatures\":null},{\"export\":\"JoinAlgorithm.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the join algorithm to be used in the join operation.\",\"signatures\":null},{\"export\":\"JoinKind.FullOuter\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    A full outer join ensures that all rows of both tables appear in the result. Rows that did not have a match in the other table are joined with a default row containing null values for all of its columns.\",\"signatures\":null},{\"export\":\"JoinKind.Inner\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    The table resulting from an inner join contains a row for each pair of rows from the specified tables that were determined to match based on the specified key columns.\",\"signatures\":null},{\"export\":\"JoinKind.LeftAnti\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    A left anti join returns that all rows from the first table which do not have a match in the second table.\",\"signatures\":null},{\"export\":\"JoinKind.LeftOuter\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    A left outer join ensures that all rows of the first table appear in the result.\",\"signatures\":null},{\"export\":\"JoinKind.RightAnti\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    A right anti join returns that all rows from the second table which do not have a match in the first table.\",\"signatures\":null},{\"export\":\"JoinKind.RightOuter\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A possible value for the optional <code>JoinKind</code> parameter in <code>Table.Join</code>.\\r\\n    A right outer join ensures that all rows of the second table appear in the result.\",\"signatures\":null},{\"export\":\"JoinKind.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the kind of join operation.\",\"signatures\":null},{\"export\":\"JoinSide.Left\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies the left table of a join.\",\"signatures\":null},{\"export\":\"JoinSide.Right\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies the right table of a join.\",\"signatures\":null},{\"export\":\"JoinSide.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the left or right table of a join.\",\"signatures\":null},{\"export\":\"Json.Document\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the content of the JSON document.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"jsonText\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29}],\"label\":\"Json.Document(jsonText as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"jsonText\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":58}],\"label\":\"Json.Document(jsonText as any, encoding as nullable number)\"}]},{\"export\":\"Json.FromValue\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Produces a JSON representation of a given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"Json.FromValue(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":56}],\"label\":\"Json.FromValue(value as any, encoding as nullable number)\"}]},{\"export\":\"Lines.FromBinary\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Converts a binary value to a list of text values split at lines breaks.  If a quote style is specified, then line breaks may appear within quotes.  If includeLineSeparators is true, then the line break characters are included in the text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33}],\"label\":\"Lines.FromBinary(binary as binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":64}],\"label\":\"Lines.FromBinary(binary as binary, quoteStyle as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"includeLineSeparators\",\"type\":\"nullable logical\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":107}],\"label\":\"Lines.FromBinary(binary as binary, quoteStyle as nullable number, includeLineSeparators as nullable logical)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"includeLineSeparators\",\"type\":\"nullable logical\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":107},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":109,\"signatureLabelEnd\":136}],\"label\":\"Lines.FromBinary(binary as binary, quoteStyle as nullable number, includeLineSeparators as nullable logical, encoding as nullable number)\"}]},{\"export\":\"Lines.FromText\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Converts a text value to a list of text values split at lines breaks. If includeLineSeparators is true, then the line break characters are included in the text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"Lines.FromText(text as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58}],\"label\":\"Lines.FromText(text as text, quoteStyle as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"includeLineSeparators\",\"type\":\"nullable logical\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":101}],\"label\":\"Lines.FromText(text as text, quoteStyle as nullable number, includeLineSeparators as nullable logical)\"}]},{\"export\":\"Lines.ToBinary\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Converts a list of text into a binary value using the specified encoding and lineSeparator.The specified lineSeparator is appended to each line.  If not specified then the carriage return and line feed characters are used.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28}],\"label\":\"Lines.ToBinary(lines as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"lineSeparator\",\"type\":\"nullable text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":60}],\"label\":\"Lines.ToBinary(lines as list, lineSeparator as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"lineSeparator\",\"type\":\"nullable text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":89}],\"label\":\"Lines.ToBinary(lines as list, lineSeparator as nullable text, encoding as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"lineSeparator\",\"type\":\"nullable text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":89},{\"documentation\":null,\"label\":\"includeByteOrderMark\",\"type\":\"nullable logical\",\"signatureLabelOffset\":91,\"signatureLabelEnd\":131}],\"label\":\"Lines.ToBinary(lines as list, lineSeparator as nullable text, encoding as nullable number, includeByteOrderMark as nullable logical)\"}]},{\"export\":\"Lines.ToText\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Converts a list of text into a single text.  The specified lineSeparator is appended to each line.  If not specified then the carriage return and line feed characters are used.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26}],\"label\":\"Lines.ToText(lines as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lines\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"lineSeparator\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":58}],\"label\":\"Lines.ToText(lines as list, lineSeparator as nullable text)\"}]},{\"export\":\"List.Accumulate\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Accumulates a summary value from the items in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"seed\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"accumulator\",\"type\":\"function\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":66}],\"label\":\"List.Accumulate(list as list, seed as any, accumulator as function)\"}]},{\"export\":\"List.AllTrue\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if all expressions are true.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"List.AllTrue(list as list)\"}]},{\"export\":\"List.Alternate\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list comprised of all the odd numbered offset elements in a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44}],\"label\":\"List.Alternate(list as list, count as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"repeatInterval\",\"type\":\"nullable number\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":79}],\"label\":\"List.Alternate(list as list, count as number, repeatInterval as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"repeatInterval\",\"type\":\"nullable number\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":79},{\"documentation\":null,\"label\":\"offset\",\"type\":\"nullable number\",\"signatureLabelOffset\":81,\"signatureLabelEnd\":106}],\"label\":\"List.Alternate(list as list, count as number, repeatInterval as nullable number, offset as nullable number)\"}]},{\"export\":\"List.AnyTrue\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if any expression is true.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"List.AnyTrue(list as list)\"}]},{\"export\":\"List.Average\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the average of the values. Works with number, date, datetime, datetimezone and duration values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"List.Average(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":55}],\"label\":\"List.Average(list as list, precision as nullable number)\"}]},{\"export\":\"List.Buffer\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Buffers a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"List.Buffer(list as list)\"}]},{\"export\":\"List.Combine\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a single list by combining multiple lists.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26}],\"label\":\"List.Combine(lists as list)\"}]},{\"export\":\"List.Contains\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether the list contains the value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":40}],\"label\":\"List.Contains(list as list, value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":65}],\"label\":\"List.Contains(list as list, value as any, equationCriteria as any)\"}]},{\"export\":\"List.ContainsAll\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates where a list includes all the values in another list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":45}],\"label\":\"List.ContainsAll(list as list, values as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":70}],\"label\":\"List.ContainsAll(list as list, values as list, equationCriteria as any)\"}]},{\"export\":\"List.ContainsAny\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates where a list includes any of the values in another list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":45}],\"label\":\"List.ContainsAny(list as list, values as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":70}],\"label\":\"List.ContainsAny(list as list, values as list, equationCriteria as any)\"}]},{\"export\":\"List.Count\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns the number of items in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"List.Count(list as list)\"}]},{\"export\":\"List.Covariance\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the covariance between the two lists of numbers.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"numberList1\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"numberList2\",\"type\":\"list\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":56}],\"label\":\"List.Covariance(numberList1 as list, numberList2 as list)\"}]},{\"export\":\"List.Dates\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list of date values given an initial value, count, and incremental duration value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"date\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"step\",\"type\":\"duration\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":59}],\"label\":\"List.Dates(start as date, count as number, step as duration)\"}]},{\"export\":\"List.DateTimes\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list of datetime values given an initial value, count, and incremental duration value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"datetime\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"step\",\"type\":\"duration\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":67}],\"label\":\"List.DateTimes(start as datetime, count as number, step as duration)\"}]},{\"export\":\"List.DateTimeZones\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list of datetimezone values given an initial value, count, and incremental duration value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"datetimezone\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"step\",\"type\":\"duration\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":75}],\"label\":\"List.DateTimeZones(start as datetimezone, count as number, step as duration)\"}]},{\"export\":\"List.Difference\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the difference of the two given lists.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list1\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"list2\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":44}],\"label\":\"List.Difference(list1 as list, list2 as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list1\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"list2\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":69}],\"label\":\"List.Difference(list1 as list, list2 as list, equationCriteria as any)\"}]},{\"export\":\"List.Distinct\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of values with duplicates removed.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"List.Distinct(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":51}],\"label\":\"List.Distinct(list as list, equationCriteria as any)\"}]},{\"export\":\"List.Durations\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list of duration values given an initial value, count, and incremental duration value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"duration\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"step\",\"type\":\"duration\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":67}],\"label\":\"List.Durations(start as duration, count as number, step as duration)\"}]},{\"export\":\"List.FindText\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of values (including record fields) that contain the specified text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":40}],\"label\":\"List.FindText(list as list, text as text)\"}]},{\"export\":\"List.First\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the list or the specified default if empty.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"List.First(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"defaultValue\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":44}],\"label\":\"List.First(list as list, defaultValue as any)\"}]},{\"export\":\"List.FirstN\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first set of items in the list by specifying how many items to return or a qualifying condition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":49}],\"label\":\"List.FirstN(list as list, countOrCondition as any)\"}]},{\"export\":\"List.Generate\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list given an initial value function, a condition function, a next function, and an optional transformation function on the values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"initial\",\"type\":\"function\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"next\",\"type\":\"function\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":74}],\"label\":\"List.Generate(initial as function, condition as function, next as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"initial\",\"type\":\"function\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"next\",\"type\":\"function\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"selector\",\"type\":\"nullable function\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":105}],\"label\":\"List.Generate(initial as function, condition as function, next as function, selector as nullable function)\"}]},{\"export\":\"List.InsertRange\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Inserts values into a list at the given index.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"index\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":62}],\"label\":\"List.InsertRange(list as list, index as number, values as list)\"}]},{\"export\":\"List.Intersect\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the intersection of the list values found in the input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28}],\"label\":\"List.Intersect(lists as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":53}],\"label\":\"List.Intersect(lists as list, equationCriteria as any)\"}]},{\"export\":\"List.IsDistinct\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether there are duplicates in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"List.IsDistinct(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":53}],\"label\":\"List.IsDistinct(list as list, equationCriteria as any)\"}]},{\"export\":\"List.IsEmpty\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if the list is empty.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"List.IsEmpty(list as list)\"}]},{\"export\":\"List.Last\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last value of the list or the specified default if empty.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"List.Last(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"defaultValue\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":43}],\"label\":\"List.Last(list as list, defaultValue as any)\"}]},{\"export\":\"List.LastN\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last value in the list.  Can optionally specify how many values to return or a qualifying condition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"List.LastN(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":48}],\"label\":\"List.LastN(list as list, countOrCondition as any)\"}]},{\"export\":\"List.MatchesAll\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if the condition function is satisfied by all values in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":51}],\"label\":\"List.MatchesAll(list as list, condition as function)\"}]},{\"export\":\"List.MatchesAny\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if the condition function is satisfied by any value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":51}],\"label\":\"List.MatchesAny(list as list, condition as function)\"}]},{\"export\":\"List.Max\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the maximum value or the default value for an empty list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21}],\"label\":\"List.Max(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37}],\"label\":\"List.Max(list as list, default as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":64}],\"label\":\"List.Max(list as list, default as any, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"includeNulls\",\"type\":\"nullable logical\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":98}],\"label\":\"List.Max(list as list, default as any, comparisonCriteria as any, includeNulls as nullable logical)\"}]},{\"export\":\"List.MaxN\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the maximum value(s) in the list. The number of values to return or filtering condition must be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47}],\"label\":\"List.MaxN(list as list, countOrCondition as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":74}],\"label\":\"List.MaxN(list as list, countOrCondition as any, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"includeNulls\",\"type\":\"nullable logical\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":108}],\"label\":\"List.MaxN(list as list, countOrCondition as any, comparisonCriteria as any, includeNulls as nullable logical)\"}]},{\"export\":\"List.Median\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the median value in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"List.Median(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":51}],\"label\":\"List.Median(list as list, comparisonCriteria as any)\"}]},{\"export\":\"List.Min\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the minimum value or the default value for an empty list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21}],\"label\":\"List.Min(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37}],\"label\":\"List.Min(list as list, default as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":64}],\"label\":\"List.Min(list as list, default as any, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"includeNulls\",\"type\":\"nullable logical\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":98}],\"label\":\"List.Min(list as list, default as any, comparisonCriteria as any, includeNulls as nullable logical)\"}]},{\"export\":\"List.MinN\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the minimum value(s) in the list. The number of values to return or filtering condition may be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47}],\"label\":\"List.MinN(list as list, countOrCondition as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":74}],\"label\":\"List.MinN(list as list, countOrCondition as any, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"includeNulls\",\"type\":\"nullable logical\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":108}],\"label\":\"List.MinN(list as list, countOrCondition as any, comparisonCriteria as any, includeNulls as nullable logical)\"}]},{\"export\":\"List.Mode\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the most frequent value in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"List.Mode(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47}],\"label\":\"List.Mode(list as list, equationCriteria as any)\"}]},{\"export\":\"List.Modes\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of the most frequent values in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"List.Modes(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":48}],\"label\":\"List.Modes(list as list, equationCriteria as any)\"}]},{\"export\":\"List.NonNullCount\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns the number of non-null items in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"List.NonNullCount(list as list)\"}]},{\"export\":\"List.Numbers\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of numbers given an initial value, count, and optional increment value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45}],\"label\":\"List.Numbers(start as number, count as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"increment\",\"type\":\"nullable number\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":75}],\"label\":\"List.Numbers(start as number, count as number, increment as nullable number)\"}]},{\"export\":\"List.PositionOf\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the offset(s) of a value in a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":42}],\"label\":\"List.PositionOf(list as list, value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":73}],\"label\":\"List.PositionOf(list as list, value as any, occurrence as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":98}],\"label\":\"List.PositionOf(list as list, value as any, occurrence as nullable number, equationCriteria as any)\"}]},{\"export\":\"List.PositionOfAny\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first offset of a value in a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47}],\"label\":\"List.PositionOfAny(list as list, values as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":78}],\"label\":\"List.PositionOfAny(list as list, values as list, occurrence as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"values\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":78},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":80,\"signatureLabelEnd\":103}],\"label\":\"List.PositionOfAny(list as list, values as list, occurrence as nullable number, equationCriteria as any)\"}]},{\"export\":\"List.Positions\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of offsets for the input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"List.Positions(list as list)\"}]},{\"export\":\"List.Product\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the product of the numbers in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"numbersList\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":32}],\"label\":\"List.Product(numbersList as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"numbersList\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":62}],\"label\":\"List.Product(numbersList as list, precision as nullable number)\"}]},{\"export\":\"List.Random\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of random numbers.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":27}],\"label\":\"List.Random(count as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"seed\",\"type\":\"nullable number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":52}],\"label\":\"List.Random(count as number, seed as nullable number)\"}]},{\"export\":\"List.Range\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a subset of the list beginning at an offset.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":41}],\"label\":\"List.Range(list as list, offset as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":67}],\"label\":\"List.Range(list as list, offset as number, count as nullable number)\"}]},{\"export\":\"List.RemoveFirstN\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list that skips the specified number of elements at the beginning of the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"List.RemoveFirstN(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":55}],\"label\":\"List.RemoveFirstN(list as list, countOrCondition as any)\"}]},{\"export\":\"List.RemoveItems\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Removes items from list1 that are present in list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list1\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"list2\",\"type\":\"list\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":45}],\"label\":\"List.RemoveItems(list1 as list, list2 as list)\"}]},{\"export\":\"List.RemoveLastN\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list that removes the specified number of elements from the end of the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29}],\"label\":\"List.RemoveLastN(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":54}],\"label\":\"List.RemoveLastN(list as list, countOrCondition as any)\"}]},{\"export\":\"List.RemoveMatchingItems\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Removes all occurrences of the input values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list1\",\"type\":\"list\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"list2\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":53}],\"label\":\"List.RemoveMatchingItems(list1 as list, list2 as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list1\",\"type\":\"list\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"list2\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":78}],\"label\":\"List.RemoveMatchingItems(list1 as list, list2 as list, equationCriteria as any)\"}]},{\"export\":\"List.RemoveNulls\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Removes all \\\"null\\\" values from the specified list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29}],\"label\":\"List.RemoveNulls(list as list)\"}]},{\"export\":\"List.RemoveRange\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Removes count number of values starting at the specified position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"index\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":46}],\"label\":\"List.RemoveRange(list as list, index as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"index\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":72}],\"label\":\"List.RemoveRange(list as list, index as number, count as nullable number)\"}]},{\"export\":\"List.Repeat\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list that is count repetitions of the original list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41}],\"label\":\"List.Repeat(list as list, count as number)\"}]},{\"export\":\"List.ReplaceMatchingItems\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Applies each replacement of { old, new }.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"replacements\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":60}],\"label\":\"List.ReplaceMatchingItems(list as list, replacements as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"replacements\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":85}],\"label\":\"List.ReplaceMatchingItems(list as list, replacements as list, equationCriteria as any)\"}]},{\"export\":\"List.ReplaceRange\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Replaces count number of values starting at position with the replacement values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"index\",\"type\":\"number\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"replaceWith\",\"type\":\"list\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":85}],\"label\":\"List.ReplaceRange(list as list, index as number, count as number, replaceWith as list)\"}]},{\"export\":\"List.ReplaceValue\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Searches a list for the specified value and replaces it.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"oldValue\",\"type\":\"any\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"newValue\",\"type\":\"any\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"replacer\",\"type\":\"function\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":86}],\"label\":\"List.ReplaceValue(list as list, oldValue as any, newValue as any, replacer as function)\"}]},{\"export\":\"List.Reverse\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Reverses the order of values in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"List.Reverse(list as list)\"}]},{\"export\":\"List.Select\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of values that match the condition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"selection\",\"type\":\"function\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":47}],\"label\":\"List.Select(list as list, selection as function)\"}]},{\"export\":\"List.Single\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the one list item for a list of length one, otherwise throws an exception.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"List.Single(list as list)\"}]},{\"export\":\"List.SingleOrDefault\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the one list item for a list of length one and the default value for an empty list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33}],\"label\":\"List.SingleOrDefault(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":49}],\"label\":\"List.SingleOrDefault(list as list, default as any)\"}]},{\"export\":\"List.Skip\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list that skips the specified number of elements at the beginning of the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"List.Skip(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":47}],\"label\":\"List.Skip(list as list, countOrCondition as any)\"}]},{\"export\":\"List.Sort\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Sorts a list of data according to the criteria specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"List.Sort(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":49}],\"label\":\"List.Sort(list as list, comparisonCriteria as any)\"}]},{\"export\":\"List.Split\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Splits the specified list into a list of lists using the specified page size.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"pageSize\",\"type\":\"number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":43}],\"label\":\"List.Split(list as list, pageSize as number)\"}]},{\"export\":\"List.StandardDeviation\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a sample based estimate of the standard deviation.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"numbersList\",\"type\":\"list\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":42}],\"label\":\"List.StandardDeviation(numbersList as list)\"}]},{\"export\":\"List.Sum\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the sum of the items in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21}],\"label\":\"List.Sum(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":51}],\"label\":\"List.Sum(list as list, precision as nullable number)\"}]},{\"export\":\"List.Times\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Generates a list of time values given an initial value, count, and incremental duration value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"start\",\"type\":\"time\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"step\",\"type\":\"duration\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":59}],\"label\":\"List.Times(start as time, count as number, step as duration)\"}]},{\"export\":\"List.Transform\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a new list of values computed from this list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"transform\",\"type\":\"function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":50}],\"label\":\"List.Transform(list as list, transform as function)\"}]},{\"export\":\"List.TransformMany\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list whose elements are transformed from the input list using specified functions.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"collectionTransform\",\"type\":\"function\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"resultTransform\",\"type\":\"function\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":93}],\"label\":\"List.TransformMany(list as list, collectionTransform as function, resultTransform as function)\"}]},{\"export\":\"List.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all lists.\",\"signatures\":null},{\"export\":\"List.Union\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the union of the list values found in the input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":24}],\"label\":\"List.Union(lists as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":49}],\"label\":\"List.Union(lists as list, equationCriteria as any)\"}]},{\"export\":\"List.Zip\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of lists by combining items at the same position in multiple lists.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":22}],\"label\":\"List.Zip(lists as list)\"}]},{\"export\":\"Logical.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Creates a logical from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"Logical.From(value as any)\"}]},{\"export\":\"Logical.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Creates a logical value from the text values \\\"true\\\" and \\\"false\\\".\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":38}],\"label\":\"Logical.FromText(text as nullable text)\"}]},{\"export\":\"Logical.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the text \\\"true\\\" or \\\"false\\\" given a logical value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"logicalValue\",\"type\":\"nullable logical\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":47}],\"label\":\"Logical.ToText(logicalValue as nullable logical)\"}]},{\"export\":\"Logical.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all logical values.\",\"signatures\":null},{\"export\":\"MissingField.Error\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"An optional parameter in record and table functions indicating that missing fields should result in an error. (This is the default parameter value.)\",\"signatures\":null},{\"export\":\"MissingField.Ignore\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"An optional parameter in record and table functions indicating that missing fields should be ignored.\",\"signatures\":null},{\"export\":\"MissingField.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the expected action for missing values in a row that contains columns less than expected.\",\"signatures\":null},{\"export\":\"MissingField.UseNull\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"An optional parameter in record and table functions indicating that missing fields should be included as null values.\",\"signatures\":null},{\"export\":\"None.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"None.Type\",\"signatures\":null},{\"export\":\"Null.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents null.\",\"signatures\":null},{\"export\":\"Number.Abs\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the absolute value of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Abs(number as nullable number)\"}]},{\"export\":\"Number.Acos\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the arccosine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Acos(number as nullable number)\"}]},{\"export\":\"Number.Asin\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the arcsine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Asin(number as nullable number)\"}]},{\"export\":\"Number.Atan\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the arctangent of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Atan(number as nullable number)\"}]},{\"export\":\"Number.Atan2\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the arctangent of the division of the two numbers.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"y\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"x\",\"type\":\"nullable number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":55}],\"label\":\"Number.Atan2(y as nullable number, x as nullable number)\"}]},{\"export\":\"Number.BitwiseAnd\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the result of performing a bitwise \\\"And\\\" operation between the two inputs.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72}],\"label\":\"Number.BitwiseAnd(number1 as nullable number, number2 as nullable number)\"}]},{\"export\":\"Number.BitwiseNot\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a byte where each bit is the opposite of the input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31}],\"label\":\"Number.BitwiseNot(number as any)\"}]},{\"export\":\"Number.BitwiseOr\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the result of performing a bitwise \\\"Or\\\" between the two inputs.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":71}],\"label\":\"Number.BitwiseOr(number1 as nullable number, number2 as nullable number)\"}]},{\"export\":\"Number.BitwiseShiftLeft\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Shifts the bits set to the left.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":78}],\"label\":\"Number.BitwiseShiftLeft(number1 as nullable number, number2 as nullable number)\"}]},{\"export\":\"Number.BitwiseShiftRight\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Shifts the bits set to the right.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":79}],\"label\":\"Number.BitwiseShiftRight(number1 as nullable number, number2 as nullable number)\"}]},{\"export\":\"Number.BitwiseXor\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the result of performing a bitwise \\\"XOR\\\" (Exclusive-OR) between the two inputs.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72}],\"label\":\"Number.BitwiseXor(number1 as nullable number, number2 as nullable number)\"}]},{\"export\":\"Number.Combinations\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the number of unique combinations.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"setSize\",\"type\":\"nullable number\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"combinationSize\",\"type\":\"nullable number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":82}],\"label\":\"Number.Combinations(setSize as nullable number, combinationSize as nullable number)\"}]},{\"export\":\"Number.Cos\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the cosine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Cos(number as nullable number)\"}]},{\"export\":\"Number.Cosh\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the hyperbolic cosine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Cosh(number as nullable number)\"}]},{\"export\":\"Number.E\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant value that represents e.\",\"signatures\":null},{\"export\":\"Number.Epsilon\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant value that represents the smallest positive number a floating-point number can hold.\",\"signatures\":null},{\"export\":\"Number.Exp\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Raises e to the given power.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Exp(number as nullable number)\"}]},{\"export\":\"Number.Factorial\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the factorial of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":42}],\"label\":\"Number.Factorial(number as nullable number)\"}]},{\"export\":\"Number.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a number from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Number.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":50}],\"label\":\"Number.From(value as any, culture as nullable text)\"}]},{\"export\":\"Number.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates numbers from common text formats (\\\"15\\\", \\\"3,423.10\\\", \\\"5.0E-10\\\").\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37}],\"label\":\"Number.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":63}],\"label\":\"Number.FromText(text as nullable text, culture as nullable text)\"}]},{\"export\":\"Number.IntegerDivide\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Divides two numbers and returns the integer portion of the result.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":75}],\"label\":\"Number.IntegerDivide(number1 as nullable number, number2 as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number1\",\"type\":\"nullable number\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"number2\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":75},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":77,\"signatureLabelEnd\":105}],\"label\":\"Number.IntegerDivide(number1 as nullable number, number2 as nullable number, precision as nullable number)\"}]},{\"export\":\"Number.IsEven\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates if the value is even.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"number\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":30}],\"label\":\"Number.IsEven(number as number)\"}]},{\"export\":\"Number.IsNaN\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates if the value is NaN (Not a number).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":29}],\"label\":\"Number.IsNaN(number as number)\"}]},{\"export\":\"Number.IsOdd\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates if the value is odd.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":29}],\"label\":\"Number.IsOdd(number as number)\"}]},{\"export\":\"Number.Ln\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the natural logarithm of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":35}],\"label\":\"Number.Ln(number as nullable number)\"}]},{\"export\":\"Number.Log\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the logarithm of the number to the specified base (default e).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Log(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"base\",\"type\":\"nullable number\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":61}],\"label\":\"Number.Log(number as nullable number, base as nullable number)\"}]},{\"export\":\"Number.Log10\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the base 10 logarithm of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":38}],\"label\":\"Number.Log10(number as nullable number)\"}]},{\"export\":\"Number.Mod\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Integer divides two numbers and returns the remainder.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"divisor\",\"type\":\"nullable number\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":64}],\"label\":\"Number.Mod(number as nullable number, divisor as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"divisor\",\"type\":\"nullable number\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":94}],\"label\":\"Number.Mod(number as nullable number, divisor as nullable number, precision as nullable number)\"}]},{\"export\":\"Number.NaN\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant value that represents  0 divided by 0.\",\"signatures\":null},{\"export\":\"Number.NegativeInfinity\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant value that represents -1 divided by 0.\",\"signatures\":null},{\"export\":\"Number.Permutations\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the number of permutations.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"setSize\",\"type\":\"nullable number\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"permutationSize\",\"type\":\"nullable number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":82}],\"label\":\"Number.Permutations(setSize as nullable number, permutationSize as nullable number)\"}]},{\"export\":\"Number.PI\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant that represents pi.\",\"signatures\":null},{\"export\":\"Number.PositiveInfinity\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A constant value that represents 1 divided by 0.\",\"signatures\":null},{\"export\":\"Number.Power\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Raises a number to the given power.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"power\",\"type\":\"nullable number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":64}],\"label\":\"Number.Power(number as nullable number, power as nullable number)\"}]},{\"export\":\"Number.Random\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns a random number.\",\"signatures\":[{\"parameters\":[],\"label\":\"Number.Random()\"}]},{\"export\":\"Number.RandomBetween\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns a random number between two numbers.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"bottom\",\"type\":\"number\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"top\",\"type\":\"number\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":52}],\"label\":\"Number.RandomBetween(bottom as number, top as number)\"}]},{\"export\":\"Number.Round\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the rounded number. The number of digits and rounding mode can be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":38}],\"label\":\"Number.Round(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":65}],\"label\":\"Number.Round(number as nullable number, digits as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"roundingMode\",\"type\":\"nullable number\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":98}],\"label\":\"Number.Round(number as nullable number, digits as nullable number, roundingMode as nullable number)\"}]},{\"export\":\"Number.RoundAwayFromZero\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the result of rounding positive numbers up and negative numbers down. The number of digits can be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":50}],\"label\":\"Number.RoundAwayFromZero(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":77}],\"label\":\"Number.RoundAwayFromZero(number as nullable number, digits as nullable number)\"}]},{\"export\":\"Number.RoundDown\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the highest previous number. The number of digits can be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":42}],\"label\":\"Number.RoundDown(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":69}],\"label\":\"Number.RoundDown(number as nullable number, digits as nullable number)\"}]},{\"export\":\"Number.RoundTowardZero\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the result of rounding positive numbers down and negative numbers up. The number of digits can be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":48}],\"label\":\"Number.RoundTowardZero(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":75}],\"label\":\"Number.RoundTowardZero(number as nullable number, digits as nullable number)\"}]},{\"export\":\"Number.RoundUp\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the next highest number. The number of digits can be specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":40}],\"label\":\"Number.RoundUp(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"digits\",\"type\":\"nullable number\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":67}],\"label\":\"Number.RoundUp(number as nullable number, digits as nullable number)\"}]},{\"export\":\"Number.Sign\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns 1 if the number is positive, -1 if it is negative, and 0 if it is zero.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Sign(number as nullable number)\"}]},{\"export\":\"Number.Sin\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the sine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Sin(number as nullable number)\"}]},{\"export\":\"Number.Sinh\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the hyperbolic sine of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Sinh(number as nullable number)\"}]},{\"export\":\"Number.Sqrt\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the square root of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Sqrt(number as nullable number)\"}]},{\"export\":\"Number.Tan\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the tangent of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":36}],\"label\":\"Number.Tan(number as nullable number)\"}]},{\"export\":\"Number.Tanh\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the hyperbolic tangent of the number.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":37}],\"label\":\"Number.Tanh(number as nullable number)\"}]},{\"export\":\"Number.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Formats the given number as text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39}],\"label\":\"Number.ToText(number as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":64}],\"label\":\"Number.ToText(number as nullable number, format as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"number\",\"type\":\"nullable number\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":90}],\"label\":\"Number.ToText(number as nullable number, format as nullable text, culture as nullable text)\"}]},{\"export\":\"Number.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all numbers.\",\"signatures\":null},{\"export\":\"Occurrence.All\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"A list of positions of all occurrences of the found values is returned.\",\"signatures\":null},{\"export\":\"Occurrence.First\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The position of the first occurrence of the found value is returned.\",\"signatures\":null},{\"export\":\"Occurrence.Last\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The position of the last occurrence of the found value is returned.\",\"signatures\":null},{\"export\":\"Occurrence.Optional\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear zero or one time in the input.\",\"signatures\":null},{\"export\":\"Occurrence.Repeating\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear zero or more times in the input.\",\"signatures\":null},{\"export\":\"Occurrence.Required\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"The item is expected to appear once in the input.\",\"signatures\":null},{\"export\":\"Occurrence.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the occurrence of an element in a sequence.\",\"signatures\":null},{\"export\":\"Order.Ascending\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Function type which sorts the list in ascending order.\",\"signatures\":null},{\"export\":\"Order.Descending\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Function type which sorts the list in descending order.\",\"signatures\":null},{\"export\":\"Order.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the direction of sorting.\",\"signatures\":null},{\"export\":\"Password.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents a text password.\",\"signatures\":null},{\"export\":\"Percentage.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns a percentage value from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Percentage.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":54}],\"label\":\"Percentage.From(value as any, culture as nullable text)\"}]},{\"export\":\"Percentage.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents percentage value.\",\"signatures\":null},{\"export\":\"Precision.Decimal\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"An optional parameter for the built-in arthimetic operators to specify decimal precision.\",\"signatures\":null},{\"export\":\"Precision.Double\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"An optional parameter for the built-in arthimetic operators to specify double precision.\",\"signatures\":null},{\"export\":\"Precision.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the precision of comparison.\",\"signatures\":null},{\"export\":\"QuoteStyle.Csv\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Quote characters indicate the start of a quoted string.  Nested quotes are indicated by two quote characters.\",\"signatures\":null},{\"export\":\"QuoteStyle.None\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Quote characters have no significance.\",\"signatures\":null},{\"export\":\"QuoteStyle.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the quote style.\",\"signatures\":null},{\"export\":\"RData.FromBinary\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a record of data frames from the RData file.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"stream\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33}],\"label\":\"RData.FromBinary(stream as binary)\"}]},{\"export\":\"Record.AddField\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Adds a field to a record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"fieldName\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":65}],\"label\":\"Record.AddField(record as record, fieldName as text, value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"fieldName\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"delayed\",\"type\":\"nullable logical\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":94}],\"label\":\"Record.AddField(record as record, fieldName as text, value as any, delayed as nullable logical)\"}]},{\"export\":\"Record.Combine\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Combines the records in the given list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"records\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Record.Combine(records as list)\"}]},{\"export\":\"Record.Field\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the value of the specified field in a record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"field\",\"type\":\"text\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":44}],\"label\":\"Record.Field(record as record, field as text)\"}]},{\"export\":\"Record.FieldCount\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns the number of fields in the record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":34}],\"label\":\"Record.FieldCount(record as record)\"}]},{\"export\":\"Record.FieldNames\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the names of the fields.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":34}],\"label\":\"Record.FieldNames(record as record)\"}]},{\"export\":\"Record.FieldOrDefault\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the value of the specified field in a record or the default value if the field is not found.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"nullable record\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"field\",\"type\":\"text\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":62}],\"label\":\"Record.FieldOrDefault(record as nullable record, field as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"nullable record\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"field\",\"type\":\"text\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":62},{\"documentation\":null,\"label\":\"defaultValue\",\"type\":\"any\",\"signatureLabelOffset\":64,\"signatureLabelEnd\":83}],\"label\":\"Record.FieldOrDefault(record as nullable record, field as text, defaultValue as any)\"}]},{\"export\":\"Record.FieldValues\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of the field values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":35}],\"label\":\"Record.FieldValues(record as record)\"}]},{\"export\":\"Record.FromList\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record given a list of field values and a set of fields.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43}],\"label\":\"Record.FromList(list as list, fields as any)\"}]},{\"export\":\"Record.FromTable\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Creates a record from a table of the form {[Name = name, Value = value]}.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31}],\"label\":\"Record.FromTable(table as table)\"}]},{\"export\":\"Record.HasFields\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether the record has the specified fields.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":48}],\"label\":\"Record.HasFields(record as record, fields as any)\"}]},{\"export\":\"Record.RemoveFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Removes the specified field(s) from the input record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":51}],\"label\":\"Record.RemoveFields(record as record, fields as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":84}],\"label\":\"Record.RemoveFields(record as record, fields as any, missingField as nullable number)\"}]},{\"export\":\"Record.RenameFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Applies rename(s) from a list in the form { old, new }.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"renames\",\"type\":\"list\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":53}],\"label\":\"Record.RenameFields(record as record, renames as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"renames\",\"type\":\"list\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":86}],\"label\":\"Record.RenameFields(record as record, renames as list, missingField as nullable number)\"}]},{\"export\":\"Record.ReorderFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Reorders the field(s) specified into the new order.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"fieldOrder\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":57}],\"label\":\"Record.ReorderFields(record as record, fieldOrder as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"fieldOrder\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":90}],\"label\":\"Record.ReorderFields(record as record, fieldOrder as list, missingField as nullable number)\"}]},{\"export\":\"Record.SelectFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record that contains only the specified fields.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":51}],\"label\":\"Record.SelectFields(record as record, fields as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"fields\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":84}],\"label\":\"Record.SelectFields(record as record, fields as any, missingField as nullable number)\"}]},{\"export\":\"Record.ToList\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of values containing the field values of the input record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":30}],\"label\":\"Record.ToList(record as record)\"}]},{\"export\":\"Record.ToTable\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with each row being a field name and value of the input record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":31}],\"label\":\"Record.ToTable(record as record)\"}]},{\"export\":\"Record.TransformFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record after applying specified transformations.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"transformOperations\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":68}],\"label\":\"Record.TransformFields(record as record, transformOperations as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"record\",\"type\":\"record\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"transformOperations\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":101}],\"label\":\"Record.TransformFields(record as record, transformOperations as list, missingField as nullable number)\"}]},{\"export\":\"Record.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all records.\",\"signatures\":null},{\"export\":\"RelativePosition.FromEnd\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Indicates indexing should be done from the end of the input.\",\"signatures\":null},{\"export\":\"RelativePosition.FromStart\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Indicates indexing should be done from the start of the input.\",\"signatures\":null},{\"export\":\"RelativePosition.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Indicates whether indexing should be done from the start or end of the input.\",\"signatures\":null},{\"export\":\"Replacer.ReplaceText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Replaces text within the provided input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"old\",\"type\":\"text\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":55},{\"documentation\":null,\"label\":\"new\",\"type\":\"text\",\"signatureLabelOffset\":57,\"signatureLabelEnd\":68}],\"label\":\"Replacer.ReplaceText(text as nullable text, old as text, new as text)\"}]},{\"export\":\"Replacer.ReplaceValue\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Replaces values within the provided input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"old\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"new\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":58}],\"label\":\"Replacer.ReplaceValue(value as any, old as any, new as any)\"}]},{\"export\":\"RoundingMode.AwayFromZero\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"RoundingMode.AwayFromZero\",\"signatures\":null},{\"export\":\"RoundingMode.Down\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"RoundingMode.Down\",\"signatures\":null},{\"export\":\"RoundingMode.ToEven\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"RoundingMode.ToEven\",\"signatures\":null},{\"export\":\"RoundingMode.TowardZero\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"RoundingMode.TowardZero\",\"signatures\":null},{\"export\":\"RoundingMode.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies rounding direction when there is a tie between the possible numbers to round to.\",\"signatures\":null},{\"export\":\"RoundingMode.Up\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"RoundingMode.Up\",\"signatures\":null},{\"export\":\"RowExpression.Column\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns an AST that represents access to a column within a row expression.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"columnName\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":39}],\"label\":\"RowExpression.Column(columnName as text)\"}]},{\"export\":\"RowExpression.From\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the AST for the body of a function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":39}],\"label\":\"RowExpression.From(function as function)\"}]},{\"export\":\"RowExpression.Row\",\"kind\":\"Constant\",\"primitiveType\":\"record\",\"summary\":\"An AST node representing the row in a row expression.\",\"signatures\":null},{\"export\":\"Single.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Creates a Single from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Single.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":50}],\"label\":\"Single.From(value as any, culture as nullable text)\"}]},{\"export\":\"Single.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents single precision floating point number.\",\"signatures\":null},{\"export\":\"Splitter.SplitByNothing\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that does no splitting, returning its argument as a single element list.\",\"signatures\":[{\"parameters\":[],\"label\":\"Splitter.SplitByNothing()\"}]},{\"export\":\"Splitter.SplitTextByAnyDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text at any of the specified delimiters.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":51}],\"label\":\"Splitter.SplitTextByAnyDelimiter(delimiters as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":82}],\"label\":\"Splitter.SplitTextByAnyDelimiter(delimiters as list, quoteStyle as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":82},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":84,\"signatureLabelEnd\":114}],\"label\":\"Splitter.SplitTextByAnyDelimiter(delimiters as list, quoteStyle as nullable number, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByCharacterTransition\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text according to a transition from one kind of character to another. The {0} and {1} parameters can either be a list of characters, or a function that takes a character and returns true/false.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"before\",\"type\":\"anynonnull\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"after\",\"type\":\"anynonnull\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":81}],\"label\":\"Splitter.SplitTextByCharacterTransition(before as anynonnull, after as anynonnull)\"}]},{\"export\":\"Splitter.SplitTextByDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text according to the specified delimiter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47}],\"label\":\"Splitter.SplitTextByDelimiter(delimiter as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":78}],\"label\":\"Splitter.SplitTextByDelimiter(delimiter as text, quoteStyle as nullable number)\"}]},{\"export\":\"Splitter.SplitTextByEachDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text at each specified delimiter in sequence.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":52}],\"label\":\"Splitter.SplitTextByEachDelimiter(delimiters as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":83}],\"label\":\"Splitter.SplitTextByEachDelimiter(delimiters as list, quoteStyle as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"delimiters\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":83},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":85,\"signatureLabelEnd\":115}],\"label\":\"Splitter.SplitTextByEachDelimiter(delimiters as list, quoteStyle as nullable number, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByLengths\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text by each specified length.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lengths\",\"type\":\"list\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":43}],\"label\":\"Splitter.SplitTextByLengths(lengths as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lengths\",\"type\":\"list\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":75}],\"label\":\"Splitter.SplitTextByLengths(lengths as list, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByPositions\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text at each specified position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"positions\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47}],\"label\":\"Splitter.SplitTextByPositions(positions as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"positions\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":79}],\"label\":\"Splitter.SplitTextByPositions(positions as list, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByRanges\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text according to the specified offsets and lengths.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"ranges\",\"type\":\"list\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41}],\"label\":\"Splitter.SplitTextByRanges(ranges as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"ranges\",\"type\":\"list\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":73}],\"label\":\"Splitter.SplitTextByRanges(ranges as list, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByRepeatedLengths\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text after the specified length repeatedly.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"length\",\"type\":\"number\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52}],\"label\":\"Splitter.SplitTextByRepeatedLengths(length as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"length\",\"type\":\"number\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"startAtEnd\",\"type\":\"nullable logical\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":84}],\"label\":\"Splitter.SplitTextByRepeatedLengths(length as number, startAtEnd as nullable logical)\"}]},{\"export\":\"Splitter.SplitTextByWhitespace\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Returns a function that splits text into a list of text at whitespace.\",\"signatures\":[{\"parameters\":[],\"label\":\"Splitter.SplitTextByWhitespace()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"quoteStyle\",\"type\":\"nullable number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":60}],\"label\":\"Splitter.SplitTextByWhitespace(quoteStyle as nullable number)\"}]},{\"export\":\"SqlExpression.SchemaFrom\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"SqlExpression.SchemaFrom\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"schema\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":38}],\"label\":\"SqlExpression.SchemaFrom(schema as any)\"}]},{\"export\":\"SqlExpression.ToExpression\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"SqlExpression.ToExpression\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"sql\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"environment\",\"type\":\"record\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":61}],\"label\":\"SqlExpression.ToExpression(sql as text, environment as record)\"}]},{\"export\":\"Table.AddColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Adds a column with the specified name. The value is computed using the specified selection function with each row taken as an input.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"columnGenerator\",\"type\":\"function\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":82}],\"label\":\"Table.AddColumn(table as table, newColumnName as text, columnGenerator as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"columnGenerator\",\"type\":\"function\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":82},{\"documentation\":null,\"label\":\"columnType\",\"type\":\"nullable type\",\"signatureLabelOffset\":84,\"signatureLabelEnd\":111}],\"label\":\"Table.AddColumn(table as table, newColumnName as text, columnGenerator as function, columnType as nullable type)\"}]},{\"export\":\"Table.AddIndexColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Appends a column with explicit position values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58}],\"label\":\"Table.AddIndexColumn(table as table, newColumnName as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"initialValue\",\"type\":\"nullable number\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":91}],\"label\":\"Table.AddIndexColumn(table as table, newColumnName as text, initialValue as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"initialValue\",\"type\":\"nullable number\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":91},{\"documentation\":null,\"label\":\"increment\",\"type\":\"nullable number\",\"signatureLabelOffset\":93,\"signatureLabelEnd\":121}],\"label\":\"Table.AddIndexColumn(table as table, newColumnName as text, initialValue as nullable number, increment as nullable number)\"}]},{\"export\":\"Table.AddJoinColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Performs a join between tables on supplied columns and produces the join result in a new column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"table2\",\"type\":\"any\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":63},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":65,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":99}],\"label\":\"Table.AddJoinColumn(table1 as table, key1 as any, table2 as any, key2 as any, newColumnName as text)\"}]},{\"export\":\"Table.AddKey\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Add a key to a table, specify the subset of the tables column names that defines the key, and specify whether the key is primary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"columns\",\"type\":\"list\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"isPrimary\",\"type\":\"logical\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":66}],\"label\":\"Table.AddKey(table as table, columns as list, isPrimary as logical)\"}]},{\"export\":\"Table.AggregateTableColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Aggregates a column of tables into multiple columns in the containing table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"aggregations\",\"type\":\"list\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":79}],\"label\":\"Table.AggregateTableColumn(table as table, column as text, aggregations as list)\"}]},{\"export\":\"Table.AlternateRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Keeps the initial offset then alternates taking and skipping the following rows.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"skip\",\"type\":\"number\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"take\",\"type\":\"number\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":84}],\"label\":\"Table.AlternateRows(table as table, offset as number, skip as number, take as number)\"}]},{\"export\":\"Table.Buffer\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Buffers a table in memory, isolating it from external changes during evaluation.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27}],\"label\":\"Table.Buffer(table as table)\"}]},{\"export\":\"Table.Column\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a specified column of data from the table as a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":43}],\"label\":\"Table.Column(table as table, column as text)\"}]},{\"export\":\"Table.ColumnCount\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns the number of columns in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32}],\"label\":\"Table.ColumnCount(table as table)\"}]},{\"export\":\"Table.ColumnNames\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the column names as a list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32}],\"label\":\"Table.ColumnNames(table as table)\"}]},{\"export\":\"Table.ColumnsOfType\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list with the names of the columns that match the specified types.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"listOfTypes\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":55}],\"label\":\"Table.ColumnsOfType(table as table, listOfTypes as list)\"}]},{\"export\":\"Table.Combine\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table that is the result of merging a list of tables.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tables\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28}],\"label\":\"Table.Combine(tables as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"tables\",\"type\":\"list\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":44}],\"label\":\"Table.Combine(tables as list, columns as any)\"}]},{\"export\":\"Table.CombineColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Combines the specified columns into a new column using the specified combiner function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"sourceColumns\",\"type\":\"list\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"combiner\",\"type\":\"function\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":80},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":82,\"signatureLabelEnd\":96}],\"label\":\"Table.CombineColumns(table as table, sourceColumns as list, combiner as function, column as text)\"}]},{\"export\":\"Table.Contains\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether the specified record appears as a row in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"row\",\"type\":\"record\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":44}],\"label\":\"Table.Contains(table as table, row as record)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"row\",\"type\":\"record\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":69}],\"label\":\"Table.Contains(table as table, row as record, equationCriteria as any)\"}]},{\"export\":\"Table.ContainsAll\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether all of the specified records appear as rows in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46}],\"label\":\"Table.ContainsAll(table as table, rows as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":71}],\"label\":\"Table.ContainsAll(table as table, rows as list, equationCriteria as any)\"}]},{\"export\":\"Table.ContainsAny\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether any of the specified records appear as rows in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46}],\"label\":\"Table.ContainsAny(table as table, rows as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":71}],\"label\":\"Table.ContainsAny(table as table, rows as list, equationCriteria as any)\"}]},{\"export\":\"Table.DemoteHeaders\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Demotes the column headers to the first row of values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34}],\"label\":\"Table.DemoteHeaders(table as table)\"}]},{\"export\":\"Table.Distinct\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Removes duplicate rows from the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29}],\"label\":\"Table.Distinct(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":54}],\"label\":\"Table.Distinct(table as table, equationCriteria as any)\"}]},{\"export\":\"Table.DuplicateColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Duplicates a column with the specified name. Values and type are copied from the source column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"columnName\",\"type\":\"text\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":79}],\"label\":\"Table.DuplicateColumn(table as table, columnName as text, newColumnName as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"columnName\",\"type\":\"text\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":79},{\"documentation\":null,\"label\":\"columnType\",\"type\":\"nullable type\",\"signatureLabelOffset\":81,\"signatureLabelEnd\":108}],\"label\":\"Table.DuplicateColumn(table as table, columnName as text, newColumnName as text, columnType as nullable type)\"}]},{\"export\":\"Table.ExpandListColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Given a column of lists in a table, create a copy of a row for each value in its list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":53}],\"label\":\"Table.ExpandListColumn(table as table, column as text)\"}]},{\"export\":\"Table.ExpandRecordColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Expands a column of records into columns with each of the values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":55},{\"documentation\":null,\"label\":\"fieldNames\",\"type\":\"list\",\"signatureLabelOffset\":57,\"signatureLabelEnd\":75}],\"label\":\"Table.ExpandRecordColumn(table as table, column as text, fieldNames as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":55},{\"documentation\":null,\"label\":\"fieldNames\",\"type\":\"list\",\"signatureLabelOffset\":57,\"signatureLabelEnd\":75},{\"documentation\":null,\"label\":\"newColumnNames\",\"type\":\"nullable list\",\"signatureLabelOffset\":77,\"signatureLabelEnd\":108}],\"label\":\"Table.ExpandRecordColumn(table as table, column as text, fieldNames as list, newColumnNames as nullable list)\"}]},{\"export\":\"Table.ExpandTableColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Expands a column of records or a column of tables into multiple columns in the containing table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"columnNames\",\"type\":\"list\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":75}],\"label\":\"Table.ExpandTableColumn(table as table, column as text, columnNames as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"columnNames\",\"type\":\"list\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":75},{\"documentation\":null,\"label\":\"newColumnNames\",\"type\":\"nullable list\",\"signatureLabelOffset\":77,\"signatureLabelEnd\":108}],\"label\":\"Table.ExpandTableColumn(table as table, column as text, columnNames as list, newColumnNames as nullable list)\"}]},{\"export\":\"Table.FillDown\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Propagates the value of a previous cell to the null-valued cells below in the column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"columns\",\"type\":\"list\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":46}],\"label\":\"Table.FillDown(table as table, columns as list)\"}]},{\"export\":\"Table.FillUp\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Propagates the value of a cell to the null-valued cells above in the column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"columns\",\"type\":\"list\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44}],\"label\":\"Table.FillUp(table as table, columns as list)\"}]},{\"export\":\"Table.FilterWithDataTable\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Table.FilterWithDataTable\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"dataTableIdentifier\",\"type\":\"text\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":69}],\"label\":\"Table.FilterWithDataTable(table as table, dataTableIdentifier as text)\"}]},{\"export\":\"Table.FindText\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns all the rows that contain the given text in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":43}],\"label\":\"Table.FindText(table as table, text as text)\"}]},{\"export\":\"Table.First\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first row or a specified default value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26}],\"label\":\"Table.First(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":42}],\"label\":\"Table.First(table as table, default as any)\"}]},{\"export\":\"Table.FirstN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the first count rows specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":52}],\"label\":\"Table.FirstN(table as table, countOrCondition as any)\"}]},{\"export\":\"Table.FirstValue\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first column of the first row of the table or a specified default value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31}],\"label\":\"Table.FirstValue(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47}],\"label\":\"Table.FirstValue(table as table, default as any)\"}]},{\"export\":\"Table.FromColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Creates a table from a list of columns and specified values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31}],\"label\":\"Table.FromColumns(lists as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"lists\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47}],\"label\":\"Table.FromColumns(lists as list, columns as any)\"}]},{\"export\":\"Table.FromList\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Converts a list into a table by applying the specified splitting function to each item in the list.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"Table.FromList(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"nullable function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58}],\"label\":\"Table.FromList(list as list, splitter as nullable function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"nullable function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":74}],\"label\":\"Table.FromList(list as list, splitter as nullable function, columns as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"nullable function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":90}],\"label\":\"Table.FromList(list as list, splitter as nullable function, columns as any, default as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"nullable function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":90},{\"documentation\":null,\"label\":\"extraValues\",\"type\":\"nullable number\",\"signatureLabelOffset\":92,\"signatureLabelEnd\":122}],\"label\":\"Table.FromList(list as list, splitter as nullable function, columns as any, default as any, extraValues as nullable number)\"}]},{\"export\":\"Table.FromPartitions\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table that is the result of combining a set of partitioned tables.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"partitionColumn\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"partitions\",\"type\":\"list\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":64}],\"label\":\"Table.FromPartitions(partitionColumn as text, partitions as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"partitionColumn\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"partitions\",\"type\":\"list\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"partitionColumnType\",\"type\":\"nullable type\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":102}],\"label\":\"Table.FromPartitions(partitionColumn as text, partitions as list, partitionColumnType as nullable type)\"}]},{\"export\":\"Table.FromRecords\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Converts a list of records into a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"records\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33}],\"label\":\"Table.FromRecords(records as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"records\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":49}],\"label\":\"Table.FromRecords(records as list, columns as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"records\",\"type\":\"list\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":82}],\"label\":\"Table.FromRecords(records as list, columns as any, missingField as nullable number)\"}]},{\"export\":\"Table.FromRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Creates a table from a list of row values and optional columns\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"Table.FromRows(rows as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":43}],\"label\":\"Table.FromRows(rows as list, columns as any)\"}]},{\"export\":\"Table.FromValue\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Creates a table with a column from the provided value(s).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Table.FromValue(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":56}],\"label\":\"Table.FromValue(value as any, options as nullable record)\"}]},{\"export\":\"Table.Group\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Groups rows in the table that have the same key.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"aggregatedColumns\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":65}],\"label\":\"Table.Group(table as table, key as any, aggregatedColumns as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"aggregatedColumns\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"groupKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":95}],\"label\":\"Table.Group(table as table, key as any, aggregatedColumns as list, groupKind as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"aggregatedColumns\",\"type\":\"list\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"groupKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":95},{\"documentation\":null,\"label\":\"comparer\",\"type\":\"nullable function\",\"signatureLabelOffset\":97,\"signatureLabelEnd\":126}],\"label\":\"Table.Group(table as table, key as any, aggregatedColumns as list, groupKind as nullable number, comparer as nullable function)\"}]},{\"export\":\"Table.HasColumns\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"indicates whether the table contains the specified column(s).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":47}],\"label\":\"Table.HasColumns(table as table, columns as any)\"}]},{\"export\":\"Table.InsertRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Inserts a list of rows into the table at the specified position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":63}],\"label\":\"Table.InsertRows(table as table, offset as number, rows as list)\"}]},{\"export\":\"Table.IsDistinct\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether the table contains only distinct rows (no duplicates).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31}],\"label\":\"Table.IsDistinct(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":58}],\"label\":\"Table.IsDistinct(table as table, comparisonCriteria as any)\"}]},{\"export\":\"Table.IsEmpty\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether the table contains any rows.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28}],\"label\":\"Table.IsEmpty(table as table)\"}]},{\"export\":\"Table.Join\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Joins the rows from the two tables that match based on the given keys.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":69}],\"label\":\"Table.Join(table1 as table, key1 as any, table2 as table, key2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":69},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":71,\"signatureLabelEnd\":98}],\"label\":\"Table.Join(table1 as table, key1 as any, table2 as table, key2 as any, joinKind as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":69},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":71,\"signatureLabelEnd\":98},{\"documentation\":null,\"label\":\"joinAlgorithm\",\"type\":\"nullable number\",\"signatureLabelOffset\":100,\"signatureLabelEnd\":132}],\"label\":\"Table.Join(table1 as table, key1 as any, table2 as table, key2 as any, joinKind as nullable number, joinAlgorithm as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":69},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":71,\"signatureLabelEnd\":98},{\"documentation\":null,\"label\":\"joinAlgorithm\",\"type\":\"nullable number\",\"signatureLabelOffset\":100,\"signatureLabelEnd\":132},{\"documentation\":null,\"label\":\"keyEqualityComparers\",\"type\":\"nullable list\",\"signatureLabelOffset\":134,\"signatureLabelEnd\":171}],\"label\":\"Table.Join(table1 as table, key1 as any, table2 as table, key2 as any, joinKind as nullable number, joinAlgorithm as nullable number, keyEqualityComparers as nullable list)\"}]},{\"export\":\"Table.Keys\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Table.Keys\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25}],\"label\":\"Table.Keys(table as table)\"}]},{\"export\":\"Table.Last\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last row or a specified default value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25}],\"label\":\"Table.Last(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41}],\"label\":\"Table.Last(table as table, default as any)\"}]},{\"export\":\"Table.LastN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the last specified number of rows.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":51}],\"label\":\"Table.LastN(table as table, countOrCondition as any)\"}]},{\"export\":\"Table.MatchesAllRows\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether all the rows in the table meet the given condition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58}],\"label\":\"Table.MatchesAllRows(table as table, condition as function)\"}]},{\"export\":\"Table.MatchesAnyRows\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Indicates whether any the rows in the table meet the given condition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58}],\"label\":\"Table.MatchesAnyRows(table as table, condition as function)\"}]},{\"export\":\"Table.Max\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the largest row or default value using the given criteria.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":51}],\"label\":\"Table.Max(table as table, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":67}],\"label\":\"Table.Max(table as table, comparisonCriteria as any, default as any)\"}]},{\"export\":\"Table.MaxN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the largest row(s) using the given criteria.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":77}],\"label\":\"Table.MaxN(table as table, comparisonCriteria as any, countOrCondition as any)\"}]},{\"export\":\"Table.Min\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the smallest row or a default value using the given criteria.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":51}],\"label\":\"Table.Min(table as table, comparisonCriteria as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":67}],\"label\":\"Table.Min(table as table, comparisonCriteria as any, default as any)\"}]},{\"export\":\"Table.MinN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the smallest row(s) using the given criteria.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":77}],\"label\":\"Table.MinN(table as table, comparisonCriteria as any, countOrCondition as any)\"}]},{\"export\":\"Table.NestedJoin\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Performs a join between tables on supplied columns and produces the join result in a new column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"table2\",\"type\":\"any\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":96}],\"label\":\"Table.NestedJoin(table1 as table, key1 as any, table2 as any, key2 as any, newColumnName as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"table2\",\"type\":\"any\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":96},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":98,\"signatureLabelEnd\":125}],\"label\":\"Table.NestedJoin(table1 as table, key1 as any, table2 as any, key2 as any, newColumnName as text, joinKind as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"table2\",\"type\":\"any\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":96},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":98,\"signatureLabelEnd\":125},{\"documentation\":null,\"label\":\"keyEqualityComparers\",\"type\":\"nullable list\",\"signatureLabelOffset\":127,\"signatureLabelEnd\":164}],\"label\":\"Table.NestedJoin(table1 as table, key1 as any, table2 as any, key2 as any, newColumnName as text, joinKind as nullable number, keyEqualityComparers as nullable list)\"}]},{\"export\":\"Table.Partition\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Partitions the table into a list of tables based on the number of groups and column specified.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"groups\",\"type\":\"number\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"hash\",\"type\":\"function\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":82}],\"label\":\"Table.Partition(table as table, column as text, groups as number, hash as function)\"}]},{\"export\":\"Table.PartitionValues\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns information about how a table is partitioned.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":36}],\"label\":\"Table.PartitionValues(table as table)\"}]},{\"export\":\"Table.Pivot\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Given a pair of columns representing attribute-value pairs, rotates the data in the attribute column into a column headings.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"pivotValues\",\"type\":\"list\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"attributeColumn\",\"type\":\"text\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"valueColumn\",\"type\":\"text\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":93}],\"label\":\"Table.Pivot(table as table, pivotValues as list, attributeColumn as text, valueColumn as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"pivotValues\",\"type\":\"list\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"attributeColumn\",\"type\":\"text\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"valueColumn\",\"type\":\"text\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":93},{\"documentation\":null,\"label\":\"aggregationFunction\",\"type\":\"nullable function\",\"signatureLabelOffset\":95,\"signatureLabelEnd\":135}],\"label\":\"Table.Pivot(table as table, pivotValues as list, attributeColumn as text, valueColumn as text, aggregationFunction as nullable function)\"}]},{\"export\":\"Table.PositionOf\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the position or positions of the row within the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"row\",\"type\":\"record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46}],\"label\":\"Table.PositionOf(table as table, row as record)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"row\",\"type\":\"record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":65}],\"label\":\"Table.PositionOf(table as table, row as record, occurrence as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"row\",\"type\":\"record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":90}],\"label\":\"Table.PositionOf(table as table, row as record, occurrence as any, equationCriteria as any)\"}]},{\"export\":\"Table.PositionOfAny\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the position or positions of any of the specified rows within the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":48}],\"label\":\"Table.PositionOfAny(table as table, rows as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":79}],\"label\":\"Table.PositionOfAny(table as table, rows as list, occurrence as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":79},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":81,\"signatureLabelEnd\":104}],\"label\":\"Table.PositionOfAny(table as table, rows as list, occurrence as nullable number, equationCriteria as any)\"}]},{\"export\":\"Table.PrefixColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table where the columns have all been prefixed with the given text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"prefix\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50}],\"label\":\"Table.PrefixColumns(table as table, prefix as text)\"}]},{\"export\":\"Table.Profile\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a profile of the columns of a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28}],\"label\":\"Table.Profile(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"additionalAggregates\",\"type\":\"nullable list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":67}],\"label\":\"Table.Profile(table as table, additionalAggregates as nullable list)\"}]},{\"export\":\"Table.PromoteHeaders\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Promotes the first row of values as the new column headers (i.e. column names).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35}],\"label\":\"Table.PromoteHeaders(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":63}],\"label\":\"Table.PromoteHeaders(table as table, options as nullable record)\"}]},{\"export\":\"Table.Range\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the rows beginning at the specified offset.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":44}],\"label\":\"Table.Range(table as table, offset as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":70}],\"label\":\"Table.Range(table as table, offset as number, count as nullable number)\"}]},{\"export\":\"Table.RemoveColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Removes the specified columns.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50}],\"label\":\"Table.RemoveColumns(table as table, columns as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":83}],\"label\":\"Table.RemoveColumns(table as table, columns as any, missingField as nullable number)\"}]},{\"export\":\"Table.RemoveFirstN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the first count rows skipped.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":33}],\"label\":\"Table.RemoveFirstN(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":58}],\"label\":\"Table.RemoveFirstN(table as table, countOrCondition as any)\"}]},{\"export\":\"Table.RemoveLastN\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the last N rows removed.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32}],\"label\":\"Table.RemoveLastN(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":57}],\"label\":\"Table.RemoveLastN(table as table, countOrCondition as any)\"}]},{\"export\":\"Table.RemoveMatchingRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Removes all occurrences of the specified rows from the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":53}],\"label\":\"Table.RemoveMatchingRows(table as table, rows as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":53},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":55,\"signatureLabelEnd\":78}],\"label\":\"Table.RemoveMatchingRows(table as table, rows as list, equationCriteria as any)\"}]},{\"export\":\"Table.RemoveRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Removes the specified number of rows.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":49}],\"label\":\"Table.RemoveRows(table as table, offset as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":75}],\"label\":\"Table.RemoveRows(table as table, offset as number, count as nullable number)\"}]},{\"export\":\"Table.RemoveRowsWithErrors\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the rows removed from the input table that contain an error in at least one of the cells. If a columns list is specified, then only the cells in the specified columns are inspected for errors.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41}],\"label\":\"Table.RemoveRowsWithErrors(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"columns\",\"type\":\"nullable list\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":67}],\"label\":\"Table.RemoveRowsWithErrors(table as table, columns as nullable list)\"}]},{\"export\":\"Table.RenameColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Applies rename(s) of the form {old, new}.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"renames\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":51}],\"label\":\"Table.RenameColumns(table as table, renames as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"renames\",\"type\":\"list\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":84}],\"label\":\"Table.RenameColumns(table as table, renames as list, missingField as nullable number)\"}]},{\"export\":\"Table.ReorderColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the columns in the specified order.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"columnOrder\",\"type\":\"list\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":56}],\"label\":\"Table.ReorderColumns(table as table, columnOrder as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"columnOrder\",\"type\":\"list\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":89}],\"label\":\"Table.ReorderColumns(table as table, columnOrder as list, missingField as nullable number)\"}]},{\"export\":\"Table.Repeat\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Repeats the rows of the tables a specified number of times.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":44}],\"label\":\"Table.Repeat(table as table, count as number)\"}]},{\"export\":\"Table.ReplaceErrorValues\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Replaces the error values in the specified columns with the corresponding specified value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"errorReplacement\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":65}],\"label\":\"Table.ReplaceErrorValues(table as table, errorReplacement as list)\"}]},{\"export\":\"Table.ReplaceKeys\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Table.ReplaceKeys\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"keys\",\"type\":\"list\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46}],\"label\":\"Table.ReplaceKeys(table as table, keys as list)\"}]},{\"export\":\"Table.ReplaceMatchingRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Replaces all the specified rows with the provided row(s).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"replacements\",\"type\":\"list\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":62}],\"label\":\"Table.ReplaceMatchingRows(table as table, replacements as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"replacements\",\"type\":\"list\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":62},{\"documentation\":null,\"label\":\"equationCriteria\",\"type\":\"any\",\"signatureLabelOffset\":64,\"signatureLabelEnd\":87}],\"label\":\"Table.ReplaceMatchingRows(table as table, replacements as list, equationCriteria as any)\"}]},{\"export\":\"Table.ReplaceRelationshipIdentity\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Table.ReplaceRelationshipIdentity\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"identity\",\"type\":\"text\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":64}],\"label\":\"Table.ReplaceRelationshipIdentity(value as any, identity as text)\"}]},{\"export\":\"Table.ReplaceRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Replaces the specified range of rows with the provided row(s).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":67},{\"documentation\":null,\"label\":\"rows\",\"type\":\"list\",\"signatureLabelOffset\":69,\"signatureLabelEnd\":81}],\"label\":\"Table.ReplaceRows(table as table, offset as number, count as number, rows as list)\"}]},{\"export\":\"Table.ReplaceValue\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Replaces one value with another in the specified columns.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"oldValue\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"newValue\",\"type\":\"any\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":67},{\"documentation\":null,\"label\":\"replacer\",\"type\":\"function\",\"signatureLabelOffset\":69,\"signatureLabelEnd\":89},{\"documentation\":null,\"label\":\"columnsToSearch\",\"type\":\"list\",\"signatureLabelOffset\":91,\"signatureLabelEnd\":114}],\"label\":\"Table.ReplaceValue(table as table, oldValue as any, newValue as any, replacer as function, columnsToSearch as list)\"}]},{\"export\":\"Table.ReverseRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the rows in reverse order.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32}],\"label\":\"Table.ReverseRows(table as table)\"}]},{\"export\":\"Table.RowCount\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns the number of rows in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29}],\"label\":\"Table.RowCount(table as table)\"}]},{\"export\":\"Table.Schema\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing a description of the columns (i.e. the schema) of the specified table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27}],\"label\":\"Table.Schema(table as table)\"}]},{\"export\":\"Table.SelectColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with only the specified columns.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50}],\"label\":\"Table.SelectColumns(table as table, columns as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":83}],\"label\":\"Table.SelectColumns(table as table, columns as any, missingField as nullable number)\"}]},{\"export\":\"Table.SelectRows\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Selects the rows that meet the condition function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"condition\",\"type\":\"function\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":54}],\"label\":\"Table.SelectRows(table as table, condition as function)\"}]},{\"export\":\"Table.SelectRowsWithErrors\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with only those rows of the input table that contain an error in at least one of the cells. If a columns list is specified, then only the cells in the specified columns are inspected for errors.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41}],\"label\":\"Table.SelectRowsWithErrors(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"columns\",\"type\":\"nullable list\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":67}],\"label\":\"Table.SelectRowsWithErrors(table as table, columns as nullable list)\"}]},{\"export\":\"Table.SingleRow\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the single row in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30}],\"label\":\"Table.SingleRow(table as table)\"}]},{\"export\":\"Table.Skip\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table with the first count rows skipped.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25}],\"label\":\"Table.Skip(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"countOrCondition\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":50}],\"label\":\"Table.Skip(table as table, countOrCondition as any)\"}]},{\"export\":\"Table.Sort\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Sorts the table using one or more column names and comparison criteria.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"comparisonCriteria\",\"type\":\"any\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":52}],\"label\":\"Table.Sort(table as table, comparisonCriteria as any)\"}]},{\"export\":\"Table.Split\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Splits the specified table into a list of tables using the specified page size.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"pageSize\",\"type\":\"number\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":46}],\"label\":\"Table.Split(table as table, pageSize as number)\"}]},{\"export\":\"Table.SplitColumn\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Splits the specified columns into a set of additional columns using the specified splitter function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"sourceColumn\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":76}],\"label\":\"Table.SplitColumn(table as table, sourceColumn as text, splitter as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"sourceColumn\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"columnNamesOrNumber\",\"type\":\"any\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":104}],\"label\":\"Table.SplitColumn(table as table, sourceColumn as text, splitter as function, columnNamesOrNumber as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"sourceColumn\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"columnNamesOrNumber\",\"type\":\"any\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":104},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":106,\"signatureLabelEnd\":120}],\"label\":\"Table.SplitColumn(table as table, sourceColumn as text, splitter as function, columnNamesOrNumber as any, default as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"sourceColumn\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"splitter\",\"type\":\"function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"columnNamesOrNumber\",\"type\":\"any\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":104},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":106,\"signatureLabelEnd\":120},{\"documentation\":null,\"label\":\"extraColumns\",\"type\":\"any\",\"signatureLabelOffset\":122,\"signatureLabelEnd\":141}],\"label\":\"Table.SplitColumn(table as table, sourceColumn as text, splitter as function, columnNamesOrNumber as any, default as any, extraColumns as any)\"}]},{\"export\":\"Table.ToColumns\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Creates a list of nested lists of column values from a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30}],\"label\":\"Table.ToColumns(table as table)\"}]},{\"export\":\"Table.ToList\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Converts a table into a list by applying the specified combining function to each row of values in the table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27}],\"label\":\"Table.ToList(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"combiner\",\"type\":\"nullable function\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":58}],\"label\":\"Table.ToList(table as table, combiner as nullable function)\"}]},{\"export\":\"Table.ToRecords\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Converts a table to a list of records.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30}],\"label\":\"Table.ToRecords(table as table)\"}]},{\"export\":\"Table.ToRows\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Creates a list of nested lists of row values from a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27}],\"label\":\"Table.ToRows(table as table)\"}]},{\"export\":\"Table.TransformColumnNames\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Transforms column names by using the given function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"nameGenerator\",\"type\":\"function\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":68}],\"label\":\"Table.TransformColumnNames(table as table, nameGenerator as function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"nameGenerator\",\"type\":\"function\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":96}],\"label\":\"Table.TransformColumnNames(table as table, nameGenerator as function, options as nullable record)\"}]},{\"export\":\"Table.TransformColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Applies transformation(s) of the form { column, transform }.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"transformOperations\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":66}],\"label\":\"Table.TransformColumns(table as table, transformOperations as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"transformOperations\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":66},{\"documentation\":null,\"label\":\"defaultTransformation\",\"type\":\"nullable function\",\"signatureLabelOffset\":68,\"signatureLabelEnd\":110}],\"label\":\"Table.TransformColumns(table as table, transformOperations as list, defaultTransformation as nullable function)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"transformOperations\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":66},{\"documentation\":null,\"label\":\"defaultTransformation\",\"type\":\"nullable function\",\"signatureLabelOffset\":68,\"signatureLabelEnd\":110},{\"documentation\":null,\"label\":\"missingField\",\"type\":\"nullable number\",\"signatureLabelOffset\":112,\"signatureLabelEnd\":143}],\"label\":\"Table.TransformColumns(table as table, transformOperations as list, defaultTransformation as nullable function, missingField as nullable number)\"}]},{\"export\":\"Table.TransformColumnTypes\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Applies type transformation(s) of the form { column, type } using a specific culture.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"typeTransformations\",\"type\":\"list\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":70}],\"label\":\"Table.TransformColumnTypes(table as table, typeTransformations as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"typeTransformations\",\"type\":\"list\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":70},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":72,\"signatureLabelEnd\":96}],\"label\":\"Table.TransformColumnTypes(table as table, typeTransformations as list, culture as nullable text)\"}]},{\"export\":\"Table.TransformRows\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Transforms the rows of the table using the specified transform function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"transform\",\"type\":\"function\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":57}],\"label\":\"Table.TransformRows(table as table, transform as function)\"}]},{\"export\":\"Table.Transpose\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Makes columns into rows and rows into columns.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30}],\"label\":\"Table.Transpose(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":46}],\"label\":\"Table.Transpose(table as table, columns as any)\"}]},{\"export\":\"Table.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all tables.\",\"signatures\":null},{\"export\":\"Table.Unpivot\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Translates a set of columns in a table into attribute-value pairs.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"pivotColumns\",\"type\":\"list\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"attributeColumn\",\"type\":\"text\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":75},{\"documentation\":null,\"label\":\"valueColumn\",\"type\":\"text\",\"signatureLabelOffset\":77,\"signatureLabelEnd\":96}],\"label\":\"Table.Unpivot(table as table, pivotColumns as list, attributeColumn as text, valueColumn as text)\"}]},{\"export\":\"Table.UnpivotOtherColumns\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Translates all columns other than a specified set into attribute-value pairs.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"pivotColumns\",\"type\":\"list\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":62},{\"documentation\":null,\"label\":\"attributeColumn\",\"type\":\"text\",\"signatureLabelOffset\":64,\"signatureLabelEnd\":87},{\"documentation\":null,\"label\":\"valueColumn\",\"type\":\"text\",\"signatureLabelOffset\":89,\"signatureLabelEnd\":108}],\"label\":\"Table.UnpivotOtherColumns(table as table, pivotColumns as list, attributeColumn as text, valueColumn as text)\"}]},{\"export\":\"Table.View\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Creates or extends a table with user-defined handlers for query and action operations.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"nullable table\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"handlers\",\"type\":\"record\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":54}],\"label\":\"Table.View(table as nullable table, handlers as record)\"}]},{\"export\":\"Table.ViewFunction\",\"kind\":\"Function\",\"primitiveType\":\"function\",\"summary\":\"Creates a function that can be intercepted by a handler defined on a view (via Table.View).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":39}],\"label\":\"Table.ViewFunction(function as function)\"}]},{\"export\":\"Tables.GetRelationships\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Gets the relationships among a set of tables.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tables\",\"type\":\"table\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39}],\"label\":\"Tables.GetRelationships(tables as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"tables\",\"type\":\"table\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"dataColumn\",\"type\":\"nullable text\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":68}],\"label\":\"Tables.GetRelationships(tables as table, dataColumn as nullable text)\"}]},{\"export\":\"Text.AfterDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Text.AfterDelimiter\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60}],\"label\":\"Text.AfterDelimiter(text as nullable text, delimiter as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"index\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":74}],\"label\":\"Text.AfterDelimiter(text as nullable text, delimiter as text, index as any)\"}]},{\"export\":\"Text.At\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the character at the specified position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":8,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"index\",\"type\":\"number\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":46}],\"label\":\"Text.At(text as nullable text, index as number)\"}]},{\"export\":\"Text.BeforeDelimiter\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Text.BeforeDelimiter\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":61}],\"label\":\"Text.BeforeDelimiter(text as nullable text, delimiter as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"delimiter\",\"type\":\"text\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"index\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":75}],\"label\":\"Text.BeforeDelimiter(text as nullable text, delimiter as text, index as any)\"}]},{\"export\":\"Text.BetweenDelimiters\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Text.BetweenDelimiters\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"startDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"endDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":90}],\"label\":\"Text.BetweenDelimiters(text as nullable text, startDelimiter as text, endDelimiter as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"startDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"endDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":90},{\"documentation\":null,\"label\":\"startIndex\",\"type\":\"any\",\"signatureLabelOffset\":92,\"signatureLabelEnd\":109}],\"label\":\"Text.BetweenDelimiters(text as nullable text, startDelimiter as text, endDelimiter as text, startIndex as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"startDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":68},{\"documentation\":null,\"label\":\"endDelimiter\",\"type\":\"text\",\"signatureLabelOffset\":70,\"signatureLabelEnd\":90},{\"documentation\":null,\"label\":\"startIndex\",\"type\":\"any\",\"signatureLabelOffset\":92,\"signatureLabelEnd\":109},{\"documentation\":null,\"label\":\"endIndex\",\"type\":\"any\",\"signatureLabelOffset\":111,\"signatureLabelEnd\":126}],\"label\":\"Text.BetweenDelimiters(text as nullable text, startDelimiter as text, endDelimiter as text, startIndex as any, endIndex as any)\"}]},{\"export\":\"Text.Clean\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the text value with all non-printable characters removed.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32}],\"label\":\"Text.Clean(text as nullable text)\"}]},{\"export\":\"Text.Combine\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Concatenates a list of text values into one text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"texts\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26}],\"label\":\"Text.Combine(texts as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"texts\",\"type\":\"list\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"separator\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":54}],\"label\":\"Text.Combine(texts as list, separator as nullable text)\"}]},{\"export\":\"Text.Contains\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Returns whether the text contains the substring.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":54}],\"label\":\"Text.Contains(text as nullable text, substring as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"comparer\",\"type\":\"nullable function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":85}],\"label\":\"Text.Contains(text as nullable text, substring as text, comparer as nullable function)\"}]},{\"export\":\"Text.End\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the last characters of the text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":47}],\"label\":\"Text.End(text as nullable text, count as number)\"}]},{\"export\":\"Text.EndsWith\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether the text ends in the specified value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":54}],\"label\":\"Text.EndsWith(text as nullable text, substring as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"comparer\",\"type\":\"nullable function\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":85}],\"label\":\"Text.EndsWith(text as nullable text, substring as text, comparer as nullable function)\"}]},{\"export\":\"Text.Format\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Returns formatted text from a format string and arguments.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"formatString\",\"type\":\"text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"arguments\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50}],\"label\":\"Text.Format(formatString as text, arguments as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"formatString\",\"type\":\"text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"arguments\",\"type\":\"any\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":76}],\"label\":\"Text.Format(formatString as text, arguments as any, culture as nullable text)\"}]},{\"export\":\"Text.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Creates a text value from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"Text.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48}],\"label\":\"Text.From(value as any, culture as nullable text)\"}]},{\"export\":\"Text.FromBinary\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Decodes data from a binary form into text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":41}],\"label\":\"Text.FromBinary(binary as nullable binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"nullable binary\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":70}],\"label\":\"Text.FromBinary(binary as nullable binary, encoding as nullable number)\"}]},{\"export\":\"Text.InferNumberType\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Infers the granular number type (Int64.Type, Double.Type, etc.) of a number encoded in text\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33}],\"label\":\"Text.InferNumberType(text as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":59}],\"label\":\"Text.InferNumberType(text as text, culture as nullable text)\"}]},{\"export\":\"Text.Insert\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Inserts one text value into another at a given position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"newText\",\"type\":\"text\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":68}],\"label\":\"Text.Insert(text as nullable text, offset as number, newText as text)\"}]},{\"export\":\"Text.Length\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the number of characters.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33}],\"label\":\"Text.Length(text as nullable text)\"}]},{\"export\":\"Text.Lower\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Converts all characters to lowercase.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32}],\"label\":\"Text.Lower(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":58}],\"label\":\"Text.Lower(text as nullable text, culture as nullable text)\"}]},{\"export\":\"Text.Middle\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the substring up to a specific length.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"start\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50}],\"label\":\"Text.Middle(text as nullable text, start as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"start\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":76}],\"label\":\"Text.Middle(text as nullable text, start as number, count as nullable number)\"}]},{\"export\":\"Text.NewGuid\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Returns a new, random globally unique identifier (GUID).\",\"signatures\":[{\"parameters\":[],\"label\":\"Text.NewGuid()\"}]},{\"export\":\"Text.PadEnd\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns text of a specified length by padding the end of the given text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50}],\"label\":\"Text.PadEnd(text as nullable text, count as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"character\",\"type\":\"nullable text\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":78}],\"label\":\"Text.PadEnd(text as nullable text, count as number, character as nullable text)\"}]},{\"export\":\"Text.PadStart\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns text of a specified length by padding the start of the given text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":52}],\"label\":\"Text.PadStart(text as nullable text, count as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"character\",\"type\":\"nullable text\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":80}],\"label\":\"Text.PadStart(text as nullable text, count as number, character as nullable text)\"}]},{\"export\":\"Text.PositionOf\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first position of the value (-1 if not found).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47}],\"label\":\"Text.PositionOf(text as text, substring as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":78}],\"label\":\"Text.PositionOf(text as text, substring as text, occurrence as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":78},{\"documentation\":null,\"label\":\"comparer\",\"type\":\"nullable function\",\"signatureLabelOffset\":80,\"signatureLabelEnd\":109}],\"label\":\"Text.PositionOf(text as text, substring as text, occurrence as nullable number, comparer as nullable function)\"}]},{\"export\":\"Text.PositionOfAny\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first position in the text value of any listed character (-1 if not found).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"characters\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":51}],\"label\":\"Text.PositionOfAny(text as text, characters as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"characters\",\"type\":\"list\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":51},{\"documentation\":null,\"label\":\"occurrence\",\"type\":\"nullable number\",\"signatureLabelOffset\":53,\"signatureLabelEnd\":82}],\"label\":\"Text.PositionOfAny(text as text, characters as list, occurrence as nullable number)\"}]},{\"export\":\"Text.Proper\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Capitalizes the first letter of each word.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33}],\"label\":\"Text.Proper(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":59}],\"label\":\"Text.Proper(text as nullable text, culture as nullable text)\"}]},{\"export\":\"Text.Range\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the substring found at offset.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50}],\"label\":\"Text.Range(text as nullable text, offset as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":76}],\"label\":\"Text.Range(text as nullable text, offset as number, count as nullable number)\"}]},{\"export\":\"Text.Remove\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes all occurrences of the given character or list of characters from the input text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"removeChars\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":53}],\"label\":\"Text.Remove(text as nullable text, removeChars as any)\"}]},{\"export\":\"Text.RemoveRange\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes a count of characters starting at the given offset\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":56}],\"label\":\"Text.RemoveRange(text as nullable text, offset as number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"count\",\"type\":\"nullable number\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":82}],\"label\":\"Text.RemoveRange(text as nullable text, offset as number, count as nullable number)\"}]},{\"export\":\"Text.Repeat\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a text value composed of the input text repeated a specified number of times.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":50}],\"label\":\"Text.Repeat(text as nullable text, count as number)\"}]},{\"export\":\"Text.Replace\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Replaces all occurrences of the given substring in the text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"old\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"new\",\"type\":\"text\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":60}],\"label\":\"Text.Replace(text as nullable text, old as text, new as text)\"}]},{\"export\":\"Text.ReplaceRange\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes a range of characters and inserts a new value at a specified position.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"offset\",\"type\":\"number\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"newText\",\"type\":\"text\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":91}],\"label\":\"Text.ReplaceRange(text as nullable text, offset as number, count as number, newText as text)\"}]},{\"export\":\"Text.Reverse\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Text.Reverse\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":34}],\"label\":\"Text.Reverse(text as nullable text)\"}]},{\"export\":\"Text.Select\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Selects all occurrences of the given character or list of characters from the input text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"selectChars\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":53}],\"label\":\"Text.Select(text as nullable text, selectChars as any)\"}]},{\"export\":\"Text.Split\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Splits text into a list of text values based upon a specified delimiter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"separator\",\"type\":\"text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":42}],\"label\":\"Text.Split(text as text, separator as text)\"}]},{\"export\":\"Text.SplitAny\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of text values, split on any of the characters in the delimiter.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"separators\",\"type\":\"text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":46}],\"label\":\"Text.SplitAny(text as text, separators as text)\"}]},{\"export\":\"Text.Start\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns the start of the text.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"count\",\"type\":\"number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":49}],\"label\":\"Text.Start(text as nullable text, count as number)\"}]},{\"export\":\"Text.StartsWith\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Indicates whether the text starts with a specified value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":56}],\"label\":\"Text.StartsWith(text as nullable text, substring as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"substring\",\"type\":\"text\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"comparer\",\"type\":\"nullable function\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":87}],\"label\":\"Text.StartsWith(text as nullable text, substring as text, comparer as nullable function)\"}]},{\"export\":\"Text.ToBinary\",\"kind\":\"Function\",\"primitiveType\":\"nullable binary\",\"summary\":\"Encodes text into a binary form.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35}],\"label\":\"Text.ToBinary(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":64}],\"label\":\"Text.ToBinary(text as nullable text, encoding as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":64},{\"documentation\":null,\"label\":\"includeByteOrderMark\",\"type\":\"nullable logical\",\"signatureLabelOffset\":66,\"signatureLabelEnd\":106}],\"label\":\"Text.ToBinary(text as nullable text, encoding as nullable number, includeByteOrderMark as nullable logical)\"}]},{\"export\":\"Text.ToList\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns a list of character values from the given text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Text.ToList(text as text)\"}]},{\"export\":\"Text.Trim\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes all leading and trailing whitespace.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":31}],\"label\":\"Text.Trim(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"trim\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":44}],\"label\":\"Text.Trim(text as nullable text, trim as any)\"}]},{\"export\":\"Text.TrimEnd\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes all trailing whitespace.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":34}],\"label\":\"Text.TrimEnd(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"trim\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":47}],\"label\":\"Text.TrimEnd(text as nullable text, trim as any)\"}]},{\"export\":\"Text.TrimStart\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Removes all leading whitespace.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":36}],\"label\":\"Text.TrimStart(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"trim\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":49}],\"label\":\"Text.TrimStart(text as nullable text, trim as any)\"}]},{\"export\":\"Text.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all text values.\",\"signatures\":null},{\"export\":\"Text.Upper\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Converts all characters to uppercase.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32}],\"label\":\"Text.Upper(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":58}],\"label\":\"Text.Upper(text as nullable text, culture as nullable text)\"}]},{\"export\":\"TextEncoding.Ascii\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the ASCII binary form.\",\"signatures\":null},{\"export\":\"TextEncoding.BigEndianUnicode\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the UTF16 big endian binary form.\",\"signatures\":null},{\"export\":\"TextEncoding.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the text encoding type.\",\"signatures\":null},{\"export\":\"TextEncoding.Unicode\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the UTF16 little endian binary form.\",\"signatures\":null},{\"export\":\"TextEncoding.Utf16\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the UTF16 little endian binary form.\",\"signatures\":null},{\"export\":\"TextEncoding.Utf8\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the UTF8 binary form.\",\"signatures\":null},{\"export\":\"TextEncoding.Windows\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Use to choose the Windows binary form.\",\"signatures\":null},{\"export\":\"Time.EndOfHour\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the last value of the hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":30}],\"label\":\"Time.EndOfHour(dateTime as any)\"}]},{\"export\":\"Time.From\",\"kind\":\"Function\",\"primitiveType\":\"nullable time\",\"summary\":\"Creates a time from the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22}],\"label\":\"Time.From(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":22},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":48}],\"label\":\"Time.From(value as any, culture as nullable text)\"}]},{\"export\":\"Time.FromText\",\"kind\":\"Function\",\"primitiveType\":\"nullable time\",\"summary\":\"Creates a Time from local and universal Time formats.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35}],\"label\":\"Time.FromText(text as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"nullable text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":61}],\"label\":\"Time.FromText(text as nullable text, culture as nullable text)\"}]},{\"export\":\"Time.Hour\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the hour component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":25}],\"label\":\"Time.Hour(dateTime as any)\"}]},{\"export\":\"Time.Minute\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the minute component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":27}],\"label\":\"Time.Minute(dateTime as any)\"}]},{\"export\":\"Time.Second\",\"kind\":\"Function\",\"primitiveType\":\"nullable number\",\"summary\":\"Returns the second component.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":27}],\"label\":\"Time.Second(dateTime as any)\"}]},{\"export\":\"Time.StartOfHour\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the first value of the hour.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dateTime\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":32}],\"label\":\"Time.StartOfHour(dateTime as any)\"}]},{\"export\":\"Time.ToRecord\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record containing the Time value's parts.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"time\",\"type\":\"time\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Time.ToRecord(time as time)\"}]},{\"export\":\"Time.ToText\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a textual representation of the Time value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"time\",\"type\":\"nullable time\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33}],\"label\":\"Time.ToText(time as nullable time)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"time\",\"type\":\"nullable time\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":58}],\"label\":\"Time.ToText(time as nullable time, format as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"time\",\"type\":\"nullable time\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"format\",\"type\":\"nullable text\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":84}],\"label\":\"Time.ToText(time as nullable time, format as nullable text, culture as nullable text)\"}]},{\"export\":\"Time.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all time values.\",\"signatures\":null},{\"export\":\"TraceLevel.Critical\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies Critical trace level.\",\"signatures\":null},{\"export\":\"TraceLevel.Error\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies Error trace level.\",\"signatures\":null},{\"export\":\"TraceLevel.Information\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies Information trace level.\",\"signatures\":null},{\"export\":\"TraceLevel.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the trace level.\",\"signatures\":null},{\"export\":\"TraceLevel.Verbose\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies Verbose trace level.\",\"signatures\":null},{\"export\":\"TraceLevel.Warning\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"Specifies Warning trace level.\",\"signatures\":null},{\"export\":\"Type.AddTableKey\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Adds a key to the given table type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"type\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"columns\",\"type\":\"list\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"isPrimary\",\"type\":\"logical\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":69}],\"label\":\"Type.AddTableKey(table as type, columns as list, isPrimary as logical)\"}]},{\"export\":\"Type.ClosedRecord\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns a closed version of the given record type (or the same type, if it is already closed).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"Type.ClosedRecord(type as type)\"}]},{\"export\":\"Type.Facets\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the facets of a type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":24}],\"label\":\"Type.Facets(type as type)\"}]},{\"export\":\"Type.ForFunction\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns a type that represents functions with specific parameter and return type constraints.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"signature\",\"type\":\"record\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"min\",\"type\":\"number\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":51}],\"label\":\"Type.ForFunction(signature as record, min as number)\"}]},{\"export\":\"Type.ForRecord\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns a type that represents records with specific type constraints on fields.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"fields\",\"type\":\"record\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"open\",\"type\":\"logical\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":48}],\"label\":\"Type.ForRecord(fields as record, open as logical)\"}]},{\"export\":\"Type.FunctionParameters\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record with field values set to the name of the parameters of a function type, and their values set to their corresponding types.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":36}],\"label\":\"Type.FunctionParameters(type as type)\"}]},{\"export\":\"Type.FunctionRequiredParameters\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns a number indicating the minimum number of parameters required to invoke the type of function.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":44}],\"label\":\"Type.FunctionRequiredParameters(type as type)\"}]},{\"export\":\"Type.FunctionReturn\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns a type returned by a function type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":32}],\"label\":\"Type.FunctionReturn(type as type)\"}]},{\"export\":\"Type.Is\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Type.Is\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type1\",\"type\":\"type\",\"signatureLabelOffset\":8,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"type2\",\"type\":\"type\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":36}],\"label\":\"Type.Is(type1 as type, type2 as type)\"}]},{\"export\":\"Type.IsNullable\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns true if a type is a nullable type; otherwise, false.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Type.IsNullable(type as type)\"}]},{\"export\":\"Type.IsOpenRecord\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns whether a record type is open.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"Type.IsOpenRecord(type as type)\"}]},{\"export\":\"Type.ListItem\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns an item type from a list type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Type.ListItem(type as type)\"}]},{\"export\":\"Type.NonNullable\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns the non nullable type from a type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":29}],\"label\":\"Type.NonNullable(type as type)\"}]},{\"export\":\"Type.OpenRecord\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns an opened version of the given record type (or the same type, if it is already open).\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Type.OpenRecord(type as type)\"}]},{\"export\":\"Type.RecordFields\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns a record describing the fields of a record type with each field of the returned record type having a corresponding name and a value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30}],\"label\":\"Type.RecordFields(type as type)\"}]},{\"export\":\"Type.ReplaceFacets\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Replaces the facets of a type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"facets\",\"type\":\"record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":49}],\"label\":\"Type.ReplaceFacets(type as type, facets as record)\"}]},{\"export\":\"Type.ReplaceTableKeys\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns a new table type with all keys replaced by the specified list of keys.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tableType\",\"type\":\"type\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"keys\",\"type\":\"list\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":53}],\"label\":\"Type.ReplaceTableKeys(tableType as type, keys as list)\"}]},{\"export\":\"Type.TableColumn\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns the type of a column in a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tableType\",\"type\":\"type\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"column\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":50}],\"label\":\"Type.TableColumn(tableType as type, column as text)\"}]},{\"export\":\"Type.TableKeys\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"Returns the possibly empty list of keys for the given table type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tableType\",\"type\":\"type\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":32}],\"label\":\"Type.TableKeys(tableType as type)\"}]},{\"export\":\"Type.TableRow\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Type.TableRow\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"type\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":27}],\"label\":\"Type.TableRow(table as type)\"}]},{\"export\":\"Type.TableSchema\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing a description of the columns (i.e. the schema) of the specified table type.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"tableType\",\"type\":\"type\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":34}],\"label\":\"Type.TableSchema(tableType as type)\"}]},{\"export\":\"Type.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all types.\",\"signatures\":null},{\"export\":\"Type.Union\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns the union of a list of types.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"types\",\"type\":\"list\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":24}],\"label\":\"Type.Union(types as list)\"}]},{\"export\":\"Uri.BuildQueryString\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Assemble a record into a URI query string.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"query\",\"type\":\"record\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"Uri.BuildQueryString(query as record)\"}]},{\"export\":\"Uri.Combine\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Returns an absolute URI that is the combination of the input base URI and relative URI.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"baseUri\",\"type\":\"text\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"relativeUri\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":48}],\"label\":\"Uri.Combine(baseUri as text, relativeUri as text)\"}]},{\"export\":\"Uri.EscapeDataString\",\"kind\":\"Function\",\"primitiveType\":\"text\",\"summary\":\"Encodes special characters in accordance with RFC 3986.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"data\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33}],\"label\":\"Uri.EscapeDataString(data as text)\"}]},{\"export\":\"Uri.Parts\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the parts of the input absolute URI as a record.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"absoluteUri\",\"type\":\"text\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":29}],\"label\":\"Uri.Parts(absoluteUri as text)\"}]},{\"export\":\"Uri.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents a text URI.\",\"signatures\":null},{\"export\":\"Value.Add\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the sum of the two values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":38}],\"label\":\"Value.Add(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":68}],\"label\":\"Value.Add(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.As\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Value.As\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":35}],\"label\":\"Value.As(value as any, type as type)\"}]},{\"export\":\"Value.Compare\",\"kind\":\"Function\",\"primitiveType\":\"number\",\"summary\":\"Returns -1, 0, or 1 based on whether the first value is less than, equal to, or greater than the second one.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":42}],\"label\":\"Value.Compare(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":42},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":44,\"signatureLabelEnd\":72}],\"label\":\"Value.Compare(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.Divide\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the result of dividing the first value by the second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41}],\"label\":\"Value.Divide(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":71}],\"label\":\"Value.Divide(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.Equals\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns whether two values are equal.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41}],\"label\":\"Value.Equals(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":71}],\"label\":\"Value.Equals(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.Firewall\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Value.Firewall\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"key\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26}],\"label\":\"Value.Firewall(key as text)\"}]},{\"export\":\"Value.FromText\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Creates a strongly-typed value from a textual representation.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26}],\"label\":\"Value.FromText(text as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"text\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"culture\",\"type\":\"nullable text\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":52}],\"label\":\"Value.FromText(text as any, culture as nullable text)\"}]},{\"export\":\"Value.Is\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Value.Is\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":35}],\"label\":\"Value.Is(value as any, type as type)\"}]},{\"export\":\"Value.Metadata\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a record containing the input's metadata.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":27}],\"label\":\"Value.Metadata(value as any)\"}]},{\"export\":\"Value.Multiply\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the product of the two values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43}],\"label\":\"Value.Multiply(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":73}],\"label\":\"Value.Multiply(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.NativeQuery\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Evaluates a query against a target.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46}],\"label\":\"Value.NativeQuery(target as any, query as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"parameters\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":65}],\"label\":\"Value.NativeQuery(target as any, query as text, parameters as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":46},{\"documentation\":null,\"label\":\"parameters\",\"type\":\"any\",\"signatureLabelOffset\":48,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":93}],\"label\":\"Value.NativeQuery(target as any, query as text, parameters as any, options as nullable record)\"}]},{\"export\":\"Value.NullableEquals\",\"kind\":\"Function\",\"primitiveType\":\"nullable logical\",\"summary\":\"Returns whether two values are equal.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":49}],\"label\":\"Value.NullableEquals(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":79}],\"label\":\"Value.NullableEquals(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.RemoveMetadata\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Strips the input of metadata.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33}],\"label\":\"Value.RemoveMetadata(value as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"metaValue\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":51}],\"label\":\"Value.RemoveMetadata(value as any, metaValue as any)\"}]},{\"export\":\"Value.ReplaceMetadata\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Replaces the input's metadata information.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"metaValue\",\"type\":\"any\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52}],\"label\":\"Value.ReplaceMetadata(value as any, metaValue as any)\"}]},{\"export\":\"Value.ReplaceType\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Value.ReplaceType\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"type\",\"type\":\"type\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":44}],\"label\":\"Value.ReplaceType(value as any, type as type)\"}]},{\"export\":\"Value.Subtract\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the difference of the two values.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43}],\"label\":\"Value.Subtract(value1 as any, value2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"value1\",\"type\":\"any\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"value2\",\"type\":\"any\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":43},{\"documentation\":null,\"label\":\"precision\",\"type\":\"nullable number\",\"signatureLabelOffset\":45,\"signatureLabelEnd\":73}],\"label\":\"Value.Subtract(value1 as any, value2 as any, precision as nullable number)\"}]},{\"export\":\"Value.Type\",\"kind\":\"Function\",\"primitiveType\":\"type\",\"summary\":\"Returns the type of the given value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":23}],\"label\":\"Value.Type(value as any)\"}]},{\"export\":\"Variable.Value\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Variable.Value\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"identifier\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":33}],\"label\":\"Variable.Value(identifier as text)\"}]},{\"export\":\"Xml.Document\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the contents of the XML document as a hierarchical table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"contents\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":28}],\"label\":\"Xml.Document(contents as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"contents\",\"type\":\"any\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":57}],\"label\":\"Xml.Document(contents as any, encoding as nullable number)\"}]},{\"export\":\"Xml.Tables\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the contents of the XML document as a nested collection of flattened tables.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"contents\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26}],\"label\":\"Xml.Tables(contents as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"contents\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":54}],\"label\":\"Xml.Tables(contents as any, options as nullable record)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"contents\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"encoding\",\"type\":\"nullable number\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":83}],\"label\":\"Xml.Tables(contents as any, options as nullable record, encoding as nullable number)\"}]},{\"export\":\"#binary\",\"kind\":\"Constructor\",\"primitiveType\":\"binary\",\"summary\":\"Creates a binary value from a list of numbers or a base 64 encoded text value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":8,\"signatureLabelEnd\":20}],\"label\":\"#binary(value as any) as binary\"}]},{\"export\":\"#date\",\"kind\":\"Constructor\",\"primitiveType\":\"date\",\"summary\":\"Creates a date value from year, month, and day.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"year\",\"type\":\"number\",\"signatureLabelOffset\":6,\"signatureLabelEnd\":20},{\"documentation\":null,\"label\":\"month\",\"type\":\"number\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"day\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":52}],\"label\":\"#date(year as number, month as number, day as number) as date\"}]},{\"export\":\"#datetime\",\"kind\":\"Constructor\",\"primitiveType\":\"datetime\",\"summary\":\"Creates a datetime value from whole numbers year, month, day, hour, minute, and (fractional) second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"year\",\"type\":\"number\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"month\",\"type\":\"number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"day\",\"type\":\"number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":56},{\"documentation\":null,\"label\":\"hour\",\"type\":\"number\",\"signatureLabelOffset\":58,\"signatureLabelEnd\":72},{\"documentation\":null,\"label\":\"minute\",\"type\":\"number\",\"signatureLabelOffset\":74,\"signatureLabelEnd\":90},{\"documentation\":null,\"label\":\"second\",\"type\":\"number\",\"signatureLabelOffset\":92,\"signatureLabelEnd\":108}],\"label\":\"#datetime(year as number, month as number, day as number, hour as number, minute as number, second as number) as datetime\"}]},{\"export\":\"#datetimezone\",\"kind\":\"Constructor\",\"primitiveType\":\"datetimezone\",\"summary\":\"Creates a datetimezone value from whole numbers year, month, day, hour, minute, (fractional) second, (fractional) offset-hours, and offset-minutes.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"year\",\"type\":\"number\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"month\",\"type\":\"number\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"day\",\"type\":\"number\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"hour\",\"type\":\"number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"minute\",\"type\":\"number\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":94},{\"documentation\":null,\"label\":\"second\",\"type\":\"number\",\"signatureLabelOffset\":96,\"signatureLabelEnd\":112},{\"documentation\":null,\"label\":\"offsetHours\",\"type\":\"number\",\"signatureLabelOffset\":114,\"signatureLabelEnd\":135},{\"documentation\":null,\"label\":\"offsetMinutes\",\"type\":\"number\",\"signatureLabelOffset\":137,\"signatureLabelEnd\":160}],\"label\":\"#datetimezone(year as number, month as number, day as number, hour as number, minute as number, second as number, offsetHours as number, offsetMinutes as number) as datetimezone\"}]},{\"export\":\"#duration\",\"kind\":\"Constructor\",\"primitiveType\":\"duration\",\"summary\":\"Creates a duration value from numbers days, hours, minutes, and seconds.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"days\",\"type\":\"number\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"hours\",\"type\":\"number\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"minutes\",\"type\":\"number\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"seconds\",\"type\":\"number\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":79}],\"label\":\"#duration(days as number, hours as number, minutes as number, seconds as number) as duration\"}]},{\"export\":\"#table\",\"kind\":\"Constructor\",\"primitiveType\":\"table\",\"summary\":\"Creates a table value from columns and the list rows where each element of the list is an inner list that contains the column values for a single row. columns may be a list of column names, a table type, a number of columns, or null.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"columns\",\"type\":\"any\",\"signatureLabelOffset\":7,\"signatureLabelEnd\":21},{\"documentation\":null,\"label\":\"rows\",\"type\":\"any\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":34}],\"label\":\"#table(columns as any, rows as any) as table\"}]},{\"export\":\"#time\",\"kind\":\"Constructor\",\"primitiveType\":\"time\",\"summary\":\"Creates a time value from whole numbers hour, minute, and (fractional) second.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"hour\",\"type\":\"number\",\"signatureLabelOffset\":6,\"signatureLabelEnd\":20},{\"documentation\":null,\"label\":\"minute\",\"type\":\"number\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"second\",\"type\":\"number\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":56}],\"label\":\"#time(hour as number, minute as number, second as number) as time\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Access\",\"version\":null,\"exports\":[{\"export\":\"Access.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a structural representation of an Access database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"database\",\"type\":\"binary\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":34}],\"label\":\"Access.Database(database as binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"database\",\"type\":\"binary\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":62}],\"label\":\"Access.Database(database as binary, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"ActiveDirectory\",\"version\":null,\"exports\":[{\"export\":\"ActiveDirectory.Domains\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a list of Active Directory domains in the same forest as the specified domain or of the current machine's domain if none is specified.\",\"signatures\":[{\"parameters\":[],\"label\":\"ActiveDirectory.Domains()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"forestRootDomainName\",\"type\":\"nullable text\",\"signatureLabelOffset\":24,\"signatureLabelEnd\":61}],\"label\":\"ActiveDirectory.Domains(forestRootDomainName as nullable text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"AdobeAnalyticsCube\",\"version\":null,\"exports\":[{\"export\":\"AdobeAnalytics.Cubes\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the report suites in Adobe Analytics.\",\"signatures\":[{\"parameters\":[],\"label\":\"AdobeAnalytics.Cubes()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":47}],\"label\":\"AdobeAnalytics.Cubes(options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"AdoDotNet\",\"version\":null,\"exports\":[{\"export\":\"AdoDotNet.DataSource\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the schema collection for an ADO.NET data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"providerName\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":66}],\"label\":\"AdoDotNet.DataSource(providerName as text, connectionString as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"providerName\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":66},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":68,\"signatureLabelEnd\":94}],\"label\":\"AdoDotNet.DataSource(providerName as text, connectionString as any, options as nullable record)\"}]},{\"export\":\"AdoDotNet.Query\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the result of running a native query on an ADO.NET data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"providerName\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":76}],\"label\":\"AdoDotNet.Query(providerName as text, connectionString as any, query as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"providerName\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":36},{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":38,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":76},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":78,\"signatureLabelEnd\":104}],\"label\":\"AdoDotNet.Query(providerName as text, connectionString as any, query as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"AnalysisServices\",\"version\":null,\"exports\":[{\"export\":\"AnalysisServices.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of multidimensional cubes or tabular models from the Analysis Services database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":58}],\"label\":\"AnalysisServices.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":58},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":60,\"signatureLabelEnd\":86}],\"label\":\"AnalysisServices.Database(server as text, database as text, options as nullable record)\"}]},{\"export\":\"AnalysisServices.Databases\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the Analysis Services databases on a particular host.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41}],\"label\":\"AnalysisServices.Databases(server as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":69}],\"label\":\"AnalysisServices.Databases(server as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"AzureBlob\",\"version\":null,\"exports\":[{\"export\":\"AzureStorage.BlobContents\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the content of the specified blob from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":37}],\"label\":\"AzureStorage.BlobContents(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":65}],\"label\":\"AzureStorage.BlobContents(url as text, options as nullable record)\"}]},{\"export\":\"AzureStorage.Blobs\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a navigational table containing the containers found in the specified account from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34}],\"label\":\"AzureStorage.Blobs(account as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":62}],\"label\":\"AzureStorage.Blobs(account as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"AzureDataLakeStorage\",\"version\":null,\"exports\":[{\"export\":\"AzureStorage.DataLake\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a navigational table containing the documents found in the specified container and its subfolders from Azure Data Lake Storage.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"endpoint\",\"type\":\"text\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":38}],\"label\":\"AzureStorage.DataLake(endpoint as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"endpoint\",\"type\":\"text\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":66}],\"label\":\"AzureStorage.DataLake(endpoint as text, options as nullable record)\"}]},{\"export\":\"AzureStorage.DataLakeContents\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the content of the specified file from an Azure Data Lake Storage filesystem.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":41}],\"label\":\"AzureStorage.DataLakeContents(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":69}],\"label\":\"AzureStorage.DataLakeContents(url as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"AzureTable\",\"version\":null,\"exports\":[{\"export\":\"AzureStorage.Tables\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a navigational table containing the tables found in the specified account from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":35}],\"label\":\"AzureStorage.Tables(account as text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Informix\",\"version\":null,\"exports\":[{\"export\":\"Informix.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views available in an Informix database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50}],\"label\":\"Informix.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":78}],\"label\":\"Informix.Database(server as text, database as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"DB2\",\"version\":null,\"exports\":[{\"export\":\"DB2.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views available in a Db2 database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45}],\"label\":\"DB2.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":73}],\"label\":\"DB2.Database(server as text, database as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Essbase\",\"version\":null,\"exports\":[{\"export\":\"Essbase.Cubes\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the cubes in an Essbase instance grouped by Essbase server.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":25}],\"label\":\"Essbase.Cubes(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":53}],\"label\":\"Essbase.Cubes(url as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"ExcelInterop\",\"version\":null,\"exports\":[{\"export\":\"Excel.CurrentWorkbook\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the tables in the current Excel Workbook.\",\"signatures\":[{\"parameters\":[],\"label\":\"Excel.CurrentWorkbook()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Exchange\",\"version\":null,\"exports\":[{\"export\":\"Exchange.Contents\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of contents from a Microsoft Exchange account.\",\"signatures\":[{\"parameters\":[],\"label\":\"Exchange.Contents()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"mailboxAddress\",\"type\":\"nullable text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":49}],\"label\":\"Exchange.Contents(mailboxAddress as nullable text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Facebook\",\"version\":null,\"exports\":[{\"export\":\"Facebook.Graph\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a record containing content from the Facebook graph.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":26}],\"label\":\"Facebook.Graph(url as text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"File\",\"version\":null,\"exports\":[{\"export\":\"File.Contents\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the contents of the specified file as binary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"File.Contents(path as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":54}],\"label\":\"File.Contents(path as text, options as nullable record)\"}]},{\"export\":\"Folder.Contents\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the properties and contents of the files and folders found in the specifed folder.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28}],\"label\":\"Folder.Contents(path as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":56}],\"label\":\"Folder.Contents(path as text, options as nullable record)\"}]},{\"export\":\"Folder.Files\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the properties and contents of the files found in the specified folder and subfolders.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25}],\"label\":\"Folder.Files(path as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"path\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":25},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":53}],\"label\":\"Folder.Files(path as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"GoogleAnalytics\",\"version\":null,\"exports\":[{\"export\":\"GoogleAnalytics.Accounts\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns Google Analytics accounts.\",\"signatures\":[{\"parameters\":[],\"label\":\"GoogleAnalytics.Accounts()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Hdfs\",\"version\":null,\"exports\":[{\"export\":\"Hdfs.Contents\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the properties and contents of the files and folders found in the specified folder from a Hadoop file system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":25}],\"label\":\"Hdfs.Contents(url as text)\"}]},{\"export\":\"Hdfs.Files\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the properties and contents of the files found in the specified folder and subfolders from a Hadoop file system.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":22}],\"label\":\"Hdfs.Files(url as text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"HdInsight\",\"version\":null,\"exports\":[{\"export\":\"HdInsight.Containers\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a navigational table containing the containers found in the specified account from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":36}],\"label\":\"HdInsight.Containers(account as text)\"}]},{\"export\":\"HdInsight.Contents\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a navigational table containing the containers found in the specified account from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":34}],\"label\":\"HdInsight.Contents(account as text)\"}]},{\"export\":\"HdInsight.Files\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing the properties and contents of the blobs found in the specified container from an Azure storage vault.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"account\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"containerName\",\"type\":\"text\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":54}],\"label\":\"HdInsight.Files(account as text, containerName as text)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Html\",\"version\":null,\"exports\":[{\"export\":\"Web.Page\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the contents of the HTML document broken into its constituent structures, as well as a representation of the full document and its text after removing tags.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"html\",\"type\":\"any\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":20}],\"label\":\"Web.Page(html as any)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"MQ\",\"version\":null,\"exports\":[{\"export\":\"MQ.Queue\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of messages available in the queue via a non-destructive read.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"queuemanager\",\"type\":\"text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"channel\",\"type\":\"text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":62},{\"documentation\":null,\"label\":\"queue\",\"type\":\"text\",\"signatureLabelOffset\":64,\"signatureLabelEnd\":77}],\"label\":\"MQ.Queue(server as text, queuemanager as text, channel as text, queue as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":9,\"signatureLabelEnd\":23},{\"documentation\":null,\"label\":\"queuemanager\",\"type\":\"text\",\"signatureLabelOffset\":25,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"channel\",\"type\":\"text\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":62},{\"documentation\":null,\"label\":\"queue\",\"type\":\"text\",\"signatureLabelOffset\":64,\"signatureLabelEnd\":77},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":79,\"signatureLabelEnd\":105}],\"label\":\"MQ.Queue(server as text, queuemanager as text, channel as text, queue as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"MySQL\",\"version\":null,\"exports\":[{\"export\":\"MySQL.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables, views, and stored scalar functions available in a MySQL database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":47}],\"label\":\"MySQL.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":15,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":47},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":49,\"signatureLabelEnd\":75}],\"label\":\"MySQL.Database(server as text, database as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"OData\",\"version\":null,\"exports\":[{\"export\":\"OData.Feed\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a table of OData feeds offered by an OData service.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"serviceUri\",\"type\":\"text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":29}],\"label\":\"OData.Feed(serviceUri as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"serviceUri\",\"type\":\"text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"headers\",\"type\":\"nullable record\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":57}],\"label\":\"OData.Feed(serviceUri as text, headers as nullable record)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"serviceUri\",\"type\":\"text\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"headers\",\"type\":\"nullable record\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":57},{\"documentation\":null,\"label\":\"options\",\"type\":\"any\",\"signatureLabelOffset\":59,\"signatureLabelEnd\":73}],\"label\":\"OData.Feed(serviceUri as text, headers as nullable record, options as any)\"}]},{\"export\":\"ODataOmitValues.Nulls\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Allows the OData service to omit null values.\",\"signatures\":null},{\"export\":\"ODataOmitValues.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies the kinds of values an OData service can omit.\",\"signatures\":null}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Odbc\",\"version\":null,\"exports\":[{\"export\":\"LimitClauseKind.AnsiSql2008\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"LimitClauseKind.AnsiSql2008\",\"signatures\":null},{\"export\":\"LimitClauseKind.Limit\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"LimitClauseKind.Limit\",\"signatures\":null},{\"export\":\"LimitClauseKind.LimitOffset\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"LimitClauseKind.LimitOffset\",\"signatures\":null},{\"export\":\"LimitClauseKind.None\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"LimitClauseKind.None\",\"signatures\":null},{\"export\":\"LimitClauseKind.Top\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"LimitClauseKind.Top\",\"signatures\":null},{\"export\":\"LimitClauseKind.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"LimitClauseKind.Type\",\"signatures\":null},{\"export\":\"Odbc.DataSource\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views from the ODBC data source. \",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":39}],\"label\":\"Odbc.DataSource(connectionString as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":39},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":41,\"signatureLabelEnd\":67}],\"label\":\"Odbc.DataSource(connectionString as any, options as nullable record)\"}]},{\"export\":\"Odbc.InferOptions\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Returns the result of trying to infer SQL capabilities for an ODBC driver.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":41}],\"label\":\"Odbc.InferOptions(connectionString as any)\"}]},{\"export\":\"Odbc.Query\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the result of running a native query on an ODBC data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":49}],\"label\":\"Odbc.Query(connectionString as any, query as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":49},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":51,\"signatureLabelEnd\":77}],\"label\":\"Odbc.Query(connectionString as any, query as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"OleDb\",\"version\":null,\"exports\":[{\"export\":\"OleDb.DataSource\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views from the OLE DB data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":40}],\"label\":\"OleDb.DataSource(connectionString as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":68}],\"label\":\"OleDb.DataSource(connectionString as any, options as nullable record)\"}]},{\"export\":\"OleDb.Query\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the result of running a native query on an OLE DB data source.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":50}],\"label\":\"OleDb.Query(connectionString as any, query as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"connectionString\",\"type\":\"any\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"query\",\"type\":\"text\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":78}],\"label\":\"OleDb.Query(connectionString as any, query as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Oracle\",\"version\":null,\"exports\":[{\"export\":\"Oracle.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views from the Oracle database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30}],\"label\":\"Oracle.Database(server as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":58}],\"label\":\"Oracle.Database(server as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"PostgreSQL\",\"version\":null,\"exports\":[{\"export\":\"PostgreSQL.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views available in a PostgreSQL database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52}],\"label\":\"PostgreSQL.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":34},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":36,\"signatureLabelEnd\":52},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":54,\"signatureLabelEnd\":80}],\"label\":\"PostgreSQL.Database(server as text, database as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Salesforce\",\"version\":null,\"exports\":[{\"export\":\"Salesforce.Data\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the objects from the Salesforce account.\",\"signatures\":[{\"parameters\":[],\"label\":\"Salesforce.Data()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"loginUrl\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Salesforce.Data(loginUrl as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"loginUrl\",\"type\":\"any\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":59}],\"label\":\"Salesforce.Data(loginUrl as any, options as nullable record)\"}]},{\"export\":\"Salesforce.Reports\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the reports from the Salesforce account.\",\"signatures\":[{\"parameters\":[],\"label\":\"Salesforce.Reports()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"loginUrl\",\"type\":\"nullable text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":44}],\"label\":\"Salesforce.Reports(loginUrl as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"loginUrl\",\"type\":\"nullable text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":72}],\"label\":\"Salesforce.Reports(loginUrl as nullable text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"SapBusinessWarehouse\",\"version\":null,\"exports\":[{\"export\":\"SapBusinessWarehouse.Cubes\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the InfoCubes and queries in an SAP Business Warehouse system grouped by InfoArea.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"systemNumberOrSystemId\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"clientId\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":91}],\"label\":\"SapBusinessWarehouse.Cubes(server as text, systemNumberOrSystemId as text, clientId as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"systemNumberOrSystemId\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"clientId\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":91},{\"documentation\":null,\"label\":\"optionsOrLogonGroup\",\"type\":\"any\",\"signatureLabelOffset\":93,\"signatureLabelEnd\":119}],\"label\":\"SapBusinessWarehouse.Cubes(server as text, systemNumberOrSystemId as text, clientId as text, optionsOrLogonGroup as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":27,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"systemNumberOrSystemId\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":73},{\"documentation\":null,\"label\":\"clientId\",\"type\":\"text\",\"signatureLabelOffset\":75,\"signatureLabelEnd\":91},{\"documentation\":null,\"label\":\"optionsOrLogonGroup\",\"type\":\"any\",\"signatureLabelOffset\":93,\"signatureLabelEnd\":119},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":121,\"signatureLabelEnd\":147}],\"label\":\"SapBusinessWarehouse.Cubes(server as text, systemNumberOrSystemId as text, clientId as text, optionsOrLogonGroup as any, options as nullable record)\"}]},{\"export\":\"SapBusinessWarehouseExecutionMode.BasXml\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'bXML flattening mode' option for MDX execution in SAP Business Warehouse.\",\"signatures\":null},{\"export\":\"SapBusinessWarehouseExecutionMode.BasXmlGzip\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Gzip compressed bXML flattening mode' option for MDX execution in SAP Business Warehouse. Recommended for low latency or high volume queries.\",\"signatures\":null},{\"export\":\"SapBusinessWarehouseExecutionMode.DataStream\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'DataStream flattening mode' option for MDX execution in SAP Business Warehouse.\",\"signatures\":null},{\"export\":\"SapBusinessWarehouseExecutionMode.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Valid options for SAP Business Warehouse execution mode option.\",\"signatures\":null}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"SapHana\",\"version\":null,\"exports\":[{\"export\":\"SapHana.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns the packages in an SAP HANA database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31}],\"label\":\"SapHana.Database(server as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":59}],\"label\":\"SapHana.Database(server as text, options as nullable record)\"}]},{\"export\":\"SapHanaDistribution.All\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'All' distribution option for SAP HANA.\",\"signatures\":null},{\"export\":\"SapHanaDistribution.Connection\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Connection' distribution option for SAP HANA.\",\"signatures\":null},{\"export\":\"SapHanaDistribution.Off\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Off' distribution option for SAP HANA.\",\"signatures\":null},{\"export\":\"SapHanaDistribution.Statement\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Statement' distribution option for SAP HANA.\",\"signatures\":null},{\"export\":\"SapHanaDistribution.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Valid options for SAP HANA distribution option.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.Equals\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Equals' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.GreaterThan\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Greater than' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.GreaterThanOrEquals\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Greater than or equals' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.LessThan\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Less than' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.LessThanOrEquals\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Less than or equals' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.NotEquals\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"'Not equals' range operator for SAP HANA input parameters.\",\"signatures\":null},{\"export\":\"SapHanaRangeOperator.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"A range operator for SAP HANA range input parameters.\",\"signatures\":null}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"SharePoint\",\"version\":null,\"exports\":[{\"export\":\"SharePoint.Contents\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing content from a SharePoint site.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":31}],\"label\":\"SharePoint.Contents(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":59}],\"label\":\"SharePoint.Contents(url as text, options as nullable record)\"}]},{\"export\":\"SharePoint.Files\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing documents from a SharePoint site.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":28}],\"label\":\"SharePoint.Files(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":56}],\"label\":\"SharePoint.Files(url as text, options as nullable record)\"}]},{\"export\":\"SharePoint.Tables\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table containing content from a SharePoint List.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":29}],\"label\":\"SharePoint.Tables(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":29},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":31,\"signatureLabelEnd\":57}],\"label\":\"SharePoint.Tables(url as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Sql\",\"version\":null,\"exports\":[{\"export\":\"Sql.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables, views, and stored functions from the SQL Server database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45}],\"label\":\"Sql.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":27},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":29,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":73}],\"label\":\"Sql.Database(server as text, database as text, options as nullable record)\"}]},{\"export\":\"Sql.Databases\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of databases on a SQL Server.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28}],\"label\":\"Sql.Databases(server as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":28},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":30,\"signatureLabelEnd\":56}],\"label\":\"Sql.Databases(server as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Sybase\",\"version\":null,\"exports\":[{\"export\":\"Sybase.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views available in a Sybase database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":48}],\"label\":\"Sybase.Database(server as text, database as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":30},{\"documentation\":null,\"label\":\"database\",\"type\":\"text\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":76}],\"label\":\"Sybase.Database(server as text, database as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Teradata\",\"version\":null,\"exports\":[{\"export\":\"Teradata.Database\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table of SQL tables and views from the Teradata database.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32}],\"label\":\"Teradata.Database(server as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"server\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":60}],\"label\":\"Teradata.Database(server as text, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Web\",\"version\":null,\"exports\":[{\"export\":\"Soda.Feed\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Returns a table from the contents at the specified URL formatted according to the SODA 2.0 API.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":10,\"signatureLabelEnd\":21}],\"label\":\"Soda.Feed(url as text)\"}]},{\"export\":\"Web.Contents\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the contents downloaded from the url as binary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":24}],\"label\":\"Web.Contents(url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":13,\"signatureLabelEnd\":24},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":52}],\"label\":\"Web.Contents(url as text, options as nullable record)\"}]},{\"export\":\"WebAction.Request\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action that, when executed, will return the results of performing an HTTP request as a binary value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"method\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":45}],\"label\":\"WebAction.Request(method as text, url as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"method\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"url\",\"type\":\"text\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":45},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":47,\"signatureLabelEnd\":73}],\"label\":\"WebAction.Request(method as text, url as text, options as nullable record)\"}]},{\"export\":\"WebMethod.Delete\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the DELETE method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Get\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the GET method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Head\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the HEAD method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Patch\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the PATCH method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Post\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the POST method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Put\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Specifies the PUT method for HTTP.\",\"signatures\":null},{\"export\":\"WebMethod.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies an HTTP method.\",\"signatures\":null}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"WebBrowserContents\",\"version\":null,\"exports\":[{\"export\":\"Web.BrowserContents\",\"kind\":\"Function\",\"primitiveType\":\"nullable null\",\"summary\":\"Web.BrowserContents\",\"signatures\":[{\"parameters\":[],\"label\":\"Web.BrowserContents()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"FuzzyMatching\",\"version\":null,\"exports\":[{\"export\":\"Table.FuzzyJoin\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Joins the rows from the two tables that fuzzy match based on the given keys.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":74}],\"label\":\"Table.FuzzyJoin(table1 as table, key1 as any, table2 as table, key2 as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":103}],\"label\":\"Table.FuzzyJoin(table1 as table, key1 as any, table2 as table, key2 as any, joinKind as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":33,\"signatureLabelEnd\":44},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":46,\"signatureLabelEnd\":61},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":63,\"signatureLabelEnd\":74},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":76,\"signatureLabelEnd\":103},{\"documentation\":null,\"label\":\"joinOptions\",\"type\":\"nullable record\",\"signatureLabelOffset\":105,\"signatureLabelEnd\":135}],\"label\":\"Table.FuzzyJoin(table1 as table, key1 as any, table2 as table, key2 as any, joinKind as nullable number, joinOptions as nullable record)\"}]},{\"export\":\"Table.FuzzyNestedJoin\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Performs a fuzzy join between tables on supplied columns and produces the join result in a new column.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":67},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":69,\"signatureLabelEnd\":80},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":82,\"signatureLabelEnd\":103}],\"label\":\"Table.FuzzyNestedJoin(table1 as table, key1 as any, table2 as table, key2 as any, newColumnName as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":67},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":69,\"signatureLabelEnd\":80},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":82,\"signatureLabelEnd\":103},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":105,\"signatureLabelEnd\":132}],\"label\":\"Table.FuzzyNestedJoin(table1 as table, key1 as any, table2 as table, key2 as any, newColumnName as text, joinKind as nullable number)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table1\",\"type\":\"table\",\"signatureLabelOffset\":22,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"key1\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":50},{\"documentation\":null,\"label\":\"table2\",\"type\":\"table\",\"signatureLabelOffset\":52,\"signatureLabelEnd\":67},{\"documentation\":null,\"label\":\"key2\",\"type\":\"any\",\"signatureLabelOffset\":69,\"signatureLabelEnd\":80},{\"documentation\":null,\"label\":\"newColumnName\",\"type\":\"text\",\"signatureLabelOffset\":82,\"signatureLabelEnd\":103},{\"documentation\":null,\"label\":\"joinKind\",\"type\":\"nullable number\",\"signatureLabelOffset\":105,\"signatureLabelEnd\":132},{\"documentation\":null,\"label\":\"joinOptions\",\"type\":\"nullable record\",\"signatureLabelOffset\":134,\"signatureLabelEnd\":164}],\"label\":\"Table.FuzzyNestedJoin(table1 as table, key1 as any, table2 as table, key2 as any, newColumnName as text, joinKind as nullable number, joinOptions as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"HtmlTable\",\"version\":null,\"exports\":[{\"export\":\"Html.Table\",\"kind\":\"Function\",\"primitiveType\":\"nullable null\",\"summary\":\"Html.Table\",\"signatures\":[{\"parameters\":[],\"label\":\"Html.Table()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Parquet\",\"version\":null,\"exports\":[{\"export\":\"Parquet.Document\",\"kind\":\"Function\",\"primitiveType\":\"nullable null\",\"summary\":\"Parquet.Document\",\"signatures\":[{\"parameters\":[],\"label\":\"Parquet.Document()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Pdf\",\"version\":null,\"exports\":[{\"export\":\"Pdf.Tables\",\"kind\":\"Function\",\"primitiveType\":\"nullable null\",\"summary\":\"Pdf.Tables\",\"signatures\":[{\"parameters\":[],\"label\":\"Pdf.Tables()\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":false,\"isSdkVisible\":false}},{\"module\":\"Action\",\"version\":null,\"exports\":[{\"export\":\"Action.DoNothing\",\"kind\":\"Constant\",\"primitiveType\":\"action\",\"summary\":\"An action that performs no action when executed and returns <code>null</code> as its result.\",\"signatures\":null},{\"export\":\"Action.Return\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action that performs no action when executed and returns the specified value as its result.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"value\",\"type\":\"any\",\"signatureLabelOffset\":14,\"signatureLabelEnd\":26}],\"label\":\"Action.Return(value as any)\"}]},{\"export\":\"Action.Sequence\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action that executes a sequence of actions in order.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"actions\",\"type\":\"list\",\"signatureLabelOffset\":16,\"signatureLabelEnd\":31}],\"label\":\"Action.Sequence(actions as list)\"}]},{\"export\":\"Action.Try\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action that executes the specified action, catching and returning any errors that occur during its execution.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"action\",\"type\":\"action\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":27}],\"label\":\"Action.Try(action as action)\"}]},{\"export\":\"Action.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"The type that represents all actions.\",\"signatures\":null},{\"export\":\"Binary.End\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the end of a binary value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"binary\",\"type\":\"binary\",\"signatureLabelOffset\":11,\"signatureLabelEnd\":27}],\"label\":\"Binary.End(binary as binary)\"}]},{\"export\":\"TableAction.DeleteRows\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action to delete rows from a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37}],\"label\":\"TableAction.DeleteRows(table as table)\"}]},{\"export\":\"TableAction.InsertRows\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action to insert rows into a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"rowsToInsert\",\"type\":\"table\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":60}],\"label\":\"TableAction.InsertRows(table as table, rowsToInsert as table)\"}]},{\"export\":\"TableAction.UpdateRows\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action to update rows in a table.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":23,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"columnUpdates\",\"type\":\"list\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":60}],\"label\":\"TableAction.UpdateRows(table as table, columnUpdates as list)\"}]},{\"export\":\"ValueAction.NativeStatement\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action to execute a statement against a target.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"statement\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60}],\"label\":\"ValueAction.NativeStatement(target as any, statement as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"statement\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"parameters\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":79}],\"label\":\"ValueAction.NativeStatement(target as any, statement as text, parameters as any)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"statement\",\"type\":\"text\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":60},{\"documentation\":null,\"label\":\"parameters\",\"type\":\"any\",\"signatureLabelOffset\":62,\"signatureLabelEnd\":79},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":81,\"signatureLabelEnd\":107}],\"label\":\"ValueAction.NativeStatement(target as any, statement as text, parameters as any, options as nullable record)\"}]},{\"export\":\"ValueAction.Replace\",\"kind\":\"Function\",\"primitiveType\":\"action\",\"summary\":\"Creates an action that replaces the content of a value with the specified value.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"target\",\"type\":\"any\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":33},{\"documentation\":null,\"label\":\"source\",\"type\":\"any\",\"signatureLabelOffset\":35,\"signatureLabelEnd\":48}],\"label\":\"ValueAction.Replace(target as any, source as any)\"}]}],\"visibility\":{\"isInternal\":true,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Crypto\",\"version\":null,\"exports\":[{\"export\":\"Crypto.CreateHash\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Crypto.CreateHash\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"algorithm\",\"type\":\"number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"value\",\"type\":\"binary\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":54}],\"label\":\"Crypto.CreateHash(algorithm as number, value as binary)\"}]},{\"export\":\"Crypto.CreateHmac\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Crypto.CreateHmac\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"algorithm\",\"type\":\"number\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"password\",\"type\":\"any\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":54},{\"documentation\":null,\"label\":\"value\",\"type\":\"binary\",\"signatureLabelOffset\":56,\"signatureLabelEnd\":71}],\"label\":\"Crypto.CreateHmac(algorithm as number, password as any, value as binary)\"}]},{\"export\":\"CryptoAlgorithm.SHA1\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"CryptoAlgorithm.SHA1\",\"signatures\":null},{\"export\":\"CryptoAlgorithm.SHA256\",\"kind\":\"Constant\",\"primitiveType\":\"number\",\"summary\":\"CryptoAlgorithm.SHA256\",\"signatures\":null},{\"export\":\"CryptoAlgorithm.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"Specifies which crypto algorithm to be used.\",\"signatures\":null},{\"export\":\"OAuth1.HMACSHA1\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"OAuth1.HMACSHA1\",\"signatures\":null},{\"export\":\"OAuth1.RSASHA1\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"OAuth1.RSASHA1\",\"signatures\":null},{\"export\":\"OAuth1.Type\",\"kind\":\"Type\",\"primitiveType\":\"type\",\"summary\":\"OAuth1.Type\",\"signatures\":null},{\"export\":\"Web.SignForOAuth1\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Web.SignForOAuth1\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"format\",\"type\":\"text\",\"signatureLabelOffset\":18,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"data\",\"type\":\"binary\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":48},{\"documentation\":null,\"label\":\"secret\",\"type\":\"any\",\"signatureLabelOffset\":50,\"signatureLabelEnd\":63}],\"label\":\"Web.SignForOAuth1(format as text, data as binary, secret as any)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":true,\"isSdkVisible\":true}},{\"module\":\"DataSource\",\"version\":null,\"exports\":[{\"export\":\"DataSource.TestConnection\",\"kind\":\"Function\",\"primitiveType\":\"logical\",\"summary\":\"Returns whether a connection to a datasource can be established and credentials are correct.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"dataSource\",\"type\":\"any\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":43}],\"label\":\"DataSource.TestConnection(dataSource as any)\"}]}],\"visibility\":{\"isInternal\":true,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Delta\",\"version\":null,\"exports\":[{\"export\":\"Delta.Since\",\"kind\":\"Function\",\"primitiveType\":\"table\",\"summary\":\"Delta.Since\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26}],\"label\":\"Delta.Since(table as table)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"table\",\"type\":\"table\",\"signatureLabelOffset\":12,\"signatureLabelEnd\":26},{\"documentation\":null,\"label\":\"tag\",\"type\":\"any\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":38}],\"label\":\"Delta.Since(table as table, tag as any)\"}]}],\"visibility\":{\"isInternal\":true,\"isSdkOnly\":false,\"isSdkVisible\":true}},{\"module\":\"Extensibility\",\"version\":null,\"exports\":[{\"export\":\"Credential.AccessDenied\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Credential.AccessDenied\",\"signatures\":null},{\"export\":\"Credential.AccessForbidden\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Credential.AccessForbidden\",\"signatures\":null},{\"export\":\"Credential.EncryptionNotSupported\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Credential.EncryptionNotSupported\",\"signatures\":null},{\"export\":\"Credential.NativeQueryPermission\",\"kind\":\"Constant\",\"primitiveType\":\"text\",\"summary\":\"Credential.NativeQueryPermission\",\"signatures\":null},{\"export\":\"Environment.FeatureSwitch\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns the value of a feature switch set by the current environment.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"name\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":38}],\"label\":\"Environment.FeatureSwitch(name as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"name\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":38},{\"documentation\":null,\"label\":\"default\",\"type\":\"any\",\"signatureLabelOffset\":40,\"signatureLabelEnd\":54}],\"label\":\"Environment.FeatureSwitch(name as text, default as any)\"}]},{\"export\":\"Error.Unexpected\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Error.Unexpected\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":41}],\"label\":\"Error.Unexpected(message as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":41},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":43,\"signatureLabelEnd\":69}],\"label\":\"Error.Unexpected(message as nullable text, options as nullable record)\"}]},{\"export\":\"Extension.Contents\",\"kind\":\"Function\",\"primitiveType\":\"binary\",\"summary\":\"Returns the contents of the specified file within the library PQX file as binary.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"file\",\"type\":\"text\",\"signatureLabelOffset\":19,\"signatureLabelEnd\":31}],\"label\":\"Extension.Contents(file as text)\"}]},{\"export\":\"Extension.CredentialError\",\"kind\":\"Function\",\"primitiveType\":\"record\",\"summary\":\"Extension.CredentialError\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40}],\"label\":\"Extension.CredentialError(reason as text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":66}],\"label\":\"Extension.CredentialError(reason as text, message as nullable text)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"reason\",\"type\":\"text\",\"signatureLabelOffset\":26,\"signatureLabelEnd\":40},{\"documentation\":null,\"label\":\"message\",\"type\":\"nullable text\",\"signatureLabelOffset\":42,\"signatureLabelEnd\":66},{\"documentation\":null,\"label\":\"detail\",\"type\":\"nullable record\",\"signatureLabelOffset\":68,\"signatureLabelEnd\":93}],\"label\":\"Extension.CredentialError(reason as text, message as nullable text, detail as nullable record)\"}]},{\"export\":\"Extension.CurrentApplication\",\"kind\":\"Function\",\"primitiveType\":\"nullable record\",\"summary\":\"Extension.CurrentApplication\",\"signatures\":[{\"parameters\":[],\"label\":\"Extension.CurrentApplication()\"}]},{\"export\":\"Extension.CurrentCredential\",\"kind\":\"Function\",\"primitiveType\":\"nullable record\",\"summary\":\"Extension.CurrentCredential\",\"signatures\":[{\"parameters\":[],\"label\":\"Extension.CurrentCredential()\"},{\"parameters\":[{\"documentation\":null,\"label\":\"forceRefresh\",\"type\":\"nullable logical\",\"signatureLabelOffset\":28,\"signatureLabelEnd\":60}],\"label\":\"Extension.CurrentCredential(forceRefresh as nullable logical)\"}]},{\"export\":\"Extension.InvokeWithCredentials\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Invokes a function in the context of the provided credential handler.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"authenticationHandler\",\"type\":\"function\",\"signatureLabelOffset\":32,\"signatureLabelEnd\":65},{\"documentation\":null,\"label\":\"function\",\"type\":\"function\",\"signatureLabelOffset\":67,\"signatureLabelEnd\":87}],\"label\":\"Extension.InvokeWithCredentials(authenticationHandler as function, function as function)\"}]},{\"export\":\"Extension.LoadString\",\"kind\":\"Function\",\"primitiveType\":\"nullable text\",\"summary\":\"Returns a localized string from the library PQX file.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"string\",\"type\":\"text\",\"signatureLabelOffset\":21,\"signatureLabelEnd\":35}],\"label\":\"Extension.LoadString(string as text)\"}]},{\"export\":\"Extension.Module\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Extension.Module\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"moduleName\",\"type\":\"text\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":35},{\"documentation\":null,\"label\":\"resourceKinds\",\"type\":\"list\",\"signatureLabelOffset\":37,\"signatureLabelEnd\":58}],\"label\":\"Extension.Module(moduleName as text, resourceKinds as list)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":true,\"isSdkVisible\":true}},{\"module\":\"ParallelEvaluation\",\"version\":null,\"exports\":[{\"export\":\"List.ParallelInvoke\",\"kind\":\"Function\",\"primitiveType\":\"list\",\"summary\":\"List.ParallelInvoke\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":32}],\"label\":\"List.ParallelInvoke(list as list)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"list\",\"type\":\"list\",\"signatureLabelOffset\":20,\"signatureLabelEnd\":32},{\"documentation\":null,\"label\":\"concurrency\",\"type\":\"nullable number\",\"signatureLabelOffset\":34,\"signatureLabelEnd\":64}],\"label\":\"List.ParallelInvoke(list as list, concurrency as nullable number)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":true,\"isSdkVisible\":true}},{\"module\":\"OpenApi\",\"version\":null,\"exports\":[{\"export\":\"OpenApi.Document\",\"kind\":\"Function\",\"primitiveType\":\"any\",\"summary\":\"Returns a table of operations from an Open API definition.\",\"signatures\":[{\"parameters\":[{\"documentation\":null,\"label\":\"definition\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":37}],\"label\":\"OpenApi.Document(definition as binary)\"},{\"parameters\":[{\"documentation\":null,\"label\":\"definition\",\"type\":\"binary\",\"signatureLabelOffset\":17,\"signatureLabelEnd\":37},{\"documentation\":null,\"label\":\"options\",\"type\":\"nullable record\",\"signatureLabelOffset\":39,\"signatureLabelEnd\":65}],\"label\":\"OpenApi.Document(definition as binary, options as nullable record)\"}]}],\"visibility\":{\"isInternal\":false,\"isSdkOnly\":true,\"isSdkVisible\":true}}]");

/***/ }),

/***/ "../packages/powerquery-library/lib/library/staticLibrarySymbolProvider.js":
/*!*********************************************************************************!*\
  !*** ../packages/powerquery-library/lib/library/staticLibrarySymbolProvider.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(/*! ./index */ "../packages/powerquery-library/lib/library/index.js");
const Utils = __webpack_require__(/*! ./utils */ "../packages/powerquery-library/lib/library/utils.js");
function createLibraryProvider() {
    return new StaticLibrarySymbolProvider();
}
exports.createLibraryProvider = createLibraryProvider;
class StaticLibrarySymbolProvider {
    constructor() {
        this.activeLibrary = index_1.AllModules;
    }
    includeModules(_modules) {
        throw new Error("Method not implemented.");
    }
    getCompletionItems(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context.range) {
                return Utils.cloneCompletionItemsWithRange(this.getCachedCompletionItems(), context.range);
            }
            return this.getCachedCompletionItems();
        });
    }
    getHover(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const definition = this.activeLibrary.get(context.identifier);
            if (definition) {
                return Utils.libraryDefinitionToHover(definition, context.range);
            }
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    getSignatureHelp(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const functionName = context.maybeFunctionName;
            if (functionName) {
                const definition = this.activeLibrary.get(functionName);
                if (definition) {
                    const signatures = Utils.signaturesToSignatureInformation(definition.signatures, definition.summary);
                    return {
                        signatures: signatures,
                        // tslint:disable-next-line: no-null-keyword
                        activeParameter: context.maybeArgumentOrdinal ? context.maybeArgumentOrdinal : null,
                        activeSignature: signatures.length - 1,
                    };
                }
            }
            // tslint:disable-next-line: no-null-keyword
            return null;
        });
    }
    getCachedCompletionItems() {
        if (!this.cachedCompletionItems) {
            this.cachedCompletionItems = [];
            for (const definition of this.activeLibrary.values()) {
                const completionItem = Utils.libraryDefinitionToCompletionItem(definition);
                this.cachedCompletionItems.push(completionItem);
            }
        }
        return this.cachedCompletionItems;
    }
}
//# sourceMappingURL=staticLibrarySymbolProvider.js.map

/***/ }),

/***/ "../packages/powerquery-library/lib/library/utils.js":
/*!***********************************************************!*\
  !*** ../packages/powerquery-library/lib/library/utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-types/lib/esm/main.js");
function cloneCompletionItemsWithRange(completionItems, range) {
    const result = [];
    completionItems.forEach(item => {
        result.push(Object.assign(Object.assign({}, item), { textEdit: {
                range: range,
                newText: item.label,
            } }));
    });
    return result;
}
exports.cloneCompletionItemsWithRange = cloneCompletionItemsWithRange;
function libraryDefinitionToCompletionItem(definition) {
    return {
        label: definition.label,
        kind: exportKindToCompletionItemKind(definition.kind),
        documentation: definition.summary,
    };
}
exports.libraryDefinitionToCompletionItem = libraryDefinitionToCompletionItem;
function libraryDefinitionToHover(definition, range) {
    let contents;
    // TODO: move this into LibraryDefinition - we should be able to call ".getMarkdownFormattedString()"
    if (isFunction(definition)) {
        contents = formatFunctionDefinition(definition);
    }
    else if (definition.kind === "Type" /* Type */) {
        contents = formatTypeDefinition(definition);
    }
    else {
        contents = formatConstantDefinition(definition);
    }
    return {
        contents,
        range,
    };
}
exports.libraryDefinitionToHover = libraryDefinitionToHover;
function isFunction(definition) {
    return (definition &&
        (definition.kind === "Function" /* Function */ || definition.kind === "Constructor" /* Constructor */));
}
exports.isFunction = isFunction;
function exportKindToCompletionItemKind(kind) {
    switch (kind) {
        case "Constant" /* Constant */:
            return vscode_languageserver_types_1.CompletionItemKind.Constant;
        case "Constructor" /* Constructor */:
            return vscode_languageserver_types_1.CompletionItemKind.Constructor;
        case "Function" /* Function */:
            return vscode_languageserver_types_1.CompletionItemKind.Function;
        case "Type" /* Type */:
            return vscode_languageserver_types_1.CompletionItemKind.TypeParameter;
        default:
            throw new Error(`Unmapped ExportKind: ${kind}`);
    }
}
exports.exportKindToCompletionItemKind = exportKindToCompletionItemKind;
function signaturesToSignatureInformation(signatures, summary) {
    return signatures.map(signature => {
        return {
            label: signature.label,
            documentation: summary !== null && summary !== void 0 ? summary : "",
            parameters: parametersToParameterInformation(signature.parameters),
        };
    });
}
exports.signaturesToSignatureInformation = signaturesToSignatureInformation;
function parametersToParameterInformation(parameters) {
    return parameters.map(parameter => {
        var _a;
        return {
            label: [parameter.signatureLabelOffset, parameter.signatureLabelEnd],
            documentation: (_a = parameter.documentation) !== null && _a !== void 0 ? _a : parameter.type,
        };
    });
}
exports.parametersToParameterInformation = parametersToParameterInformation;
function formatTypeDefinition(definition) {
    return {
        kind: vscode_languageserver_types_1.MarkupKind.Markdown,
        value: `(type) ${definition.label}\n\n\n${definition.summary}`,
    };
}
function formatConstantDefinition(definition) {
    return {
        kind: vscode_languageserver_types_1.MarkupKind.Markdown,
        value: `(constant) ${definition.label}\n\n\n${definition.summary}`,
    };
}
function formatFunctionDefinition(definition) {
    // TODO: assert that we have at least one signature
    return {
        kind: vscode_languageserver_types_1.MarkupKind.Markdown,
        value: [
            "```powerquery",
            definition.signatures[definition.signatures.length - 1].label,
            "```",
            definition.summary,
        ].join("\n"),
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const powerquery_format_1 = __webpack_require__(/*! @microsoft/powerquery-format */ "../packages/powerquery-format/lib/index.js");
const LanguageServices = __webpack_require__(/*! @microsoft/powerquery-language-services */ "../packages/powerquery-language-services/lib/index.js");
const Library = __webpack_require__(/*! @microsoft/powerquery-library */ "../packages/powerquery-library/lib/index.js");
const powerquery_parser_1 = __webpack_require__(/*! @microsoft/powerquery-parser */ "../packages/powerquery-format/node_modules/@microsoft/powerquery-parser/lib/index.js");
const LS = __webpack_require__(/*! vscode-languageserver */ "../node_modules/vscode-languageserver/lib/main.js");
const vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ "../node_modules/vscode-languageserver-textdocument/lib/esm/main.js");
// Create a connection for the server. The connection uses Node's IPC as a transport.
// Also include all preview / proposed LSP features.
const connection = LS.createConnection(LS.ProposedFeatures.all);
const documents = new LS.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
let analysisOptions;
connection.onInitialize(() => {
    return {
        capabilities: {
            textDocumentSync: LS.TextDocumentSyncKind.Incremental,
            documentFormattingProvider: true,
            completionProvider: {
                // TODO: is it better to return the first pass without documention to reduce message size?
                resolveProvider: false,
            },
            hoverProvider: true,
            signatureHelpProvider: {
                triggerCharacters: ["(", ","],
            },
        },
    };
});
connection.onInitialized(() => {
    analysisOptions = {
        librarySymbolProvider: Library.createLibraryProvider(),
    };
});
documents.onDidClose(event => {
    LanguageServices.documentClosed(event.document);
});
// TODO: Support incremental lexing.
// TextDocuments uses the connection's onDidChangeTextDocument, and I can't see a way to provide a second
// one to intercept incremental changes. TextDocuments.OnDidChangeContent only provides the full document.
documents.onDidChangeContent(event => {
    LanguageServices.documentUpdated(event.document);
    validateDocument(event.document).catch(err => connection.console.error(`validateDocument err: ${JSON.stringify(err, undefined, 4)}`));
});
function validateDocument(document) {
    return __awaiter(this, void 0, void 0, function* () {
        const validationResult = LanguageServices.validate(document);
        connection.sendDiagnostics({
            uri: document.uri,
            diagnostics: validationResult.diagnostics,
        });
    });
}
connection.onDocumentFormatting((documentfomattingParams) => {
    const maybeDocument = documents.get(documentfomattingParams.textDocument.uri);
    if (maybeDocument === undefined) {
        return [];
    }
    const document = maybeDocument;
    const options = documentfomattingParams.options;
    const textEditResult = [];
    let indentationLiteral;
    if (options.insertSpaces) {
        indentationLiteral = "    " /* SpaceX4 */;
    }
    else {
        indentationLiteral = "\t" /* Tab */;
    }
    const formatSettings = Object.assign(Object.assign({}, powerquery_parser_1.DefaultSettings), { indentationLiteral, 
        // TODO: get the newline terminator for the document/workspace
        newlineLiteral: "\r\n" /* Windows */ });
    const formatResult = powerquery_format_1.format(formatSettings, document.getText());
    if (formatResult.kind === "Ok" /* Ok */) {
        textEditResult.push(LS.TextEdit.replace(fullDocumentRange(document), formatResult.value));
    }
    else {
        // TODO: should this go in the failed promise path?
        const error = formatResult.error;
        let message;
        if (powerquery_format_1.FormatError.isTFormatError(error)) {
            message = error.innerError.message;
        }
        else {
            message = "An unknown error occured during formatting.";
        }
        connection.window.showErrorMessage(message);
    }
    return textEditResult;
});
// TODO: is there a better way to do this?
function fullDocumentRange(document) {
    return {
        start: document.positionAt(0),
        end: {
            line: document.lineCount - 1,
            character: Number.MAX_VALUE,
        },
    };
}
connection.onCompletion((textDocumentPosition, _token) => __awaiter(void 0, void 0, void 0, function* () {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (document) {
        const analysis = LanguageServices.createAnalysisSession(document, textDocumentPosition.position, analysisOptions);
        return analysis.getCompletionItems().catch(err => {
            connection.console.error(`onCompletion error ${JSON.stringify(err, undefined, 4)}`);
            return [];
        });
    }
    return [];
}));
connection.onHover((textDocumentPosition, _token) => __awaiter(void 0, void 0, void 0, function* () {
    const emptyHover = {
        range: undefined,
        contents: [],
    };
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (document) {
        const analysis = LanguageServices.createAnalysisSession(document, textDocumentPosition.position, analysisOptions);
        return analysis.getHover().catch(err => {
            connection.console.error(`onHover error ${JSON.stringify(err, undefined, 4)}`);
            return emptyHover;
        });
    }
    return emptyHover;
}));
connection.onSignatureHelp((textDocumentPosition, _token) => __awaiter(void 0, void 0, void 0, function* () {
    const emptySignatureHelp = {
        signatures: [],
        // tslint:disable-next-line: no-null-keyword
        activeParameter: null,
        activeSignature: 0,
    };
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (document) {
        const analysis = LanguageServices.createAnalysisSession(document, textDocumentPosition.position, analysisOptions);
        return analysis.getSignatureHelp().catch(err => {
            connection.console.error(`onSignatureHelp error ${JSON.stringify(err, undefined, 4)}`);
            return emptySignatureHelp;
        });
    }
    return emptySignatureHelp;
}));
// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);
// Listen on the connection
connection.listen();


/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ })

/******/ });
//# sourceMappingURL=server.js.map